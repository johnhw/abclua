<h1 id="abclua-0.1">ABCLua 0.1</h1>
<h2 id="description">Description</h2>
<p>Simple ABC parsing for Lua. This library can read a reasonable subset of ABC 2.1 and generate Lua tables representing the song structure.</p>
<p>It can transform ABC source into a token stream, transform a token stream into an ABC string, transform a token stream into an event stream (with timing, repeats expanded etc.), and transform these event streams into MIDI.</p>
<h2 id="example">Example</h2>
<pre><code>require &quot;abclua_all&quot;
-- Assuming you have Peter J. Billam&#39;s MIDI.lua
tunes = abclua.parse_abc_file(&#39;skye.abc&#39;)
opus = abclua.make_midi(tunes[1], &#39;skye.mid&#39;)   </code></pre>
<h3 id="requires">Requires:</h3>
<ul>
<li><a href="http://www.lua.org">Lua 5.2</a></li>
<li><a href="http://www.inf.puc-rio.br/~roberto/lpeg">LPeg</a></li>
</ul>
<h3 id="optional">Optional:</h3>
<ul>
<li><a href="http://www.pjb.com.au/comp/lua/MIDI.html">MIDI.lua</a></li>
</ul>
<h2 id="using">Using</h2>
<p>You can use this file just by requiring abclua_all.lua, which has all the functions in one single file as a convenience.</p>
<pre><code>require &quot;abclua_all.lua&quot;</code></pre>
<p>ABCLua has three main functions: <em>parsing</em> ABC text into a sequence of tokens; <em>emitting</em> ABC text from a sequence of tokens; and <em>compiling</em> token sequeneces into event sequences.</p>
<p>The compilation procedure expands repetitions, parts, voices, etc. and applies timing and pitching information to notes. The output format can easily be translated to MIDI or to another playback or display format.</p>
<h2 id="api">API</h2>
<p>The basic datastructure is the <em>song</em> table.</p>
<pre><code>song -&gt;
    
    song.token_stream -&gt;    parsed input as a stream of tokens. This is generated by the parser.
    
    song.voices -&gt;          each voice in the song (there is alwaays a voice called &quot;default&quot;).
                            song.voices is created when the token stream is compiled (e.g. with compile_abc)

        song.voice[id].stream -&gt;          event stream generated from the token stream
        song.voice[id].context -&gt;         table representing the current state of the song 
                                 (e.g. meter, tempo, key)
    
        
    Every token has
            token.token          The type of this token
            ...along with custom fields for each token
        
    Every event has 
            event.event         String giving event type
            event.t             Time of event, in microseconds
            ...along with custom fields for each event
                                </code></pre>
<ul>
<li><p><code>parse_abc(str, [options])</code><br />Parse a single ABC notation string, and return a song structure. The parsed tokens are stored in the table <code>song.token_stream</code>.</p></li>
<li><p><code>compile_abc(song)</code> Compile a song. Converts the sequence of tokens in a song into an event stream which is stored in song.stream.</p></li>
<li><p><code>parse_abc_fragment(str, [context])</code> Parse a fragment of ABC (e.g. 'abc | def') in a given context (uses the default context if one is not provided). Returns the token sequence for that fragment.</p>
<p>songs = parse_abc_file('example.abc') -- parse the fragment in the context of the first song loaded parse_abc_fragment('de&gt;d', songs[1].context)</p></li>
<li><p><code>parse_abc_multisong(str, [options])</code> Parse and compile the given string, which can be blocks of ABC and plain text interspersed, separated by blank lines (e.g. an entire songbook). Returns a table of song structures.</p></li>
<li><p><code>parse_abc_file(filename, [options])</code> Parse and compile the given ABC file, and return a table of songs, one for each tune in the songbook. This is just a convenience for reading a file and calling parse_abc_multisong() on it.</p>
<p>songs = parse_abc_file('example.abc') -- songs[1] is the first tune -- songs[2] is the second tune etc.</p></li>
<li><p><code>compile_tokens(tokens)</code> Convert a token stream into an event stream, with timing information.</p>
<pre><code>-- parse the fragment in the context of the first song loaded
tokens = parse_abc_fragment(&#39;de&gt;d&#39;)
stream = compile_tokens(tokens)</code></pre></li>
<li><p><code>emit_abc(tokens)</code> Return an ABC string represenation of a given token stream songs = parse_abc_file('example.abc') -- should print out something close to the first tune in the original example.abc print(token_stream_to_abc(songs[1].token_stream))</p></li>
<li><p><code>abc_from_songs(songs)</code> Return a ABC string from a table of songs. songs = parse_abc_file('example.abc') -- should print out something close to the original example.abc print(abc_from_songs(songs))</p></li>
<li><p><code>make_midi(song, filename)</code> Simple MIDI conversion; writes the MIDI file to filename. songs = parse_abc_file('example.abc')<br /> make_midi(songs[1], 'example.mid')</p></li>
</ul>
<h2 id="test-scripts">Test scripts</h2>
<p><code>tests/reproduce_abc.lua</code> takes a filename as an argument, and creates a file called <filename>_reproduced.abc which is the result of parsing the given file and emitting the ABC representation of the token stream. It should leave files basically unchanged</p>
<p><code>tests/abc_to_midi.lua</code> converts an ABC file to a simple MIDI file. It should render most files correctly.</p>
<h2 id="development">Development</h2>
<p><code>abclua_all.lua</code> contains the entire parser/emitter/compiler as a single convenient file. For developers who want to modify the ABCLua source, the individual sub-components are in separate .lua files in src. Require &quot;abclua&quot; instead of &quot;abclua_all&quot; to load the module which loads files with these subcomponents.</p>
<p>If you want to modify the source and still use <code>abclua_all.lua</code>, modify the files in src and rebuild <code>abclua_all.lua</code> by running <code>lua make_abclua.lua</code>. Do <strong>not</strong> edit <code>abclua_all.lua</code> directly!</p>
<h2 id="supported-features">Supported features</h2>
<p>ABCLua supports most of the 2.1 standard; tested features include:</p>
<ul>
<li>All standard note descriptions and tune metadata fields</li>
<li>Complex meters <code>M:(1+4+2)/8</code></li>
<li>Full key definitions <code>K:C locrian ^c _g alto t=-2</code></li>
<li>Multi-tune songbooks</li>
<li>Tuplets <code>(3 abc (5:2:7 abcdefg</code></li>
<li>Aligned lyrics <code>+w: th-ese wor-ds are al-igned in the event stre-a-m</code><br /></li>
<li>Grace notes, decorations <code>{cf}!fermata!~G</code></li>
<li>Slurs and chords <code>(ABC)</code> and <code>[Ceg]</code></li>
<li>Named chords <code>&quot;Cm7&quot;C G F | &quot;Dmaj&quot; D e' f |</code></li>
<li>Repeats (with variable counts, such as <code>|::: :::|</code>) and variant endings <code>|: abc :|1 def |2 fed ||</code></li>
<li>Parts with variant endings</li>
<li>Multi-voice songs <code>V:v1</code></li>
<li>Voice overlay with <code>&amp;</code></li>
<li>Macros, user macros and transposing macros</li>
<li><code>abc-include</code> to include files</li>
</ul>
<p>See <code>tests/test_abc.lua</code> for examples of these in use.</p>
<h2 id="limitations">Limitations</h2>
<h3 id="transposing-macros">Transposing macros</h3>
<p>Transposing macros are supported, but only work with notes without explicit octave symbols. For example:</p>
<pre><code>m:~n2={op}n2
A2 b2 c&#39;2    </code></pre>
<p>produces</p>
<pre><code>{Bc}A2 {c&#39;d&#39;}b2 c&#39;2 </code></pre>
<p>because the macro does not match n'2. It is not clear whether this is the behavour the standard intended.</p>
<h3 id="expansion">Expansion</h3>
<p>Macros are expanded as they are read, so they will appear in the token stream expanded. The macro definitions are stripped from the song. So <code>reproduce_abc.lua</code> will turn</p>
<pre><code>m:a=g
abc        </code></pre>
<p>into</p>
<pre><code>gbc</code></pre>
<p><code>abc-include</code></p>
<pre><code>    I:abc-include file.abc
    </code></pre>
<p>will include the <code>file.abc</code>. But note that the instruction field will not appear in the token stream -- instead the contents of &quot;file.abc&quot; will appear in place. If a file is included more than once inside a song, all includes except the first are ignored. This eliminates recursive includes but might have confounding effects.</p>
<p>Macro expansion and abc-include can be disabled by setting <code>no_expand=true</code> in the options passed to parse_abc_multisong(), parse_abc_file() or parse_abc_fragment(). Example:</p>
<pre><code>parse_abc_file(&#39;macros.abc&#39;, {no_expand=false}) -- parses the file with macros enabled
parse_abc_file(&#39;macros.abc&#39;, {no_expand=true}) -- parses the file with macros disabled, macro fields are passed through</code></pre>
<h2 id="license">License</h2>
<pre><code>Licensened under the BSD 3 clause license.
    
* Copyright (c) 2013, John Williamson
* All rights reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions are met:
*     * Redistributions of source code must retain the above copyright
*       notice, this list of conditions and the following disclaimer.
*     * Redistributions in binary form must reproduce the above copyright
*       notice, this list of conditions and the following disclaimer in the
*       documentation and/or other materials provided with the distribution.
*     * Neither the name of the &lt;organization&gt; nor the
*       names of its contributors may be used to endorse or promote products
*       derived from this software without specific prior written permission.
*
* THIS SOFTWARE IS PROVIDED BY &lt;copyright holder&gt; ``AS IS&#39;&#39; AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
* WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
* DISCLAIMED. IN NO EVENT SHALL &lt;copyright holder&gt; BE LIABLE FOR ANY
* DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
* (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
* LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
* ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
* SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.**
 </code></pre>
