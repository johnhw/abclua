# ABCLua 0.1


## Description
Simple ABC parsing for Lua. This library can read a reasonable
subset of ABC 2.1 and generate Lua tables representing the song structure.

It can transform ABC source into a token stream, transform a token 
stream into an ABC string, transform a token stream into an event stream
(with timing, repeats expanded etc.), and transform these event streams into MIDI.


## Example
    require "abclua_all"
    -- Assuming you have Peter J. Billam's MIDI.lua
    tunes = abclua.parse_abc_file('skye.abc')
    abclua.make_midi(tunes[1], 'skye.mid')   


### Requires: 
* [Lua 5.2](http://www.lua.org)
* [LPeg](http://www.inf.puc-rio.br/~roberto/lpeg)

### Optional:    
* [MIDI.lua](http://www.pjb.com.au/comp/lua/MIDI.html)

    
## Using
You can use this file just by requiring abclua_all.lua, which has all the
functions in one single file as a convenience.

    require "abclua_all.lua"

ABCLua has three main functions: *parsing* ABC text into a sequence of tokens; *emitting* ABC text from a sequence of tokens; and *compiling* token sequeneces into event sequences. 

The compilation procedure expands repetitions, parts, voices, etc. and applies timing and pitching information to notes. The output format can easily be translated to MIDI or to another playback or display format.
    
## API

The basic datastructure is the *song* table. 

    song ->
        
        song.token_stream ->    parsed input as a stream of tokens. This is generated by the parser.
        
        song.voices ->          each voice in the song (there is alwaays a voice called "default").
                                song.voices is created when the token stream is compiled (e.g. with compile_abc)

            song.voice[id].stream ->          event stream generated from the token stream
            song.voice[id].context ->         table representing the current state of the song 
                                     (e.g. meter, tempo, key)
        
            
        Every token has
                token.token          The type of this token
                ...along with custom fields for each token
            
        Every event has 
                event.event         String giving event type
                event.t             Time of event, in microseconds
                ...along with custom fields for each event
                                    
* `parse_abc(str, [options])`  

Parse a single ABC notation string, and return a song structure. The parsed tokens are
stored in the table `song.token_stream`.
        
* `compile_abc(song)`

Compile a song. Converts the sequence of tokens in a song into an event stream
which is stored in song.stream.


* `parse_abc_fragment(str, [context])`

Parse a fragment of ABC (e.g. 'abc | def') in a given context (uses the default context if
one is not provided). Returns the token sequence for that fragment.


        songs = parse_abc_file('example.abc')
        -- parse the fragment in the context of the first song loaded
        parse_abc_fragment('de>d', songs[1].context)

    
* `parse_abc_multisong(str, [options])`

Parse and compile the given string, which can be blocks of ABC and plain text interspersed, separated by blank lines (e.g. an entire songbook). Returns a table of song structures.
    
* `parse_abc_file(filename, [options])`

Parse and compile the given ABC file, and return a table of songs, one for each tune in the songbook. This is 
just a convenience for reading a file and calling parse_abc_multisong() on it.
        
    songs = parse_abc_file('example.abc')
    -- songs[1] is the first tune
    -- songs[2] is the second tune etc.
            
        
* `compile_tokens(tokens)`

Convert a token stream into an event stream, with timing information.
        
        -- parse the fragment in the context of the first song loaded
        tokens = parse_abc_fragment('de>d')
        stream = compile_tokens(tokens)
        
* `emit_abc(tokens)`

Return an ABC string represenation of a given token stream
            songs = parse_abc_file('example.abc')
            -- should print out something close to the first tune in the original example.abc
            print(token_stream_to_abc(songs[1].token_stream))
                    
* `abc_from_songs(songs)`

Return a ABC string from a table of songs.
        songs = parse_abc_file('example.abc')
        -- should print out something close to the original example.abc
        print(abc_from_songs(songs))
        
* `make_midi(song, filename)`

Simple MIDI conversion; writes the MIDI file to filename.
        songs = parse_abc_file('example.abc')            
        make_midi(songs[1], 'example.mid')
        
    
## Test scripts
`tests/reproduce_abc.lua` takes a filename as an argument, and creates a file called
<filename>_reproduced.abc which is the result of parsing the given file and
emitting the ABC representation of the token stream. It should leave files
basically unchanged 

`tests/abc_to_midi.lua` converts an ABC file to a simple MIDI file. It should render
most files correctly.
        

## Development
`abclua_all.lua` contains the entire parser/emitter/compiler as a single convenient file. 
For developers who want to modify the ABCLua source, the individual sub-components are in separate .lua files in src. Require "abclua" instead of "abclua_all" to load the module which loads files with these subcomponents.

If you want to modify the source and still use `abclua_all.lua`, modify the files in 
src and rebuild `abclua_all.lua` by running `lua make_abclua.lua`. 
Do **not** edit `abclua_all.lua` directly!

## Supported features

ABCLua supports most of the 2.1 standard; tested features include:

* All standard note descriptions and tune metadata fields
* Complex meters `M:(1+4+2)/8`
* Full key definitions `K:C locrian ^c _g alto t=-2`
* Multi-tune songbooks 
* Tuplets `(3 abc (5:2:7 abcdefg`
* Aligned lyrics  `+w: th-ese wor-ds are al-igned in the event stre-a-m`  
* Grace notes, decorations `{cf}!fermata!~G`
* Slurs and chords `(ABC)` and `[Ceg]`
* Named chords `"Cm7"C G F | "Dmaj" D e' f |`
* Repeats (with variable counts, such as `|::: :::|`) and variant endings `|: abc :|1 def |2 fed ||`
* Parts with variant endings 
* Multi-voice songs `V:v1`
* Voice overlay with `&`
* Macros, user macros and transposing macros
* `abc-include` to include files

See `tests/test_abc.lua` for examples of these in use.

## Limitations

### Transposing macros
Transposing macros are supported, but only work with notes without explicit octave
symbols. For example:

    m:~n2={op}n2
    A2 b2 c'2    

produces

    {Bc}A2 {c'd'}b2 c'2 
    
because the macro does not match n'2. It is not clear whether this is the behavour the
standard intended.


###Macro expansion
Macros are expanded as they are read, so they will appear in the token stream expanded. The 
macro definitions are stripped from the song. So `reproduce_abc.lua` will turn        

    m:a=g
    abc        

into

    gbc
    
### Includes 
        
        I:abc-include file.abc
        
will include the `file.abc`. But note that the instruction 
field will not appear in the token stream -- instead the contents of "file.abc" 
will appear in place. If a file is included more than once inside a song, all 
includes except the first are ignored. This eliminates recursive includes but
might have confounding effects.
        
### Disabling expansion
Macro expansion and abc-include can be disabled by setting `no_expand=true` in the options passed to 
`parse_abc_multisong()`, `parse_abc_file()` or `parse_abc_fragment()`. Example:

    parse_abc_file('macros.abc', {no_expand=false}) -- parses the file with macros enabled
    parse_abc_file('macros.abc', {no_expand=true}) -- parses the file with macros disabled, macro fields are passed through


## License    
    Licensened under the BSD 3 clause license.
        
    * Copyright (c) 2013, John Williamson
    * All rights reserved.
    *
    * Redistribution and use in source and binary forms, with or without
    * modification, are permitted provided that the following conditions are met:
    *     * Redistributions of source code must retain the above copyright
    *       notice, this list of conditions and the following disclaimer.
    *     * Redistributions in binary form must reproduce the above copyright
    *       notice, this list of conditions and the following disclaimer in the
    *       documentation and/or other materials provided with the distribution.
    *     * Neither the name of the <organization> nor the
    *       names of its contributors may be used to endorse or promote products
    *       derived from this software without specific prior written permission.
    *
    * THIS SOFTWARE IS PROVIDED BY <copyright holder> ``AS IS'' AND ANY
    * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
    * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
    * DISCLAIMED. IN NO EVENT SHALL <copyright holder> BE LIABLE FOR ANY
    * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
    * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
    * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.**
     
