-- ABC Lua single file: autogenerated from source files
-- DO NOT EDIT; regenerate using make_abclua.lua
--
-- 
-- Simple ABC parsing for Lua. This library can read a reasonable
-- subset of ABC and generate tables representing the song structure.
--
-- Requires: 
--     Lua 5.2.1 http://www.lua.org
--     LPeg http://www.inf.puc-rio.br/~roberto/lpeg/
--
-- License: BSD 3 clause license
--  
-- * Copyright (c) 2013, John Williamson
-- * All rights reserved.
-- *
-- * Redistribution and use in source and binary forms, with or without
-- * modification, are permitted provided that the following conditions are met:
-- *     * Redistributions of source code must retain the above copyright
-- *       notice, this list of conditions and the following disclaimer.
-- *     * Redistributions in binary form must reproduce the above copyright
-- *       notice, this list of conditions and the following disclaimer in the
-- *       documentation and/or other materials provided with the distribution.
-- *     * Neither the name of the <organization> nor the
-- *       names of its contributors may be used to endorse or promote products
-- *       derived from this software without specific prior written permission.
-- *
-- * THIS SOFTWARE IS PROVIDED BY <copyright holder> ``AS IS'' AND ANY
-- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-- * DISCLAIMED. IN NO EVENT SHALL <copyright holder> BE LIABLE FOR ANY
-- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.**
--

local re = require "re"
--
-- From source file: utils.lua
--
function repeat_string(str, times)
    -- return the concatenation of a string a given number of times
    -- e.g. repeat_string('abc', '3') = 'abcabcabc'
    local reps = {}
    for i=1,times do
        table.insert(reps, str)
    end
    return table.concat(reps)
end

-- set a field of the whole table
function set_property(t, key, value)
    for i,v in pairs(t) do
        v[key] = value
    end
end

-- copy a table completely
function deepcopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[deepcopy(orig_key)] = deepcopy(orig_value)
        end
        setmetatable(copy, deepcopy(getmetatable(orig)))
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

-- Print anything - including nested tables
function table_print (tt, indent, done)
  done = done or {}
  indent = indent or 0
  if type(tt) == "table" then
    for key, value in pairs (tt) do
      io.write(string.rep (" ", indent)) -- indent it
      if type (value) == "table" and not done [value] then
        done [value] = true
        io.write(string.format("[%s] => table\n", tostring (key)));
        io.write(string.rep (" ", indent+4)) -- indent it
        io.write("(\n");
        table_print (value, indent + 7, done)
        io.write(string.rep (" ", indent+4)) -- indent it
        io.write(")\n");
      else
        io.write(string.format("[%s] => %s\n",
            tostring (key), tostring(value)))
      end
    end
  else
    io.write(tt .. "\n")
  end
end


function invert_table(t)
    -- invert a table so that values map to keys
    local n = {}
    for i,v in pairs(t) do
        n[v] = i
    end
    return n
end


function append_table(a, b)
    -- Append b to a. Operates in-place, and returns a copy
    -- of the modified array
    for i,v in ipairs(b) do    
        table.insert(a,v)
    end
    return a
end

-- Compatibility: Lua-5.1
function split(str, pat)
   local t = {}  -- NOTE: use {n = 0} in Lua-5.0
   local fpat = "(.-)" .. pat
   local last_end = 1
   local s, e, cap = str:find(fpat, 1)
   while s do
      if s ~= 1 or cap ~= "" then
	 table.insert(t,cap)
      end
      last_end = e+1
      s, e, cap = str:find(fpat, last_end)
   end
   if last_end <= #str then
      cap = str:sub(last_end)
      table.insert(t, cap)
   end
   return t
end


function warn(message)
-- print a warning message
    print(message)
end


--
-- From source file: keys.lua
--
-- Functions for handling key signatures and modes
-- and working out sharps and flats in keys.

function midi_to_frequency(midi, reference)
    -- transform a midi note to a frequency (in Hz)
    -- optionally use a different tuning than concert A
    -- specify frequency of A in Hz as the second parameter if required
    reference = reference or 440.0    
    return reference * math.pow(2.0, (midi-69)/12.0)
end

-- Table mapping notes to semitones
local note_table = {
c=0,
cb=11,
cs=1,
d=2,
db=1,
ds=3,
e=4,
eb=3,
es=5,
f=5,
fb=4,
fs=6,
g=7,
gb=6,
gs=8,
a=9,
ab=8,
as=10,
b=11,
bb=10,
bs=12
}

local key_note_table = {
c=0,
cb=11,
cs=1,
d=2,
db=1,
e=4,
eb=3,
f=5,
fs=6,
g=7,
gb=6,
a=9,
ab=8,
b=11,
bb=10
}





-- semitones in the major scale
local major = {'c','d','e','f','g','a','b'}
local key_table = 
{
c = {0,0,0,0,0,0,0},
g = {0,0,0,1,0,0,0},
d = {1,0,0,1,0,0,0},
a = {1,0,0,1,1,0,0},
e = {1,1,0,1,1,0,0},
b = {1,1,0,1,1,1,0},
fs = {1,1,1,1,1,1,0},
cs = {1,1,1,1,1,1,1},
f =  {0,0,0,0,0,0,-1},
bb = {0,0,-1,0,0,0,0},
eb = {0,0,-1,0,0,-1,-1},
ab = {0,-1,-1,0,0,-1,-1},
db = {0,-1,-1,0,-1,-1,-1},
gb = {-1,-1,-1,0,-1,-1,-1},
cb = {-1,-1,-1,-1,-1,-1,-1},

-- not real keys, but sound correct
as = {0,0,-1,0,0,0,0},
ds = {0,0,-1,0,0,-1,-1},
gs = {0,-1,-1,0,0,-1,-1},
fs = {-1,-1,-1,0,-1,-1,-1},
bs = {-1,-1,-1,-1,-1,-1,-1},
}



local inverse_note_table = invert_table(note_table)
local inverse_key_note_table = invert_table(key_note_table)

-- offsets for the common modes
local mode_offsets = {maj=0, min=3, mix=5, dor=10, phr=8, lyd=7, loc=1}





function compute_mode(offset)
    -- compute a mapping from notes in a given mode to the corresponding major key
    -- e.g. compute_mode(3) gives the relative major keys of each possible minor key
    -- return value is a table mapping from the modal key (e.g. E min) to the 
    -- corresponding major key (e.g. G)
    local notes = {}
    for note, semi in pairs(note_table) do
        semi = (semi + offset) % 12        
        notes[note] = inverse_key_note_table[semi]
    end
    return notes
end


local key_matcher = re.compile([[
    key <- ( {:none: ('none') :} / {:pipe: ('Hp' / 'HP') :} / (
        {:root: ([a-gA-G]):}  ({:flat: ('b'):}) ? ({:sharp: ('#'):}) ?  
        (%s * {:mode: (mode %S*):}) ? 
        (%s * {:accidentals: (accidentals):}) ?         
         ({:clef:  ((%s + <clef>) +) -> {}   :})  ?           
        )) -> {} 
        
    clef <-  (({:clef: clefs :}  / clef_def /  middle  / transpose / octave / stafflines / custom )  ) 
    
    custom <- ([^:] + ':' [^=] + '=' [%S] +)
    clef_def <- ('clef=' {:clef: <clefs> :} [0-9] ? ({:plus8: (  '+8' / '-8' ) :})  ? ) 
    clefs <- ('alto' / 'bass' / 'none' / 'perc' / 'tenor' / 'treble' )
    middle <- ('middle=' {:middle: <number> :})
    transpose <- (('transpose='/'t=')  {:transpose: <number> :}) 
    octave <- ('octave=' {:octave: <number> :}) 
    stafflines <- ('stafflines=' {:stafflines: <number> :})
    
    
    number <- ( ('+' / '-') ? [0-9]+)
    
    mode <- ( ({'maj'}) / ({'aeo'}) / ({'ion'}) / ({'mix'}) / ({'dor'}) / ({'phr'}) / ({'lyd'}) /
          ({'loc'}) /  ({'exp'}) / ({'min'}) / {'m'}) 
    accidentals <- ( {accidental} (%s+ {accidental}) * ) -> {}
    accidental <- ( ('^' / '_' / '__' / '^^' / '=') [a-g] )
]])

function parse_key(k)
    -- Parse a key definition, in the format <root>[b][#][mode] [accidentals] [expaccidentals]
    

    k = k:lower()
    local captures = key_matcher:match(k)
    
    --replace +8 / -8 with a straightforward transpose
    if captures.clef and captures.clef.plus8 then
        if captures.clef.plus8=='-8' then
            captures.clef.octave = (captures.clef.octave or 0) + 1
        else
            captures.clefoctave = (captures.clef.octave or 0) - 1 
        end
        captures.clef.plus8 = nil
    end
    
    -- replace transpose with t
    if captures.clef and captures.clef.t then
        captures.clef.transpose = captures.clef.t
        captures.clef.t = nil
    end
    
    return {naming = captures,  clef=captures.clef}
    
end


function create_key_structure(k)
    -- Create a key structure, which lists each note as written (e.g. A or B)
    -- and maps it to the correct semitone in the interval
    
    local key_mapping = {}    
    
    -- default: C major if no signature
    for i,v in pairs(key_table['c']) do                        
            key_mapping[major[i]] = v
    end        
    
    -- none = c major, all accidentals must be specified
    if k.none then
        return key_mapping
    end
    
    
    -- Pipe notation (Hp or HP): F sharp and G sharp
    if k.pipe then
        for i,v in pairs(key_table['c']) do                        
                key_mapping[major[i]] = v
        end        
        
        key_mapping[1] = 1 -- C sharp
        key_mapping[4] = 1 -- F sharp
                    
    else
        -- find the matching key        
        local root = k.root
        if k.flat then
            root = root..'b'
        end
        
        if k.sharp then
            root = root..'s'
        end                      
        
        -- offset according to mode
        if k.mode then
            if k.mode=='aeo'  or k.mode=='m' then
                k.mode = 'min'
            end
            
            if k.mode=='ion' then
                k.mode = 'maj'
            end            
            
            -- get the modal offset
            local modal_root = root            
            
            if mode_offsets[k.mode] then
                local major_mapping = compute_mode(mode_offsets[k.mode])
                root = major_mapping[root] -- get relative major key                        
            end            
        end
                
      
        for i,v in pairs(key_table[root]) do                        
            key_mapping[major[i]] = v
        end
        
        -- add accidentals
        if k.accidentals then
            for i,v in pairs(k.accidentals) do
                local acc = re.match(v, "({('^'/'^^'/'='/'_'/'__')} {[a-g]}) -> {}")
                if acc[1]=='^' then 
                    key_mapping[acc[2]] = 1
                end
                if acc[1]=='^^' then 
                    key_mapping[acc[2]] = 2
                end
                if acc[1]=='=' then 
                    key_mapping[acc[2]] = 0
                end
                if acc[1]=='_' then 
                    key_mapping[acc[2]] = -1
                end
                if acc[1]=='__' then 
                    key_mapping[acc[2]] = -2
                end
            end
        end
        
                        
    end
    return key_mapping
end




--
-- From source file: parts.lua
--
-- Functions for dealing with parts, repeats and sub-patterns


function add_section(song, repeats)
    -- add the current temporary buffer to the song as a new pattern
    -- repeat it repeat times
    repeats = repeats or 1
        
    if not song.context.in_variant then
        table.insert(song.context.pattern_map, {section=song.opus, repeats=repeats, variants={}})
    else
        table.insert(song.context.pattern_map[#song.context.pattern_map].variants, song.opus)
    end
    
    song.temp_part = {}
    song.opus = song.temp_part
    
end


function start_new_part(song, name)
    -- start a new part with the given name. writes the old part into the part table
    -- and clears the current section
    
    add_section(song, 1) -- add any left over section    
    song.context.part_map[song.context.current_part] = song.context.pattern_map
    song.context.pattern_map = {}
    song.context.current_part = name
    song.context.in_variant = nil
    song.temp_part = {}
    song.opus = song.temp_part   
end


-- variant tag
local variant_tag = 0



function start_variant_part(song, bar)
    -- start a variant part. The variant specifier indicates the ranges that 
    -- this variant will apply to.
    -- Enters a part called (current_part).N where N is each range this part applies to
    -- and registers the sub-part in the variants table
    
    -- parse the variant list
    local endings = bar.variant_range
    
    -- if we are not already in a variant, record the arent part
    if not song.in_variant_part then
        song.context.parent_part = song.context.current_part
        song.in_variant_part = true
    end
        
    -- generate new ID for this tag
    local part_tag = song.context.parent_part .. '.' .. variant_tag
    start_new_part(song, part_tag)
    variant_tag = variant_tag + 1
    
    -- fill in the variants in the parent part map
    if not song.context.part_map[song.context.parent_part].variants then 
            song.context.part_map[song.context.parent_part].variants = {}
    end
            
    for i,v in ipairs(endings) do
        
        song.context.part_map[song.context.parent_part].variants[v] = part_tag
    end
                
    
    
end

function expand_patterns(patterns)
    -- expand a pattern list table into a single event stream
    local result = {}
    
    for i,v in ipairs(patterns) do
        
        for i=1,v.repeats do
            -- repeated measures (including single repeats!)
            append_table(result, v.section)    
            
            -- append variant endings
            if #v.variants>=i then
                append_table(result, v.variants[i])    
            
            end
        end
    end
    
    return result        
end



function compose_parts(song)
    -- Compose each of the parts in the song into one single event stream
    -- using the parts indicator. If no parts indicator, just uses the default part
    -- Combines all repeats etc. inside each part into a stream as well
    -- The final stream is a fresh copy of all the events
    
    
    start_new_part(song, nil)
    
    local variant_counts = {}
    
    if song.context.part_sequence then                         
        song.stream = {}
        for c in song.context.part_sequence:gmatch"." do            
            local pattern = deepcopy(expand_patterns(song.context.part_map[c]))
            append_table(song.stream, pattern)
            
            -- count repetitions of this part
            if not variant_counts[c] then
                variant_counts[c] = 1
            else
                variant_counts[c] = variant_counts[c] + 1
            end
            
            -- expand the variants
            local vc = variant_counts[c]
            if song.context.part_map[c].variants and song.context.part_map[c].variants[vc] then
                -- find the name of this variant ending
                variant_part_name = song.context.part_map[c].variants[vc]
                pattern = deepcopy(expand_patterns(song.context.part_map[variant_part_name]))
                append_table(song.stream, pattern)
            
            end            
            
        end        
        
    else
        -- no parts indicator
        song.stream = deepcopy(expand_patterns(song.context.part_map['default']))
    end
    
end






    




--
-- From source file: lyrics.lua
--
-- functions for dealing with lyrics

function parse_lyrics(lyrics)
    -- Parse a lyric definition string
    -- Returns a table containing a sequence of syllables and advance field
    -- each advance field specifies how far to move for the next syllable
    -- either an integer number of notes, or "bar" to wait until the next bar
    -- e.g. 'he-llo wo-rld_ oh~yes | a test___' becomes
    -- { 
    -- {syllable='he', advance=1}
    -- {syllable='llo', advance=1}
    -- {syllable='wo', advance=1}
    -- {syllable='rld', advance=2}
    -- {syllable='oh yes', advance='bar'}
    -- {syllable='a', advance=1}
    -- {syllable='test', advance=4}    
    -- }
    
    -- make escaped dashes into backquotes
    lyrics = lyrics:gsub('\\\\-', '`')

    local lyrics_pattern = [[
    lyrics <- ( (({:syl: <syllable> :} {:br: <break> :}) -> {} *)  {:syl: (<syllable>)  :} -> {} ) -> {}
    break <- ( ( %s +)  / ('-')  )
    
    syllable <- ( ([^%s-] +) )        
    ]]
    
    local match = re.match(lyrics, lyrics_pattern) 
    local lyric_sequence = {}
    
    local next_advance = 1 -- always start on first note of the song
    
    -- construct the syllable sequence
    for i,syllable in ipairs(match) do
        local syl = syllable.syl
        -- fix backquotes
        syl = syl:gsub('`', '-')
        -- note advance on trailing underscore
        local note_count = 1
        for c in syl:gmatch"_" do
            note_count = note_count + 1
        end
        
        local advance = next_advance
        
        -- bar advance
        if string.sub(syl,-1)=='|' then
            next_advance = 'bar'
        else
            next_advance = note_count
        end
        
        -- remove _, ~ and | from the display syllables
        for i,v in ipairs(match) do
            syl = syl:gsub('|', '')        
            syl = syl:gsub('_', '')        
            syl = syl:gsub('~', ' ')        
        end
                
        table.insert(lyric_sequence, {syllable=syl, advance=advance, br=syllable.br})
    end
    return lyric_sequence
end


function insert_lyrics(lyrics, stream)
    -- Takes a lyrics structure and an event stream, and inserts the lyric
    -- events into the stream accordingly. Returns a new event stream
    -- with the lyrics in place
    local new_stream = {}
    
    -- return immediately if there are no lyrics to insert
    if not lyrics or #lyrics<1 then       
        return stream
    end
        
    local lyric_index = 1
    local note_wait = lyrics[lyric_index].advance
    local advance = false
    
    
    for i,v in ipairs(stream) do
        -- insert original event
        table.insert(new_stream, v)
        
        -- if waiting for a bar, reset on next bar symbol
        if v.event == 'bar' then
            
            if note_wait == 'bar' then
                advance = true
                
            end
        end
        
        
        -- note; decrement wait if we're not looking for a bar
        if v.event=='note' then
        
            if note_wait ~= 'end' and note_wait ~= 'bar' then
                note_wait = note_wait - 1                
                -- wait hit zero; insert the lyric syllable
                if note_wait == 0 then
                    advance = true                                        
                end                
            end            
        end
        
        
        -- if we've waited long enough, insert the lyric symbol into the stream
        if advance then
            table.insert(new_stream, {event='lyric', syllable=lyrics[lyric_index].syllable})
            
            lyric_index = lyric_index + 1                    
            -- move on the lyric pointer
            if lyric_index > #lyrics then
                note_wait = 'end'
            else
                note_wait = lyrics[lyric_index].advance                
            end
            
            
            advance = false
        end
        
        
    end
    
    return new_stream
end


function test_lyric_parsing()
    -- test the lyrics parser
    tests = {
    'hello',
    'he-llo',
    'he-llo th-is~a te\\-st___',
    'he-llo wo-rld_ oh~yes | a test___',
    'this is sim-ple~but fine'
    }
    
    for i,v in ipairs(tests) do    
        print(v)
        table_print(parse_lyrics(v))
        print()
    end
    
    
end


--
-- From source file: chords.lua
--
-- Chord handling functions
local chords = 
{
["+2"] = { 0, 2, },
["+3"] = { 0, 4, },
["+4"] = { 0, 6, },
["+b3"] = { 0, 3, },
["5"] = { 0, 7, },
["b5"] = { 0, 6, },
["6sus4(-5)"] = { 0, 6, 9, },
["aug"] = { 0, 4, 8, },
["dim"] = { 0, 3, 6, },
["dim5"] = { 0, 4, 6, },
["maj"] = { 0, 4, 7, },
["min"] = { 0, 3, 7, },
["m"] = { 0, 3, 7, },
["sus2"] = { 0, 2, 7, },
["sus2sus4(-5)"] = { 0, 2, 6, },
["sus4"] = { 0, 6, 7, },
["6"] = { 0, 4, 7, 9, },
["6sus2"] = { 0, 2, 7, 9, },
["6sus4"] = { 0, 6, 7, 9, },
["7"] = { 0, 4, 7, 10, },
["7#5"] = { 0, 4, 8, 10, },
["7b5"] = { 0, 4, 6, 10, },
["7sus2"] = { 0, 2, 7, 10, },
["7sus4"] = { 0, 6, 7, 10, },
["add2"] = { 0, 2, 4, 7, },
["add4"] = { 0, 4, 6, 7, },
["add9"] = { 0, 4, 7, 14, },
["dim7"] = { 0, 3, 6, 9, },
["dim7susb13"] = { 0, 3, 9, 20, },
["madd2"] = { 0, 2, 3, 7, },
["madd4"] = { 0, 3, 6, 7, },
["madd9"] = { 0, 3, 7, 14, },
["mmaj7"] = { 0, 3, 7, 11, },
["m6"] = { 0, 3, 7, 9, },
["m7"] = { 0, 3, 7, 10, },
["m7#5"] = { 0, 3, 8, 10, },
["m7b5"] = { 0, 3, 6, 10, },
["minadd2"] = { 0, 2, 3, 7, },
["minadd4"] = { 0, 3, 6, 7, },
["minadd9"] = { 0, 3, 7, 14, },
["minmaj7"] = { 0, 3, 7, 11, },
["min6"] = { 0, 3, 7, 9, },
["min7"] = { 0, 3, 7, 10, },
["min7#5"] = { 0, 3, 8, 10, },
["min7b5"] = { 0, 3, 6, 10, },
["maj7"] = { 0, 4, 7, 11, },
["maj7#5"] = { 0, 4, 8, 11, },
["maj7b5"] = { 0, 4, 6, 11, },
["maj7sus2"] = { 0, 2, 7, 11, },
["maj7sus4"] = { 0, 6, 7, 11, },
["sus2sus4"] = { 0, 2, 6, 7, },
["6/7"] = { 0, 4, 7, 9, 10, },
["6add9"] = { 0, 4, 7, 9, 14, },
["7s5b9"] = { 0, 4, 8, 10, 13, },
["7s9"] = { 0, 4, 7, 10, 15, },
["7s9b5"] = { 0, 4, 6, 10, 15, },
["7/11"] = { 0, 4, 7, 10, 18, },
["7/13"] = { 0, 4, 7, 10, 21, },
["7add4"] = { 0, 4, 6, 7, 10, },
["7b9"] = { 0, 4, 7, 10, 13, },
["7b9b5"] = { 0, 4, 6, 10, 13, },
["7sus4/13"] = { 0, 6, 7, 10, 21, },
["9"] = { 0, 4, 7, 10, 14, },
["9s5"] = { 0, 4, 8, 10, 14, },
["9b5"] = { 0, 4, 6, 10, 14, },
["9sus4"] = { 0, 7, 10, 14, 18, },
["m maj9"] = { 0, 3, 7, 11, 14, },
["mmaj9"] = { 0, 3, 7, 11, 14, },
["m6/7"] = { 0, 3, 7, 9, 10, },
["m6/9"] = { 0, 3, 7, 9, 14, },
["m7/11"] = { 0, 3, 7, 10, 18, },
["m7add4"] = { 0, 3, 6, 7, 10, },
["m9"] = { 0, 3, 7, 10, 14, },
["m9/11"] = { 0, 3, 10, 14, 18, },
["m9b5"] = { 0, 3, 6, 10, 14, },
["min maj9"] = { 0, 3, 7, 11, 14, },
["minmaj9"] = { 0, 3, 7, 11, 14, },
["min6/7"] = { 0, 3, 7, 9, 10, },
["min6/9"] = { 0, 3, 7, 9, 14, },
["min7/11"] = { 0, 3, 7, 10, 18, },
["min7add4"] = { 0, 3, 6, 7, 10, },
["min9"] = { 0, 3, 7, 10, 14, },
["min9/11"] = { 0, 3, 10, 14, 18, },
["min9b5"] = { 0, 3, 6, 10, 14, },
["maj6/7"] = { 0, 4, 7, 9, 11, },
["maj7/11"] = { 0, 4, 7, 11, 18, },
["maj7/13"] = { 0, 4, 7, 11, 21, },
["maj9"] = { 0, 4, 7, 11, 14, },
["maj9s5"] = { 0, 4, 8, 11, 14, },
}

local common_chords = 
{
["aug"] = { 0, 4, 8, },
["dim"] = { 0, 3, 6, },
["dim5"] = { 0, 4, 6, },
["maj"] = { 0, 4, 7, },
["min"] = { 0, 3, 7, },
["sus2"] = { 0, 2, 7, },
["sus4"] = { 0, 6, 7, },
["6"] = { 0, 4, 7, 9, },
["7"] = { 0, 4, 7, 10, },
["7sus2"] = { 0, 2, 7, 10, },
["7sus4"] = { 0, 6, 7, 10, },
["add2"] = { 0, 2, 4, 7, },
["add4"] = { 0, 4, 6, 7, },
["add9"] = { 0, 4, 7, 14, },
["dim7"] = { 0, 3, 6, 9, },
["madd9"] = { 0, 3, 7, 14, },
["mmaj7"] = { 0, 3, 7, 11, },
["m6"] = { 0, 3, 7, 9, },
["m7"] = { 0, 3, 7, 10, },
["m7#5"] = { 0, 3, 8, 10, },
["m7b5"] = { 0, 3, 6, 10, },
["maj7"] = { 0, 4, 7, 11, },
["maj7#5"] = { 0, 4, 8, 11, },
["maj7b5"] = { 0, 4, 6, 11, },
["9"] = { 0, 4, 7, 10, 14, },
["mmaj9"] = { 0, 3, 7, 11, 14, },
["m6/7"] = { 0, 3, 7, 9, 10, },
["m6/9"] = { 0, 3, 7, 9, 14, },
["m7/11"] = { 0, 3, 7, 10, 18, },
["m7add4"] = { 0, 3, 6, 7, 10, },
["m9"] = { 0, 3, 7, 10, 14, },
["m9/11"] = { 0, 3, 10, 14, 18, },
["m9b5"] = { 0, 3, 6, 10, 14, },
["maj9"] = { 0, 4, 7, 11, 14, },
}



-- Table mapping notes to semitones
local note_table = {
c=0,
cb=11,
cs=1,
d=2,
db=1,
ds=3,
e=4,
eb=3,
es=5,
f=5,
fb=4,
fs=6,
g=7,
gb=6,
gs=8,
a=9,
ab=8,
as=10,
b=11,
bb=10,
bs=12
}


local chord_matcher = re.compile([[
        chord <- ({:root: root :} ({:type: %S +:}) ? ) -> {}
        root <- ([a-g] ('b' / 's') ?)
    ]])

function match_chord(chord)
    -- Matches chord definitions, returning the root note
    -- the chord type, and the notes in that chord (as semitone offsets)
    -- convert sharp signs to s and lowercase
        
    chord = chord:gsub('#', 's')
    chord = string.lower(chord)
    
    
    
    local match = chord_matcher:match(chord)
    if not match or not match.root then
        return nil
    end
    
    local base_pitch = note_table[match.root]
    match.type = match.type or 'maj' -- default to major chord
    
    local chord_offsets
    if chords[match.type] then
        chord_offsets = chords[match.type]
    else    
        return nil -- not a valid chord
    end
    
    return {chord_type=match.type, base_pitch=base_pitch, notes=chord_offsets}
   
end


function is_chord(str)
    -- Return true if this string is a valid chord identifier
    if match_chord(str) then
        return true
    else
        return false
    end
end
    
function create_chord(chord)
-- takes a chord defintion string (e.g. "Gm" or "Fm7" or "Asus2") and returns the notes in it
-- as a table of pitches (with C=0)

    
    local match = match_chord(chord)
    local notes = {}
    
    if match then      
        for i,v in ipairs(match.notes) do
            table.insert(notes, v+match.base_pitch)
        end
    end
    return notes
    
end

function voice_chord(notes, octave)
    -- Takes a note sequence for a chord and expands the chord across several octaves
    -- Returns a MIDI note number set
    local octave = octave or 5
    
    local base = octave * 12
    
    local out_notes = {}    

    -- add original notes
    for i,v in ipairs(notes) do 
        table.insert(out_notes, v+base)
    end
    
    -- root at octave above and below
    local root = notes[1]
    table.insert(out_notes, root+base-12)
    table.insert(out_notes, root+base+12)
    
    -- -- fifth at octave above
    -- if #notes>=3 then
        -- fifth = notes[3]
        -- table.insert(out_notes, fifth+base+12)
    -- end
    
    return out_notes
    
end


function test_chords()
    
    local test_chords = {'Gm', 'G', 'F#min7', 'dM9', 'bbmin'}
    for i,v in ipairs(test_chords) do
        print(v)
        table_print(voice_chord(create_chord(v), 5))
        print()
    end   
end




--
-- From source file: stream.lua
--
-- Functions from transforming an raw stream into a timed event stream

function time_stream(stream)
    -- take a stream of events and insert time indicators (in microseconds)
    -- as the t field in each event
    -- Time advances only on notes or rests
    
    local t 
    local in_chord = false
    local max_duration 
    
    t = 0
    
    
    for i,event in ipairs(stream) do        
        event.t = t
        
        -- rests and notes
        if event.event=='rest' or event.event=='note' then
            if not in_chord then
                t = t + event.duration
            else
                -- record maximum time in chord; this is how much we will advance by
                if event.duration > max_duration then
                    max_duration = event.duration
                end
            end            
        end
        
        -- chord symbols
       
        -- chord starts; stop advancing time
        if event.event=='chord_begin' then
            in_chord = true
            max_duration = 0
        end
        
        if event.event=='chord_end' then
            in_chord = false
            t = t + max_duration -- advance by longest note in chord
        end
       
       
    end
    
end

function get_note_stream(timed_stream, channel)
    -- Extract all play events from a timed stream, as sequence of note on / note off events
    -- take into account ties in computing note offs
    
   local out = {}
   local notes_on = {}
   
   local channel = channel or 1
   for i,event in ipairs(timed_stream) do        
            if event.event=='note' then                
                if not notes_on[event.pitch] then 
                    table.insert(out, {event='note_on', t=event.t, pitch=event.pitch, channel=channel})
                    notes_on[event.pitch] = true
                end
                
                -- don't insert a note off if the note is tied
                if not event.note.tie then                    
                    table.insert(out, {event='note_off', t=event.t+event.duration-1, pitch=event.pitch, channel=channel})                                    
                    notes_on[event.pitch] = false
                end          
            end
    end
    return out
end


function print_notes(stream)
    -- print out the notes, as a sequence of pitches
    local notes = {}
    
    for i,event in ipairs(stream) do        
        if event.event == 'note' then                      
           table.insert(notes, event.note.note_def.pitch.note)
        end
        if event.event == 'rest' then
            table.insert(notes, '~')
        end
        if event.event == 'bar' then
            table.insert(notes, '|')
        end
        if event.event == 'split_line' then
            table.insert(notes, '\n')
        end
    end
    
    print(table.concat(notes))
    
end


function filter_event_stream(stream, includes)
    -- return a copy of the stream, keeping only those specified events in the stream
    local filtered = {}
    
    if #stream=={} then
        return {}
    end
    
    if type(includes)=='string' then        
        for i,v in ipairs(stream) do
            if v.event==includes then
                table.insert(filtered, v.event)            
            end
        end       
    end
    
    if type(includes)=='table' then        
        for i,v in ipairs(stream) do
            for j,n in ipairs(includes) do 
                if v.event==n then
                table.insert(filtered, v.event)            
                end
            end
        end       
    end    
    return filtered   
end

function duration_stream(stream)
    -- return the duration of the stream, from the first event, to
    -- the end of the last note
    if #stream==0 then
        return 0
    end
    
    local end_time = stream[-1].t
    -- must add on duration to avoid chopping last note
    if stream[-1].duration then
        end_time = end_time + stream[-1].duration
    end
    return end_time
end

function start_time_stream(stream)
    -- return the time of the first event
    if #stream==0 then
        return 0
    end    
    return stream[1].t
end

function zero_time_stream(stream)
    -- fix the time of the first element of the stream to t=0, and shift
    -- the rest of the stream to match
    -- Modifies the stream in place -- copy it if you don't want to modify the 
    -- original data
    if #stream=={} then
        return {}
    end
    
    local t = stream[1].t
    for i,v in ipairs(stream) do
        stream.t = stream.t - t
    end
    
end


function render_grace_notes(stream)
    -- Return a copy of the stream with grace notes rendered in 
    -- as ordinary notes. These notes will cut into the following note 
    local out = {}
    for i,v in ipairs(stream) do
        if v.event=='note' and v.note.grace then
        
            local sequence = v.note.grace.sequence
             
            local duration = 0 -- total duration of the grace notes
            for j,n in ipairs(sequence) do
                
                table.insert(out, {event='note', t=duration+v.t, duration=n.duration, pitch=n.pitch, note=n.grace})
                duration = duration + n.duration
            end            
            
            -- cut into the time of the next note, and push it along
            local cut_note = deepcopy(v)
            cut_note.duration = cut_note.duration - duration
            cut_note.t = cut_note.t + duration
            table.insert(out, cut_note) 
        else
            table.insert(out, v)
        end
    end    
    return out
end


function trim_event_stream(stream,  mode, start_time, end_time)
    -- return a copy of the stream, including only events that fall inside
    -- [start_time:end_time] (given in microseconds)
    -- mode can be = 'starts' which returns event that start in the given period
    --               'ends' which returns events that end in the given period
    --               'any' which returns events that overlap the period at all
    --               'within' which returns that are wholly in the period
    --               'trim' which is like any, but trims notes to fit the given time
    -- start_time and end_time are optional (default to start and end of the tune)   
    
    if #stream=={} then
        return {}
    end
    
    local filtered = {}
    start_time = start_time or nil
    end_time = end_time or duration_stream(stream)         
    
    
    for i,v in ipairs(stream) do
        local start_t = v.t
        local end_t = v.t
        
        -- notes and rests occupy time
        if v.event == 'note' or v.event=='rest' then
            end_t = v.t + v.duration
        end
        
        -- work out if this event starts or stops in this interval
        local start_in = (start_t>=start_time and  start_t<=end_time) 
        local end_in = (end_t>=start_time and end_t<=end_time)
        
        if mode=='any' then
            if start_in or end_in  then
                table.insert(filtered, v)
            end
        end
        
        if mode=='starts' then
            if start_in then
                table.insert(filtered, v)
            end
        end
        
        if mode=='ends' then
            if end_in then
                table.insert(filtered, v)
            end
        end
        
        if mode=='within' then
            if start_in and end_in then
                table.insert(filtered, v)
            end
        end
        
        if mode == 'trim' then
             if start_in or end_in  then
                -- must copy event to avoid changing the original
                local event = deepcopy(v)
                
                -- starts, but is too long
                if start_in and not end_in then
                    event.duration = end_time - event.t
                end
                
                -- starts before, but ends in
                if end_in and not start_in then
                    event.duration = (event.t+event.duration)-start_time
                    event.t = start_time                    
                end
                table.insert(filtered, event)
             end
        end
        
    end
    
    return filtered
end
    
    
    


function print_lyrics_notes(stream)
    -- print out the notes and lyrics, as a sequence of pitches interleaved with 
    -- syllables
    local notes = {}
    
    for i,event in ipairs(stream) do        
    
        if event.event == 'lyric' then                      
           table.insert(notes, event.syllable)
        end
    
        if event.event == 'note' then                      
           table.insert(notes, event.note.note_def.pitch.note)
        end
        if event.event == 'rest' then
            table.insert(notes, '~')
        end
        if event.event == 'bar' then
            table.insert(notes, '|')
        end
        if event.event == 'split_line' then
            table.insert(notes, '\n')
        end
    end
    
    print(table.concat(notes))
    
end

function note_stream_to_opus(note_stream)
    -- make sure events are in time order
    table.sort(note_stream, function(a,b) return a.t<b.t end)
    
    local last_t = 0
    score = {}
    local dtime
    for i,event in ipairs(note_stream) do
        dtime = (event.t - last_t)/1000.0 -- microseconds to milliseconds
        table.insert(score, {event.event, dtime, event.channel or 1, event.pitch, event.velocity or 127})
        last_t = event.t
    end
    return score
end



function get_chord_stream(stream, octave)
    -- extract all the named chords from a stream (e.g. "Cm7" or "Dmaj") and write 
    -- them in as note events in a stream
   local out = {}
   local notes_on = {}
   local t
   local channel = channel or 1
   octave = octave or 5
   
   for i,event in ipairs(stream) do        
        
        if (event.event=='note' and event.note.chord) or event.event=='chord' then                
            local chord = event.note.chord or event.chord
            
            t = event.t
            -- turn off last chord!
            for j, n in ipairs(notes_on) do
                table.insert(out, {event='note_off', t=t, channel})                                           
                notes_on = {}
            end
            
            -- get the notes for this chord and put them in the sequence
            notes = voice_chord(create_chord(chord), octave)
            for j, n in ipairs(notes) do
                 table.insert(out, {event='note_on', t=t, pitch=n, channel})                           
                 notes_on[n] = true
            end                    
        end
    end
    
    -- turn off last chord
    for j, n in ipairs(notes_on) do
            table.insert(out, {event='note_off', t=t, channel=channel})                                           
            notes_on = {}
    end            
    
    return out 
end


function merge_streams(streams)
    -- merge a list of streams into one single, ordered stream
    local merged_stream = {}
    
    for i,v in pairs(streams) do
        append_table(merged_stream, v)         
    end    
    table.sort(merged_stream, function(a,b) return a.t<b.t end)
    return merged_stream    
end

-- sort out stream functions

function stream_to_opus(stream,  patch)
    -- return the opus form of a single note stream song, with millisecond timing    
    channel = channel or 1
    patch = patch or 41 -- default to violin
    
    local note_stream = get_note_stream(stream, channel)
    
     local score = {
        1000,  -- ticks per beat
        {    -- first track
            {'set_tempo', 0, 1000000},
            {'patch_change', 0, channel, patch},            
        },  
     }     
    append_table(score[2], note_stream_to_opus(note_stream))
    return score  
end


function song_to_opus(song, patches)
    -- return the opus form of all the voices song, with millisecond timing
    -- one channel per voice
    
    
    patches = patches or {}
    local channel = 0    
    local merged_stream = {}
    local score = {1000,
        {    
            {'set_tempo', 0, 1000000},        
        },          
    }    
    -- set the patch for each channel
    for i=1,#song.voices do
        if patches[i] then
            table.insert(score[2], 'patch_change', 0, i, patches[i])
        else
            table.insert(score[2], 'patch_change', 0, i, 41)
        end
    end
    
    -- merge in each voice
    for i,v in pairs(song.voices) do
        channel = channel + 1        
        append_table(merged_stream, get_note_stream(v.stream, channel))         
    end
        
   append_table(score[2], note_stream_to_opus(merged_stream))
   return score
end


function make_midi_from_stream(stream, fname)
    -- Turn a note stream into a MIDI file
     local MIDI = require 'MIDI'

     opus = stream_to_opus(stream)
     local midifile = assert(io.open(fname,'wb'))
     midifile:write(MIDI.opus2midi(opus))
     midifile:close()
end

function make_midi(song, fname)
    -- make a midi file from a song
    -- merge all of the voices into a single event stream
    local MIDI = require 'MIDI'
    local opus = song_to_opus(song)
    
    local midifile = assert(io.open(fname,'wb'))
    midifile:write(MIDI.opus2midi(opus))
    midifile:close()    
end




--
-- From source file: macro.lua
--
-- subsitution macro handling

-- tables for shifting notes (diatonically)
local transpose_notes = { 
    'C,,', 'D,,', 'E,,', 'F,,', 'G,,', 'A,,', 'B,,',
    'C,', 'D,', 'E,', 'F,', 'G,', 'A,', 'B,',
    'C', 'D', 'E', 'F', 'G', 'A', 'B',
     'c', 'd', 'e', 'f', 'g', 'a', 'b',
     "c'", "d'", "e'", "f'", "g'", "a'", "b'",
     "c''", "d''", "e''", "f''", "g''", "a''", "b''"    
    }
    
local transpose_note_lookup = invert_table(transpose_notes)

function transpose_note(note, offset)
    -- transpose a note (a-g A-G) by the given number of (diatonic) steps
    -- e.g. transpose_note('a', 1) = 'b'
    --      transpose_note('g', 3) = 'c''
    --      transpose_note('E', -1) = 'D'
    
    return transpose_notes[transpose_note_lookup[note]+offset]
end

function transpose_macro(lhs, note, rhs)
    -- create the macro expansion for lhs -> rhs
-- replace n in lhs with note
-- and any letters h..z in rhs with relatively offset pitches

    local lhs = lhs:gsub('n', note)
    local rhs = rhs:gsub('([h-zH-Z])', function (s)
    -- only allow lowercase values
    s = string.lower(s)
    relative = string.byte(s) - string.byte('n')
    return transpose_note(note, relative)
    end)
    return {lhs=lhs, rhs=rhs}
end


function apply_macros(macros, line)
    -- expand macros in the line
    for i,v in ipairs(macros) do
        line = line:gsub(v.lhs, v.rhs)
    end
    return line
end
    
local macro_matcher = re.compile([[
    macro <- (%s * ({:lhs: [^=%s] + :}) %s * '=' %s * ({:rhs: ([^%nl] *) :})) -> {} 
    ]])
    
function parse_macro(macro)
    -- take a raw ABC string block and expand any macros defined it
    -- expansion takes place *before* any other parsing
    local match = macro_matcher:match(macro)
 
    return match
    
end



--
-- From source file: directives.lua
--
-- functions for handling custom directives

local grace_matcher = re.compile([[ 
    length <- ({:num: (number) :} '/' {:den: (number) :}) -> {}
    number <- ([0-9]+)
    ]])

function directive_set_grace_note_length(song, directive, arguments)
    -- set the length of grace notes
    -- Directive should be of the form I:gracenotes 1/64
    if arguments[1] then
        -- extract ratio
        local ratio = grace_matcher:match(arguments[1])
        if ratio then
            song.context.grace_note_length = {num=ratio.num, den=ratio.den}
        end
    end
    update_timing(song) -- must recompute note lengths
end

-- table maps directive names to functions
-- each function takes two arguments: the song structure, and an argument list from
-- the directive (as a table)
local directive_table = {
gracenote  = directive_set_grace_note_length
}

function apply_directive(song, directive, arguments)
    -- Apply a directive; look it up in the directive table,
    -- and if there is a match, execute it
    if directive_table[directive] then
        print(directive)
        directive_table[directive](song, directive, arguments)
    end

end

function register_user_directive(directive, fn)
    -- Register a user directive. Will call fn(song, directive, arguments) when
    -- the given directive is found
    directive_table[directive] = fn
    
end


function parse_directive(directive)
    -- parse a directive into a directive, followed by sequence of space separated directives
    local directive_pattern = [[
    directives <- (%s * ({:directive: %S+ :} ) %s+ ?  {:arguments: ( ({%S+} %s +) * {%S+}  ) -> {}  :} )  -> {}
    ]]
    
    local match = re.match(directive, directive_pattern)
    return match
end



--
-- From source file: fields.lua
--
-- Routines for parsing metadata in headers and inline inside songs


-- create the various pattern matchers

local fields = {}
fields.key = [[('K:' {.*} ) -> {}]]
fields.title = [[('T:' %s * {.*}) -> {}]]
fields.ref =  [[('X:' %s * {.*}) -> {}]]
fields.area =  [[('A:' %s * {.*}) -> {}]]
fields.book =  [[('B:' %s * {.*}) -> {}]]
fields.composer =  [[('C:' %s * {.*}) -> {}]]
fields.discography =  [[('D:' %s * {.*}) -> {}]]
fields.file =  [[('F:' %s * {.*}) -> {}]]
fields.group =  [[('G:' %s * {.*}) -> {}]]
fields.history =  [[('H:' %s * {.*}) -> {}]]
fields.instruction =  [[('I:' %s * {.*}) -> {}]]
fields.length =  [[('L:' %s * {.*}) -> {}]]
fields.meter =  [[('M:' %s * {.*}) -> {}]]
fields.macro =  [[('m:' %s * {.*}) -> {}]]
fields.notes =  [[('N:' %s * {.*}) -> {}]]
fields.origin =  [[('O:' %s * {.*}) -> {}]]
fields.parts =  [[('P:' %s * {.*}) -> {}]]
fields.tempo =  [[('Q:' %s * {.*}) -> {}]]
fields.rhythm =  [[('R:' %s * {.*}) -> {}]]
fields.remark =  [[('r:' %s * {.*}) -> {}]]
fields.source =  [[('S:' %s * {.*}) -> {}]]
fields.symbolline =  [[('s:' %s * {.*}) -> {}]]
fields.user =  [[('U:' %s * {.*}) -> {}]]
fields.voice =  [[('V:' %s * {.*}) -> {}]]
fields.words =  [[('w:' %s * {.*}) -> {}]]
fields.end_words =  [[('W:' %s * {.*}) -> {}]]
fields.transcriber =  [[('Z:' %s * {.*}) -> {}]]
fields.continuation =  [[('+:' %s * {.*}) -> {}]]


-- compile field matchers
for i,v in pairs(fields) do
    fields[i] = re.compile(v)
end

local parts_matcher = re.compile(
[[
    parts <- (part +) -> {}
    part <- ( ({element}  / ( '(' part + ')' ) )  {:repeat: [0-9]* :}) -> {}    
    element <- [A-Za-z]    
    ]])
    
function parse_parts(m)
    -- Parse a parts definition that specifies the parts to be played
    -- including any repeats
    -- Returns a fully expanded part list
    
    local captures = parts_matcher:match(m)
    
    return captures
    
end

local voice_matcher = re.compile([[
    voice <- (({:id: [%S]+ :}) %s * {:specifiers: (<specifier> *) -> {} :}) -> {}
    specifier <- (%s * {:lhs: ([^=] +) :} + '=' {:rhs: [^%s]* :}) -> {} 
    ]])

function parse_voice(voice)
    -- Parse a voice definition string
    -- Voices of the form V:ID [specifier] [specifier] ...
    -- Returns a table with an ID and a specifiers table
    -- e.g. V:tenor becomes {id="tenor", specifiers={}}
    -- V:tenor clef=treble becomes {id="tenor", specifiers={lhs='clef', rhs='treble'}}
    return voice_matcher:match(voice)
end


local tempo_matcher = re.compile([[
tempo <- (
({:name: qstring :} %s +) ?
    ( 
    (  (  (div (%s + div) *)  )  %s * '=' %s * {:div_rate: number:} )  /
    (  'C=' {:div_rate: number:} ) /
    (  {:div_rate: number :} ) 
    ) 
(%s + {:name: qstring :}) ?
) -> {}

div <- ({:num: number:} %s * '/' %s * {:den: number:}) -> {}
number <- ( [0-9] + )
qstring <- ( ["] [^"]* ["] )
]])

function parse_tempo(l)
    -- Parse a tempo string
    -- Returns a tempo table, with an (optional) name and div_rate field
    -- div_rate is in units per second
    -- the numbered elements specify the unit lengths to be played up to that point
    -- each element has a "num" and "den" field to specify the numerator and denominator
    local captures = tempo_matcher:match(l)    
  
    return captures
end

local length_matcher = re.compile("('1' ('/' {[0-9] +}) ?)")
function parse_length(l)
    -- Parse a string giving note length, as a fraction "1/n" (or plain "1")
    -- Returns integer representing denominator.
    local captures = length_matcher:match(l) 
    if captures then
        return captures+0
    else
        return 1    
    end
end



function get_simplified_meter(meter)
    -- return meter as a simple num/den form
    -- with the beat emphasis separate
    -- by summing up all num elements
    -- (e.g. (2+3+2)/8 becomes 7/8)
    -- the beat emphasis is stored as
    -- emphasis = {1,3,5}
    local total_num = 0
    local emphasis = {}
    for i,v in ipairs(meter.num) do
        table.insert(emphasis, total_num)
        total_num = total_num + v
    end
    return {num=total_num, den=meter.den, emphasis=emphasis}
end

local meter_matcher = re.compile([[
    meter <- (fraction / cut / common / none) 
    common <- ({:num: '' -> '4':} {:den: '' -> '4':} 'C') -> {}
    cut <- ({:num: '' -> '2':} {:den: '' -> '2' :} 'C|' ) -> {}
    none <- ('none' / '')  -> {}    
    fraction <- ({:num: complex :} %s * '/' %s * {:den: [0-9]+ :}) -> {}    
    complex <- ( '(' ? ((number + '+') * number) ->{} ')' ? )
    number <- {([0-9]+)}     
    ]])

function parse_meter(m)
    -- Parse a string giving the meter definition
    -- Returns fraction as a two element table
    local captures = meter_matcher:match(m)
   
    return get_simplified_meter(captures)
    
end


function expand_parts(parts)
    -- Recurisvely expand a parts table into a string
    -- Input is a table with entries which are either an array of tables or
    -- a table with entries [1] = terminal, repeat = repeat count
    local reps = parts['repeat']
    local r
    if not reps or reps=='' then
        r = 1
    else
        r = reps + 0
    end
   
    local sym = ''
    local    t=''
    local i,v
    for i,v in ipairs(parts) do
    
        -- terminal symbol
        if type (v) == "string" then
            t =  t..v
        else
            -- recursive part (i.e. a nested group)
            t = t..expand_parts(v)
        end
    end
    
    -- repeat whatever we got as many times as required
    for i = 1, r do
            sym = sym .. t
    end
       
    return sym
end

function is_in(str, tab)
-- return true if str is in the given table of strings
    for i,v in ipairs(tab) do
        if str==v then
            return true
        end
    end
    return false
end



function parse_field(f, song, inline)
    -- parse a metadata field, of the form X: stuff
    -- (either as a line on its own, or as an inline [x:stuff] field
     local name, field, match, field_name, content
          
     -- find matching field
     local field_name = nil
     for name, field in pairs(fields) do
        match = field:match(f)         
        if match then
            field_name = name
            content = match[1]
        end
     end
     
            
     -- not a metadata field at all
     if not field_name then
        -- in the header, treat lines without a tag as continuations
        if song.parse.in_header then
            field_name = 'continuation' 
            content = f                
        else
            -- otherwise it was probably a tune line
            return
        end
     end    
        
   
    local parsable = {'length', 'tempo', 'parts', 'meter', 'words', 'key', 'macro', 'user', 'voice', 'instruction'} -- those fields we parse individually
    local field = {name=field_name, content=content}
    -- continuation
    if field_name=='continuation' then
        if song.parse.last_field then
            -- append plain text if necessary
            if not is_in(song.parse.last_field, parsable) then            
                table.insert(song.token_stream, {event='append_field_text', name=song.parse.last_field, content=content, inline=inline, field={name=song.parse.last_field, content=content}})
                
            end
            
             if song.parse.last_field=='words' then
                 table.insert(song.token_stream, {event='words', lyrics=parse_lyrics(content), field=field})            
             end
         end
         
    else
        -- if not a parsable field, store it as plain text
    
        song.parse.last_field = field_name
        if not is_in(field_name, parsable) then
            table.insert(song.token_stream, {event='field_text', name=field_name, content=content, inline=inline, field=field}) 
        end

    end
    
    
    -- update specific tune settings
    if field_name=='length' then
        table.insert(song.token_stream, {event='note_length', note_length=parse_length(content), inline=inline,  field=field}) 
    end
            
    -- update tempo
    if field_name=='tempo' then            
        table.insert(song.token_stream, {event='tempo', tempo=parse_tempo(content), inline=inline, field=field})
    end
    
    -- parse lyric definitions
    if field_name=='words' then                        
         table.insert(song.token_stream, {event='words', lyrics=parse_lyrics(content), field=field, inline=inline})            
    end
    
     -- parse lyric definitions
    if field_name=='instruction' then                       
         directive = parse_directive(content)
         table.insert(song.token_stream, {event='instruction', directive=directive, field=field, inline=inline})            
    end
            
     -- parse voice definitions
    if field_name=='voice' then  
        -- in the header this just sets up the voice properties
        if song.parse.in_header then
            table.insert(song.token_stream, {event='voice_def', voice=parse_voice(content), inline=inline, field=field})
        else
            table.insert(song.token_stream, {event='voice_change', voice=parse_voice(content), inline=inline, field=field})
        end
    end
      
   
    if field_name=='parts' then            
        -- parts definition if we are still in the header
        -- look up the parts and expand them out
        if song.parse.in_header then
            local parts = content:gsub('\\.', '') -- remove dots
            parts = parse_parts(content)
            table.insert(song.token_stream, {event='parts', parts=parts, inline=inline, field=field})            
        else
            
            -- otherwise we are starting a new part   
            -- parts are always one character long, spaces and dots are ignored
            local part = content:gsub('%s', '')
            part = part:gsub('\\.', '')
            part = string.sub(part,1,1)
                        
            table.insert(song.token_stream, {event='new_part', part=part, inline=inline, field=field})            
        end
    end
    
    
    if field_name=='user' then
        -- user macro (not transposable)
        local macro = parse_macro(content)
        table.insert(song.parse.user_macros, macro)
    end
    
    if field_name=='macro' then
        -- we DON'T insert macros into the token_stream. Instead
        -- we expand them as we find them
        local macro = parse_macro(content)
        
        -- transposing macro
        if re.find(macro.lhs, "'n'") then
            local notes = {'a', 'b', 'c', 'd', 'e', 'f', 'g'} 
            for i,v in ipairs(notes) do
                table.insert(song.parse.macros, transpose_macro(macro.lhs, v, macro.rhs)) 
                table.insert(song.parse.macros, transpose_macro(macro.lhs, string.upper(v), macro.rhs)) 
            end
        else
            -- non-transposing macro
            table.insert(song.parse.macros, macro)
        end
    end
    
    -- update meter
    if field_name=='meter' then            
        table.insert(song.token_stream, {event='meter', meter=parse_meter(content), inline=inline, field=field})            
    end       
    
    -- update key
    if field_name=='key' then            
        table.insert(song.token_stream, {event='key', key=parse_key(content), inline=inline, field=field}) 
        song.parse.found_key = true -- key marks the end of the header
    end
 
end




--
-- From source file: bar.lua
--
local range_matcher = re.compile([[
    range_list <- ((<range>) (',' <range>) *) -> {}
    range <- (   <range_id> / <number> ) -> {}
    range_id <- (<number> '-' <number>)
    number <- ({ [0-9]+ }) 
    ]])

function parse_range_list(range_list)
    -- parses a range identifier
    -- as a comma separated list of numbers or ranges
    -- (e.g. "1", "1,2", "2-3", "1-3,5-6")
    -- Returns each value in this range
    
    local matches = range_matcher:match(range_pattern)    
    local sequence = {}    
    -- append each element of the range list
    for i,v in ipairs(matches) do
        -- single number
        if #v==1 then
            table.insert(sequence, v[1]+0)
        end
        
        -- range of values
        if #v==2 then            
            for j=v[1]+0,v[2]+0 do
                table.insert(sequence, j)
            end
        end    
    end
    
    
    return sequence

end


local bar_matcher = re.compile([[bar <- (  
        {:mid_repeat: <mid_repeat> :} /  {:end_repeat: <end_repeat> :}  / {:start_repeat: <start_repeat> :} / {:double: <double> :}
        /  {:thickthin: <thickthin> :} / {:thinthick: <thinthick> :} /  {:plain: <plain> :} / {:variant: <variant> :} / {:just_colons: <just_colons> :} ) -> {}        
        mid_repeat <- ({}<colons> {}<plain>{} <colons>{}) -> {}
        start_repeat <- (<plain> {} <colons> {} ) -> {}
        end_repeat <- ({}<colons> {} <plain> ) -> {}
        just_colons <- ({} ':' <colons>  {}) -> {}
        plain <- ('|')
        thickthin <- (('[' / ']') '|')
        thinthick <- ('|' ('[' / ']') )
        double <- ('|' '|')
        
        variant <- ('[')
        colons <- (':' +) 
]])

function parse_bar(bar, song)
-- Parse a bar symbol and repeat/variant markers. Bars can be
-- plain bars (|)
-- bars with thick lines (][)
-- repeat begin (|:)
-- repeat end (:|)
-- repeat middle (:||: or :: or :|:)
-- variant markers [range
   local type_info = bar_matcher:match(bar.type)
    
    -- compute number of colons around bar (which is the number of repeats of this section)
    if type_info.mid_repeat then
        type_info.end_reps = type_info.mid_repeat[2]-type_info.mid_repeat[1]
        type_info.start_reps = type_info.mid_repeat[4]-type_info.mid_repeat[3]
    end
    
    if type_info.end_repeat then
        type_info.end_reps = type_info.end_repeat[2]-type_info.end_repeat[1]        
    end
    
    -- thick bars work like repeats with a count of one
    if type_info.thickthin or type_info.thinthick or type_info.double then
        type_info.end_reps = 0
        type_info.end_repeat = true
    end
    
    if type_info.start_repeat then
        type_info.start_reps = type_info.start_repeat[2]-type_info.start_repeat[1]        
    end        
    
    -- for a colon sequence, interpret :: as one start end repeat, :::: as two start, two end, etc.
    -- odd colon numbers without a bar symbol don't make sense!
    if type_info.just_colons then
       
        type_info.start_reps = type_info.just_colons[2]-type_info.just_colons[1] / 2
        type_info.start_reps = type_info.just_colons[4]-type_info.just_colons[3] / 2
        type_info.mid_repeat = type_info.just_colons -- this is a mid repeat
        type_info.just_colons = nil
    end
    
    
    local bar_types = {'mid_repeat', 'end_repeat', 'start_repeat', 'variant',
    'plain', 'double', 'thickthin', 'thinthick'}
    
    local parsed_bar = {}
    
    -- set type field
    for i,v in ipairs(bar_types) do
        if type_info[v] then
            parsed_bar.type = v
        end
    end
    
    -- convert ranges into a list of integers
    if bar.variant_range then     
         parsed_bar.variant_range = parse_range_list(bar.variant_range)
    end
    
    parsed_bar.end_reps = type_info.end_reps
    parsed_bar.start_reps = type_info.start_reps
    
    
    
    return parsed_bar           
end




--
-- From source file: notes.lua
--
local pitch_table = {C=0, D=2, E=4, F=5, G=7, A=9, B=11}


function default_note_length(song)
    -- return the default note length
    -- if meter.num/meter.den > 0.75 then 1/8
    -- else 1/16
    if song.context.meter_data then
        local ratio = song.context.meter_data.num / song.context.meter_data.num
        if ratio>=0.75 then
            return 8
        else
            return 16
        end
    end
    return 8
end

function parse_note_def(note)
    -- Canonicalise a note, filling in the full duration field. 
    -- Remove slashes from the duration
    -- Fills in full duration field
    -- Replaces broken with an integer representing the dotted value (e.g. 0 = plain, 1 = once dotted,
    --  2 = twice, etc.)
    
    -- fill in measure rests
    if note.measure_rest and not note.measure_rest.bars then
        note.measure_rest.bars = 1
    end
    
    if note.duration.slashes and not note.duration.den then
         local den = 1
         local l = string.len(note.duration.slashes)
         for i = 1,l do
            den = den * 2
         end
         note.duration.den = den
    end
    
    if not note.duration.num then
        note.duration.num = 1
    end
    
    if not note.duration.den then
        note.duration.den = 1
    end

    if note.broken then
        local shift = 0
        -- get the overall shift: negative means this note gets shortened
        for c in note.broken:gmatch"." do
            
            if c == '>' then
                shift = shift + 1
            end
            if c == '<' then
                shift = shift - 1
            end
        end
        note.broken = nil
        note.duration.broken = shift
    end
  
  if note.pitch then
      -- add octave shifts  
      
        local octave = 0
        if note.pitch.octave then
            for c in note.pitch.octave:gmatch"." do
                if c == "'" then
                    octave = octave + 1
                end
                if c==',' then 
                    octave = octave - 1
                end
            end
        end
        
        -- +1 octave for lower case notes
        if note.pitch.note == string.lower(note.pitch.note) then
            octave = octave + 1
            note.pitch.note = string.upper(note.pitch.note)
        end
        
        note.pitch.octave = octave 
       
        -- accidentals
        if note.pitch.accidental == '^' then
           note.pitch.accidental = 1
        end
        
        if note.pitch.accidental == '^^' then
           note.pitch.accidental = 2
        end
        
        if note.pitch.accidental == '_' then
            note.pitch.accidental = -1
        end
        
        if note.pitch.accidental == '__' then
            note.pitch.accidental = -2
        end
        
        if note.pitch.accidental == '=' then
            note.pitch.accidental = 0
        end

    end
    
    -- tied notes
    if note.tie then
        note.tie = true
    end
    
    
    note.duration.slashes = nil
    return note
    
    
end

function parse_note(note)
    -- Parse a note structure. 
    -- Clean up the duration and pitch of notes and any grace notes
    -- Replace the decoration string with a sequence of decorators
    
    
    -- fix the note itself
    if note.note_def then
        parse_note_def(note.note_def)
    end
    
    -- and the grace notes
    if note.grace then
        for i,v in ipairs(note.grace) do
            parse_note_def(v)
        end
    end
    
    
    return note
    
end


function compute_pitch(note, song)
    -- compute the real pitch (in MIDI notes) of a note event
    -- taking into account: 
    --  written pitch
    --  capitalisation
    --  octave modifier
    --  current key signature
    --  accidentals
    --  transpose and octave shift
    
    -- -1 indicates a rest note
    if note.rest or note.measure_rest then
        return -1
    end
   
   local base_pitch = pitch_table[note.pitch.note]
    
    if note.pitch.octave then
        base_pitch = base_pitch + note.pitch.octave * 12
    end
    
    -- accidental in K:none applies only to following notes
    -- otherwise applies to whole measure
    -- accidental is cleared when a bar is encountered
    if song.context.key_data.naming.none then
        accidental = note.pitch.accidental 
    else
        if note.pitch.accidental then
            song.context.accidental = note.pitch.accidental 
        end
        accidental = song.context.accidental
    end
    
    -- accidentals / keys
    if accidental then
        base_pitch = base_pitch + accidental
    else        
        -- apply key signature sharpening / flattening
        local acc = song.context.key_mapping[string.lower(note.pitch.note)]
        base_pitch = base_pitch + acc
    end
        
    base_pitch = base_pitch + song.context.global_transpose
    return base_pitch + 60  -- MIDI middle C
end

function compute_duration(note, song)
    -- compute the duration (in microseconds) of a note_def
    
    -- takes into account:
    -- tempo 
    -- note length
    -- triplet state 
    -- broken state
    -- duration field of the note itself
    -- bars for multi-measure rests  
    
    local length = 1
    
    
    -- measure rest
    if note.measure_rest then   
        -- one bar =  meter ratio * note length (e.g. 1/16 = 16)
        local note_length = song.context.note_length or default_note_length(song)
        return (song.context.meter_data.num / song.context.meter_data.den) * note_length * song.context.timing.base_note_length * 1e6
    end
    
    -- we are guaranteed to have filled out the num and den fields
    if note.duration then
        length = note.duration.num / note.duration.den
    end
    
    local shift = 1
    local this_note = 1
    local next_note = 1
    
    local prev_note = 1
    
    -- take into account previous dotted note, if needed
    if song.context.timing.prev_broken_note then
        prev_note = song.context.timing.prev_broken_note
    else
        prev_note = 1
    end
    
    -- deal with broken note information
    -- a < shortens this note by 0.5, and increases the next by 1.5
    -- vice versa for >
    -- multiple > (e.g. >> or >>>) lengthens by 1.75 (0.25) or 1.875 (0.125) etc.
    if note.duration.broken then
        shift = math.pow(2, math.abs(note.duration.broken))
        
        if shift<0 then
            this_note = 1.0 / -shift
            next_note = 1.0 + 1 - (1.0 / -shift)
        else
            this_note = 1.0 + 1 - (1.0 / shift)
            next_note = (1.0 / shift)
        end
        
        -- store for later
        song.context.timing.prev_broken_note = next_note
    else
        song.context.timing.prev_broken_note = 1
    end
        
    length = length * song.context.timing.base_note_length * this_note * prev_note * 1e6 * song.context.timing.triplet_compress
   
  
    return length
   
end



function apply_triplet(song, triplet)
    -- set the triplet fields in the song
    local p,q,r
    
    if triplet.q == 'n' then
        -- check if compound time -- if so
        -- the default timing for (5 (7 and (9 changes
        if is_compound_time(song) then
            q = 3
        else    
            q = 2
        end
    else
        q = triplet.q
    end
    p = triplet.p
    r = triplet.r 
    
    -- set compression and number of notes to apply this to
    song.context.timing.triplet_compress = triplet.q / triplet.p
    song.context.timing.triplet_state = triplet.r
              
end

function parse_triplet(triplet, song)
-- parse a triplet/tuplet definition, which specifies the contraction of the following
-- n notes. General form of p notes in the time of q for the next r notes

    local n, p, q, r
    q=-1
    r=-1
            
    -- simple triplet of form (3:
    if #triplet==1 then
        p = triplet[1]+0                
    end
    
    -- triplet of form (3:2
    if #triplet==2 then
        p = triplet[1]+0                
        q = triplet[2]+0
    end
    
    -- triplet of form (3:2:3 or (3::2 or (3::
    if #triplet==3 then
        p = triplet[1]+0
        if triplet[2] and string.len(triplet[2])>0 then
            q = triplet[2]+0
        end
        if triplet[3] and string.len(triplet[3])>0 then
            r = triplet[3]+0
        end
    end
       
    -- default: r is equal to p
    if r==-1 then
        r = p
    end

    
    if p>9 then
        warn("Bad triplet length (p>9)")
    end
    
    -- default to choosing q from the table
    local q_table = {-1,3,2,3,'n',2,'n',3,'n'}
    if q==-1 then
        q = q_table[p]
    end
        
    return {p=p, q=q, r=r}
end

function expand_grace(song, grace_note)
    -- insert a grace note sequence into a song
    -- grace notes have their own separate timing (i.e. no carryover of
    -- broken note state or of triplet state)
    
    -- preserve the timing state
    local preserved_state = deepcopy(song.context.timing)
    
    song.context.timing.prev_broken_note = 1
    song.context.timing.triplet_compress = 1
    song.context.timing.base_note_length = song.context.timing.grace_note_length -- switch to grace note timing
    
    local grace = {}
    
    for i,v in ipairs(grace_note) do
        local note_def = v
        local pitch = compute_pitch(note_def, song)
        local duration = compute_duration(note_def, song)
        table.insert(grace, {pitch=pitch, duration=duration, grace=note_def})
    end
    
    -- restore timing state
    song.context.timing = preserved_state
    
    -- insert the grace sequence
    
    return grace
    
    

end
    
function insert_note(note, song)
        -- insert a new note into the song
        local note_def = note.note_def
        local pitch = compute_pitch(note_def, song)
        local duration = compute_duration(note_def, song)
       
        -- insert grace notes before the main note, if there are any
        if note.grace then
            note.grace.sequence = expand_grace(song, note.grace) 
        end
        
        -- insert the note events
        if pitch==-1 then
            -- rest
            table.insert(song.opus, {event='rest', duration=duration,
            note=note})        
        else       
            -- pitched note
            table.insert(song.opus, {event='note', pitch=pitch, duration=duration, note = note})
            
        end
   
        -- update tuplet counter; if back to zero, reset triplet compression
        if song.context.timing.triplet_state>0 then 
            song.context.timing.triplet_state = song.context.timing.triplet_state - 1
        else
            song.context.timing.triplet_compress = 1
        end
    
end



--
-- From source file: write_abc.lua
--
-- functions for writing out text represenatations of the song token_stream
local field_tags = {key = 'K'
,title = 'T'
,ref =  'X'
,area =  'A'
,book =  'B'
,composer =  'C'
,discography =   'D'
,file =   'F'
,group =   'G'
,history =   'H'
,instruction =   'I'
,length =   'L'
,meter =   'M'
,macro =   'm'
,notes =   'N'
,origin =   'O'
,parts =   'P'
,tempo =   'Q'
,rhythm =   'R'
,remark =  'r'
,source =   'S'
,symbolline =   's'
,user =   'U'
,voice =   'V'
,words =  'w'
,end_words =  'W'
,transcriber =  'Z'
,continuation =  '+'
}

function abc_meter(meter)
    -- return the string representation of a meter
    -- e.g. {num=3, den=4} becomes 'M:3/4'
    -- if there is an explicit emphasis then this produces
    -- a compound numerator (e.g. M:(2+3+2)/4)
    local num = ''
    
    if #meter.emphasis==1 then
        -- simple meter
        num = meter.num
    else
        -- join together complex meters from the empahsis table
        local e = 0
        num = '(' -- parenthesise complex meters
        for j,n in ipairs(meter.emphasis) do
           if j ~= 1 then -- first emphasis is always on 0; skip that
            num = num .. (n-e) .. '+'
            e = n
           end
        end
        
        -- length of last emphasis is however much to make up
        -- to the total meter length
        num = num .. (meter.num-e) .. ')'
           
    end
   
    local ret = string.format('M:%s/%s' , num, meter.den..'')
    return ret
    
end

function abc_tempo(tempo)
    -- return the string represenation of a tempo definition
    -- e.g. Q:1/4=120 or Q=1/2 1/4 1/2=80 "allegro"
    local q = ''
    
    
    -- abc out the tempo units
    for i,v in ipairs(tempo) do
        q = q .. string.format('%s/%s ', v.num..'', v.den..'')
    end
    
    -- strip trailing space
    q = string.sub(q, 1, -2)
    
    -- the rate as =140
    q = q .. '=' .. tempo.div_rate
    
    -- tempo names (e.g. "allegro")
    if tempo.name then
        q = q .. ' "' .. tempo.name .. '"'
    end
    
   return string.format('Q:%s', q)
end

function abc_key(key)
    -- return the string representation of a key 
    local clef = ''
    local acc = ''
    local name = key.naming
    
    -- no key
    if key.naming.none then
        return 'K:none' 
    end
    
    if key.naming.pipe then
        return 'K:HP'
    end
    
    -- root and modal modifier
    local root = string.upper(key.naming.root) 
    if key.naming.mode then     
        root = root .. key.naming.mode
    end

    -- accidentals
    if key.naming.accidentals then
        acc = ' '
        for i,v in ipairs(key.naming.accidentals) do
            acc = acc .. v
        end
    end
    
    -- handle clef modifiers 
    if key.clef then
        clef = ' '
        -- alto, treble, etc. as a bare string
        if key.clef.clef then
            clef = clef .. key.clef.clef
        end
        
        -- other settings (e.g. transpose=3) are in
        -- key=value format
        for i,v in pairs(key.clef) do
            if i ~= 'clef' then
                clef = clef .. string.format(' %s=%s',i,v..'')
            end
        end
    end
    
    return string.format('K:%s%s%s', root , acc, clef )
end

function abc_part_string(part_table)
    -- return the string representation of a parts table
    local ret = ''
    for i,v in  ipairs(part_table) do
        -- simple part
        if type(v[1])=='string' then
            ret = ret .. v[1]
        end
        
        -- sub part (e.g A(BC)2A)
        if type(v[1])=='table' then
            ret = ret .. '(' .. abc_part_string(v) .. ')'
        end
        
        
        -- repeats
        if v['repeat'] and string.len(v['repeat'])>0 and (0+v['repeat']) > 1 then
            ret = ret .. v['repeat']
        end
    end
    return ret
   
end

function abc_parts(parts)
    -- return the string representation of a parts structure
    return 'P:'..abc_part_string(parts)
end

function abc_note_length(note_length)
    return 'L:1/' .. note_length
end

function abc_lyrics(lyrics)
    -- return the ABC string for a given lyric structure
    -- lyrics should have:
    --    syllable field giving the syllable
    --    br field giving the break symbol ('-' or ' ')
    --    advance field giving the number of notes to advance to the next syllable
    local lyric_string = {}
    local next_advance
    for i,v in ipairs(lyrics) do
        local syl = v.syllable
        
        -- escape characters (unbreakable space and dash)
        syl = syl:gsub(' ', '~')
        syl = syl:gsub('-', '\\-')
        table.insert(lyric_string, syl)
        
        -- advance will be from the next symbol
        if #lyrics>i then
            next_advance = lyrics[i+1].advance
        else
            next_advance = 1
        end
        
        -- abc in holds (either syllable holds with _ or bar hold with |)
        if next_advance  then
            if next_advance=='bar' then 
                table.insert(lyric_string, '|')
            elseif next_advance>1 then
                for i=2,next_advance do
                    table.insert(lyric_string, '_')
                end
            end
        end
        
        -- insert the break symbol (' ' or '-')
        table.insert(lyric_string, v.br)
    end
    return 'w:'..table.concat(lyric_string)
end


function abc_voice(voice)
    -- return the ABC string represenation of a voice. Has
    -- an ID, and a set of optional specifiers 
    local str = 'V:'..voice.id
    
    for i,v in ipairs(voice.specifiers) do
        str = str..' '..v.lhs..'='..v.rhs
    end
    
    return str
    
end

function abc_new_part(part)
    -- return the abc definition of a new part
    return 'P:'..part
end


function abc_directive(directive, inline)
    -- Return the ABC notation for a directive (I: or %%)
    -- Uses %% for all non-standard directives and I: only
    -- for standard ones. Forces I: if in inline mode
    local standard_directives = {'abc-charset', 'abc-version', 'abc-include', 'abc-creator'}
    local str
    
    if not directive then
        return ''
    end
    
    if is_in(directive.directive, standard_directives) or inline then
        str = 'I:'..directive.directive
    else
         str = '%%'..directive.directive
    end
    
    -- append space separated arguments
    for i,v in ipairs(directive.arguments) do
        str = str .. ' ' .. v
    end
    return str
end

function abc_field(v)
    -- abc out a field entry (either inline [x:stuff] or 
    -- as its own line 
    -- X:stuff
    
    -- plain text events
    if v.event=='append_field_text' then 
        return  '+' .. ':' .. v.content
    end
    
    if v.event=='field_text' then 
        return field_tags[v.name] .. ':' .. v.content
    end
    
    -- key, tempo, meter
    if v.event=='meter' then
        return abc_meter(v.meter)
    end
 
    -- voice definitions
    if v.event=='voice_def' or v.event=='voice_change' then
        return abc_voice(v.voice)
    end
  
 
    if v.event=='key' then
        return abc_key(v.key) 
    end

    if v.event=='tempo' then
        return abc_tempo(v.tempo)
    end
    
    if v.event=='instruction' then
        return abc_directive(v.directive, v.inline)
    end

    
    if v.event=='parts' then
        return abc_parts(v.parts)
    end
    
    if v.event=='new_part' then
        return abc_new_part(v.part)
    end
    
    
    if v.event=='words' then
        return abc_lyrics(v.lyrics)
    end
    
    if v.event=='note_length' then
        return abc_note_length(v.note_length)
    end
    
    
end


function abc_triplet(triplet)
    -- abc the string represenation of a triplet specifier
    -- Uses the simplest ABC form
    -- 1-3 elements p:q:r
    -- p:q gives the ratio of the compression
    -- r gives the duration of the effect (in notes)
    
    local triplet_string
    local q_table = {-1,3,2,3,-1,2,-1,3,-1} -- default timing
    
    triplet_string = '('..triplet.p
    
    -- check if we need an r field
    local r_needed = triplet.r and triplet.r ~= triplet.p
    
    -- only need q if it's not default
    -- e.g. triplet p=3, q=2, r=3 should just be written as (3
    local q_needed = triplet.q and (q_table[triplet.p]~=triplet.q)
    
    -- triplet of form (3:2
    if q_needed or r_needed then
        triplet_string = triplet_string .. ':'
        if q_needed then 
            triplet_string = triplet_string .. triplet.q
        end
    end
    
    -- full triplet (only need r if it's not equal to p)
    if r_needed then
        triplet_string = triplet_string .. ':' .. triplet.r
    end
    
    return triplet_string .. ' ' -- must include trailing space separator!
end


function abc_pitch(note_pitch)
    -- get the string represenation of a pitch table
    -- pitch; lowercase = +1 octave
    
 
    -- root note
    local pitch = note_pitch.note
    
    -- octave shifts
    if note_pitch.octave then
        if note_pitch.octave==1 then
            pitch = string.lower(note_pitch.note)
        end
        -- increase octave with '
        if note_pitch.octave>1 then
            for i=2,note_pitch.octave do
                pitch = pitch .. "'"
            end
        end 
        -- decrease octave with ,
        if note_pitch.octave<0 then
            for i=1,-note_pitch.octave do
                pitch = pitch .. ","
            end
        end
    end
    
    if note_pitch.accidental then
        -- accidentals
        if note_pitch.accidental==1 then
            pitch = '^' .. pitch
        end
        
        if note_pitch.accidental==2 then
            pitch = '^^' .. pitch
        end
        
        if note_pitch.accidental==-1 then
            pitch = '_' .. pitch
        end
        
        if note_pitch.accidental==-2 then
            pitch = '__' .. pitch
        end
        
        if note_pitch.accidental==0 then
            pitch = '=' .. pitch
        end  
    end
    return pitch
end


function abc_duration(note_duration)
    -- get the string representation of the duration of the note
    -- e.g. as a fraction (A/4 or A2/3 or A>)

    local duration = ''
 
    -- work out the duration form
    -- nothing if fraction is 1/1
    -- just a if fraction is a/1
    -- just /b if fraction is 1/a
    -- a/b otherwise
    if note_duration.num~=1 then
        duration = duration .. note_duration.num
    end
    if note_duration.den~=1 then
        duration = duration .. '/' .. note_duration.den
    end

    -- add broken rhythm symbols (< and >)
    -- broken, this note shortened
    if note_duration.broken < 0 then
        for i=1,-note_duration.broken do
            duration = duration..'<'
        end
    end
   
    -- broken, this note lengthened
    if note_duration.broken > 0 then
        for i=1,note_duration.broken do
            duration = duration..'>'
        end
    end
   
    return duration
end


function abc_note_def(note)
    local note_str = ''
    
    -- measure rests
    if note.measure_rest then
        if note.measure_rest.bars==1 then
            return 'Z'
        else
            return 'Z' .. note.measure_rest.bars
        end
    end
    
    -- pitch and duration
    if note.rest then
        note_str = 'z'
    else
        note_str = abc_pitch(note.pitch)
    end
    note_str = note_str .. abc_duration(note.duration)
    return note_str
end

function abc_note(note)
    -- abc a note out
    -- Return the string version of the note definition
    -- Includes pitch and duration
    local note_str = ''
    
    -- grace notes (e.g. {gabE}e)
    if note.grace then
        note_str = note_str .. '{'
        for i,v in ipairs(note.grace) do
            note_str = note_str .. abc_note_def(v)
        end
        note_str = note_str .. '}'
    end
    
    -- chords (e.g. "Cm")
    if note.chord then
        note_str = note_str .. '"' .. note.chord .. '"'
    end
    
    -- decorations (e.g. . for legato)
    if note.decoration then
        note_str = note_str ..  table.concat(note.decoration)
    end
    
    -- pitch and duration
    note_str = note_str .. abc_note_def(note.note_def)
    
    -- ties
    if note.tie then
        note_str = note_str .. '-'
    end
    
    return note_str
end



function abc_bar(bar)
    -- Return a string representing a bar element
    -- a bar can be
    -- | single bar
    -- || double bar
    -- [| double thick-thin bar
    -- |] double thin-thick bar
    -- |: start repeat
    -- :| end repeat
    -- :|: mid repeat
    -- [n start variant
    
    local bar_str = ''
    
    local type_symbols = {plain='|', double='||', thickthin=']|', thinthick='[|',
    variant='['}
    
    for i,v in pairs(type_symbols) do
        if bar.type==i then 
            bar_str = v
        end
    end
    
    if bar.type=='start_repeat' then
        bar_str= '|' .. repeat_string(':', bar.start_reps)
    end
    
    if bar.type=='end_repeat' then
        bar_str= repeat_string(':', bar.end_reps) .. '|'
    end
    
    if bar.type=='mid_repeat' then
        bar_str= repeat_string(':', bar.end_reps) .. '|' .. repeat_string(':', bar.start_reps)
    end
    
    if bar.type=='variant' then 
        bar_str = '[' 
    end
    
    -- variant indicators (e.g. for parts [4 or for repeats :|1 x x x :|2 x x x ||)
    if bar.variant_range then
        -- for part variants, can have multiple indicators
        if bar.variant then
            for i,v in ipairs(bar.variant_range) do
                bar_str = bar_str .. v .. ','
            end
            -- remove last comma
            bar_str = string.sub(bar_str, 1, -1)
        else
            -- can only have one variant indicator
            bar_str = bar_str .. bar.variant_range[1]
        end
    end
    
    return bar_str
end


function abc_note_element(element)
    -- Return a string representing a note element 
    -- can be a note, rest, bar symbol
    -- chord group, slur group, triplet/tuplet
    -- line break, beam break or some inline text
    if element.event=='split' then
        return ' '
    end
    
    if element.event=='split_line' then
        return '\n'
    end
    
    if element.event=='chord' then
            return '"' .. element.chord .. '"'
    end
    
    
    if element.event=='chord_begin' then
            return '['        
    end
    
    if element.event=='chord_end' then
        return ']'
    end
    
    if element.event=='slur_begin' then
        return '('        
    end
    
    if element.event=='slur_end' then
        return ')'
    end
    
    if element.event=='text' then     
        return '"' .. element.text .. '"'
    end
    
    if element.event=='triplet' then
        return abc_triplet(element.triplet)
    end
    
    if element.event=='note' then
        return abc_note(element.note)
    end
    
    if element.event=='bar' then
        return abc_bar(element.bar)
    end
 
    
    return ''
    
end
 
function abc_element(element)    
    -- return the abc representation of token_stream element
    if element.field then

        local field = abc_field(element)
        if element.inline then
            return '['..field..']'
        else
            return field..'\n'
        end
    else
        return abc_note_element(element)
    
    end
    
end

function token_stream_to_abc(token_stream)
-- return the token_stream out as a valid ABC string
    local output = {}
    
    for i,v in ipairs(token_stream) do
         table.insert(output, abc_element(v))
    end
    -- concatenate into a single string
    return table.concat(output)
end

function abc_from_songs(songs, creator)
    -- return the ABC representation of a table of songs
    -- the creator field can optionally be specified to identify
    -- the program that created this code
    local out = {}
    creator = creator or 'abclua'
    -- write out header
    table.insert(out, '%abc-2.1\n')
    table.insert(out, '%%abc-creator='..creator..'\n')
    
    -- each song segment separated by two newlines
    for i,v in ipairs(songs) do
        table.insert(out, token_stream_to_abc(v.token_stream))
        table.insert(out, '\n\n')
    end
end


--
-- From source file: token_stream.lua
--
-- Functions from transforming a parsed token_stream stream into a song structure and then an event stream




function update_timing(song)
    -- Update the base note length (in seconds), given the current L and Q settings
    local total_note = 0
    local rate = 0    
    local note_length = song.context.note_length or default_note_length(song)
    
    for i,v in ipairs(song.context.tempo) do
        total_note = total_note + (v.num / v.den)
    
    end                    
    rate = 60.0 / (total_note * song.context.tempo.div_rate)
    song.context.timing.base_note_length = rate / note_length
    -- grace notes assumed to be 32nds
    
    song.context.timing.grace_note_length = rate / (song.context.grace_length.num / song.context.grace_length.den)
end    



function is_compound_time(song)
    -- return true if the meter is 6/8, 9/8 or 12/8
    -- and false otherwise
    local meter = song.context.meter_data
    if meter then
        if meter.den==8 and (meter.num==6 or meter.num==9 or meter.num==12) then
            return true
        end
    end
    return false
end


function apply_repeats(song, bar)
        -- clear any existing material
        if bar.type=='start_repeat' then
            add_section(song, 1)
        end
                                
        -- append any repeats, and variant endings
        if bar.type=='mid_repeat' or bar.type=='end_repeat' or bar.type=='double' or bar.type=='thickthin' or bar.type=='thinthick' then
        
            add_section(song, bar.end_reps+1)
            
            -- mark that we will now go into a variant mode
            if bar.variant_range then
                -- only allows first element in range to be used (e.g. can't do |1,3 within a repeat)
                song.context.in_variant = bar.variant_range[1]
            else
                song.context.in_variant = nil
            end            
        end
        
        -- part variant; if we see this we go into a new part
        if bar.type=='variant' then
            start_variant_part(song, bar)
        end        
end


function apply_key(song, key_data) 
    -- apply transpose / octave to the song state
    if key_data.clef then                 
        if key_data.clef.octave then
            song.context.global_transpose = 12 * key_data.clef.octave -- octave shift
        else
            song.context.global_transpose = 0
        end
        
        if key_data.clef.transpose then 
            song.context.global_transpose = song.context.global_transpose + key_data.clef.transpose                
        end
    end 
    
    -- update key map
    song.context.key_mapping = create_key_structure(key_data.naming)
end

function finalise_song(song)
    -- Finalise a song's event stream
    -- Composes the parts, repeats into a single stream
    -- Inserts absolute times into the events 
    -- Inserts the lyrics into the song

    compose_parts(song)
    
    -- clear temporary data
    song.opus = nil
    song.temp_part = nil 
 
    -- time the stream and add lyrics    
    song.stream = insert_lyrics(song.context.lyrics, song.stream)
    time_stream(song.stream)
    
end


function start_new_voice(song, voice)
    -- compose old voice into parts
    if song.context and song.context.voice then
        finalise_song(song)
        song.voices[song.context.voice] = {stream=song.stream, context=song.context}
    end

    -- reset song state
    -- set up context state
    song.context.lyrics = {}
    song.context.current_part = 'default'
    song.context.part_map = {}
    song.context.pattern_map = {}
    song.context.timing = {}
    
    song.context.timing.triplet_state = 0
    song.context.timing.triplet_compress = 1
    song.context.timing.prev_broken_note = 1
    song.context.voice = voice
    song.temp_part = {}
    song.opus = song.temp_part
        
    update_timing(song) -- make sure default timing takes effect    
end


function expand_token_stream(song)
    -- expand a token_stream into a song structure
    
    for i,v in ipairs(song.token_stream) do
   
        -- write in the ABC notation event as a string
        table.insert(song.opus, {event='abc', abc=abc_element(v)}) 
        
        -- copy in standard events that don't change the context state
        if v.event ~= 'note' then
            table.insert(song.opus, deepcopy(v))
        else
           insert_note(v.note, song)                                         
        end
       
        -- end of header; store metadata so far
        if v.event=='header_end' then
            song.header_metadata = deepcopy(song.metadata)
            song.header_context = deepcopy(song.context) 
        end
       
        -- deal with triplet definitions
        if v.event=='triplet' then                
            -- update the context tuplet state so that timing is correct for the next notes
            apply_triplet(song, v.triplet)
            end
        
        -- deal with bars and repeat symbols
        if v.event=='bar' then
            apply_repeats(song, v.bar)                               
            song.context.accidental = nil -- clear any lingering accidentals             
        end
            
       
        if v.event=='append_field_text' then       
            song.metadata[v.field.name] = song.metadata[v.field.name] .. ' ' .. v.content
        else
            if v.field then               
                song.metadata[v.field.name] = v.field.content
            end
        end
        
        -- new voice
        if v.event=='voice_change' then
            start_new_voice(song, v.voice.id)
        end
        
        if v.event=='instruction' then
            apply_directive(song, v.directive.directive, v.directive.arguments)
        end
         
        
        if v.event=='note_length' then
             song.context.note_length = v.note_length
            update_timing(song)
        end
        
        if v.event=='tempo' then
            song.context.tempo = v.tempo
            update_timing(song)
        end
        
        if v.event=='words' then                            
            append_table(song.context.lyrics, v.lyrics)
        end
            
        if v.event=='parts' then
            song.context.part_structure = v.parts
            song.context.part_sequence = expand_parts(song.context.part_structure)      
        end
        
        if v.event=='new_part' then
            song.in_variant_part = nil -- clear the variant flag
            start_new_part(song, v.part)    
        end
        
        if v.event=='meter' then  
            song.context.meter_data = v.meter
            update_timing(song)   
        end
        
        -- update key
        if v.event=='key' then            
            song.context.key_data = v.key
            apply_key(song, song.context.key_data)
        end
 
    
    end
    
end





function token_stream_to_stream(song, context, metadata)
    -- Convert a token_stream into a full
    -- a song datastructure. 
    -- 
    -- song.metadata contains header data about title, reference number, key etc.
    --  stored as plain text
   
    -- The song contains a table of voices
    -- each voice contains:
    -- voice.stream: a series of events (e.g. note on, note off)
    --  indexed by microseconds,
    -- voice.context contains all of the parsed song data
   
    
    -- copy any inherited data from the file header
    
    song.default_context = context
    song.context = deepcopy(song.default_context)
   
    song.voices = {}
    song.metadata = metadata    
    start_new_voice(song, 'default')
    expand_token_stream(song)
    
    -- finalise the voice
    start_new_voice(song, nil)
    
    -- clean up
    song.stream = nil
    
end


--
-- From source file: parse_abc.lua
--
-- Grammar for parsing tune definitions
local tune_pattern = [[
elements <- ( ( <element>)  +) -> {}
element <- (  {:field: field :}  / ({:slur: <slurred_note> :}) / ({:chord_group: <chord_group> :})  / {:bar: (<bar> / <variant>) :}   / {:free_text: free :} / {:triplet: triplet :} / {:s: beam_split :}  / {:continuation: continuation :}) -> {}

continuation <- ('\')
beam_split <- (%s +)
free <- ( '"' {:text: [^"]* :} '"' ) -> {}
bar <- ( {:type: ((']' / '[') * ('|' / ':') + (']' / '[') *) :} ({:variant_range: (<range_set>) :}) ? ) -> {}
variant <- ({:type: '[' :} {:variant_range: <range_set> :})   -> {}
range_set <- (range (',' range)*)
range <- ([0-9] ('-' [0-9]) ?)
slurred_note <- ( ((<complete_note>) -> {}) / ( ({:chord: chord :} ) ? '(' ((<complete_note> %s*)+) ')' )  -> {}  ) 


chord_group <- ( ({:chord: chord :} ) ? ('[' ((<complete_note> %s*) +) ']' ) ) -> {} 
complete_note <- (({:grace: (grace)  :}) ?  ({:chord: (chord)  :}) ?  ({:decoration: {(decoration +)}->{} :}) ? {:note_def: full_note  :} ({:tie: (tie)  :}) ? ) -> {}
triplet <- ('(' {[1-9]} (':' {[1-9] ?}  (':' {[1-9]} ? ) ?) ?) -> {}
grace <- ('{' full_note + '}') -> {}
tie <- ('-')
chord <- (["] {([^"] *)} ["])
full_note <-  (({:pitch: (note) :} / {:rest: (rest) :} / {:measure_rest: <measure_rest> :} ) {:duration: (duration ?)  :}  {:broken: (broken ?)  :})  -> {}
rest <- ( 'z' / 'x' )
measure_rest <- (('Z' / 'X') ({:bars: ([0-9]+) :}) ? ) -> {}
broken <- ( ('<' +) / ('>' +) )
note <- (({:accidental: (accidental )  :})? ({:note:  ([a-g]/[A-G]) :}) ({:octave: (octave)  :}) ? ) -> {}
decoration <- ('.' / [~] / 'H' / 'L' / 'M' / 'O' / 'P' / 'S' / 'T' / 'u' / 'v' / ('!' ([^!] *) '!') / ('+' ([^+] *) '+'))
octave <- (( ['] / ',') +)
accidental <- (  '^^' /  '__' /  '^' / '_' / '=' )
duration <- ( (({:num: ([1-9] +) :}) ? ({:slashes: ('/' +)  :})?  ({:den: ((  [1-9]+  ) ) :})?))  -> {}

field <- (  '['  {:contents: field_element  ':'  [^]`] + :} ']' ) -> {}
field_element <- ([A-Za-z])

]]
local tune_matcher = re.compile(tune_pattern)

function read_tune_segment(tune_data, song)
    -- read the next token in the note stream
    
    for i,v in ipairs(tune_data) do
        
        if v.measure_rest then
            local bars = v.measure_rest.bars or 1
            table.insert(song.token_stream, {event='measure_rest', bars=bars})
        end
        
        -- store annotations
        if v.free_text then
            -- could be a standalone chord
            if is_chord(v.free_text.text) then
                table.insert(song.token_stream, {event='chord', chord=v.free_text.text})
            else
                table.insert(song.token_stream, {event='text', text=v.free_text.text})
            end
        end
        
        -- parse inline fields (e.g. [r:hello!])
        if v.field then                
            -- this automatically writes it to the token_stream            
            parse_field(v.field.contents, song, true)
        end
        
        -- deal with triplet definitions
        if v.triplet then                                        
            table.insert(song.token_stream, {event='triplet', triplet=parse_triplet(v.triplet, song)})
            
        end
        
        -- beam splits
        if v.s then
            table.insert(song.token_stream, {event='split'})
        end
        
        -- linebreaks
        if v.linebreak then
            table.insert(song.token_stream, {event='split_line'})
        end
            
        
        -- deal with bars and repeat symbols
        if v.bar then            
            table.insert(song.token_stream, {event='bar', bar=parse_bar(v.bar)  })                      
        end
        
        -- chord groups
        if v.chord_group then
        
            -- textual chords
            if v.chord_group.chord then
                table.insert(song.token_stream, {event='chord', chord=v.chord_group.chord})                                
            end
            
            if v.chord_group[1] then
                table.insert(song.token_stream, {event='chord_begin'})                                
                -- insert the individual notes
                for i,note in ipairs(v.chord_group) do                
                    local cnote = parse_note(note)
                    table.insert(song.token_stream, {event='note', note=cnote})                        
                end
                table.insert(song.token_stream, {event='chord_end'})                                
            end                               
            
        end
        
        -- if we have slur groups then there are some notes to parse...
        if v.slur then            
            if v.slur.chord then
                table.insert(song.token_stream, {event='chord', chord=v.slur.chord})                                
            end
            
            -- slur groups (only put the group in if there
            -- are more than elements, or there is an associated chord name)
            if #v.slur>1  then
                table.insert(song.token_stream, {event='slur_begin'} )
               
            end
            
            -- insert the individual notes
            for i,note in ipairs(v.slur) do                
                local cnote = parse_note(note)                
                table.insert(song.token_stream, {event='note', note=cnote})
            end
                
            if #v.slur>1 then
                table.insert(song.token_stream, {event='slur_end'} )
            end

        end
    end
    
end

function parse_abc_line(line, song)
    -- Parse one line of ABC, updating the song
    -- datastructure. Temporary state is held in
    -- information from line to line
        
    -- strip whitespace from start and end of line
    line = line:gsub('^%s*', '')
    line = line:gsub('%s*$', '')
    
    -- remove any backquotes
    line = line:gsub('`', '')
    
    -- replace stylesheet directives with I: information fields
    line = line:gsub("^%%%%", "I:")    
    
    -- strip comments
    line = line:gsub("%%.*", "")
        
    --
    -- read tune
    --
    if not song.parse.in_header then
        
        -- try and match notes
        local match = tune_matcher:match(line)
                
        -- if it was a tune line, then parse it
        -- (if not, it should be a metadata field)
        if match then            
            -- check for macros
            if #song.parse.macros>0 or #song.parse.user_macros>0  then
                local expanded_line = apply_macros(song.parse.macros, line)
                expanded_line = apply_macros(song.parse.user_macros, expanded_line)
                if expanded_line ~= line then
                    -- macros changed this line; must now re-parse the line
                    match = tune_matcher:match(expanded_line)
                    if not match then
                        warn('Macro expansion produced invalid output '..line..expanded_line)
                        return -- if macro expansion broke the parsing, ignore this line
                    end
                end
            end
            
            -- we found tune notes; this isn't a file header
            song.parse.has_notes = true
            
            -- insert linebreaks if there is not a continuation symbol
            if  not match[#match].continuation then
                table.insert(match, {linebreak=''})    
            end                             
            read_tune_segment(match, song)
        end
    end
    
    --
    -- read header or metadata
    --       
    -- read metadata fields
    parse_field(line, song)
      
    -- check if we've read the complete header; terminated on a key
    if song.parse.found_key and song.parse.in_header then
        song.parse.in_header = false
        table.insert(song.token_stream, {event='header_end'})
    end
end    

    

function parse_abc(str)
    -- parse and ABC file and return a song with a filled in token_stream field
    -- representing all of the tokens in the stream    
    local lines = split(str, "[\r\n]")
    local song = {}
    song.token_stream = {}
    song.parse = {in_header=true, has_notes=false, macros={}, user_macros={}}
    for i,line in pairs(lines) do 
        parse_abc_line(line, song)
        
        -- local success, err = pcall(parse_abc_line, line, song)
        -- if not success then
            -- warn('Parse error reading line '  .. line.. '\n'.. err)
        -- end
    end
        
    return song 
end
    


function get_default_context()
    return   deepcopy({
    tempo = {div_rate=120, [1]={num=1, den=8}}, 
    use_parts = false,
    meter_data = {num=4, den=4},
    key_data = { naming={root='C', mode='maj'}, clef={}},
    key_mapping = {c=0,d=0,e=0,f=0,g=0,a=0,b=0},
    global_transpose = 0,
    grace_length = {num=1, den=32}
    })
end
    
local section_matcher = re.compile([[
     abc_tunes <- (section (break section) * last_line ?) -> {}
     break <- (([ ] * %nl)  )
     section <- { (line +)  }
     line <- ( ([^%nl] +  %nl) )
     last_line <- ( ([^%nl]+) )
    ]] 
)    
function parse_all_abc(str)
         
    -- split file into sections
   
    
    str = str..'\n'
    
    
    -- tunes must begin with a field (although there
    -- can be directives or comments first)
    local sections = section_matcher:match(str)
    local tunes = {}    
    
    -- malformed file
    if not sections or #sections==0 then
        return {}
    end
   
    -- only include patterns with a field in them; ignore 
    -- free text blocks
    for i,v in ipairs(sections) do    
        if v:gmatch('\n[a-zA-Z]:') then            
            table.insert(tunes, v)  
        end
    end
        
    
    -- set defaults for the whole tune
    local default_metadata = {}
    
    local default_context = get_default_context()
    
    -- no tunes!
    if #tunes<1 then
        return {}
    end
    
    local songs = {}
    
    -- first tune might be a file header
    local first_tune = parse_abc(tunes[1]) 
    token_stream_to_stream(first_tune,  deepcopy(default_context), deepcopy(default_metadata))
    table.insert(songs, first_tune)
    
    
    -- if no notes, is a global header for this whole file
    if not first_tune.parse.has_notes then
        default_metadata = first_tune.metadata
        default_context = first_tune.context
    end
    
   
    -- add remaining tunes, using file header as default, if needed
    for i,v in ipairs(tunes) do
        -- don't add first tune twice
        if i~=1 then
            local tune = parse_abc(v) 
            token_stream_to_stream(tune, deepcopy(default_context), deepcopy(default_metadata))    
            table.insert(songs, tune)
        end
    end
    
    return songs
end

function parse_abc_file(filename)
    -- Read a file and send it for parsing. Returns the 
    -- corresponding song table.
    local f = io.open(filename, 'r')
    local contents = f:read('*a')
    return parse_all_abc(contents)
end

function parse_abc_fragment(str, parse)
    -- Parse a short abc fragment, and return the token stream table
    local song = {}
    song.token_stream = {}
    -- use default parse structure if not one specified
    song.parse = parse or {in_header=false, has_notes=false, macros={}, user_macros={}}    
    
    if not pcall(parse_abc_line, str, song) then
        song.token_stream = nil -- return nil if the fragment is unparsable
    end
    return song.token_stream
end

function fragment_to_stream(tokens, context)
    --Converts a token stream from a fragment into a timed event stream
    -- Returns the event stream if this is a single voice fragment, or
    -- a table of voices, if it is a multi-voice fragment
    --
    -- Note that this is a relatively slow function to execute, as it
    -- must copy the context, expand the stream and then finalise the song
    context = context or get_default_context()
    
    local song = {context=deepcopy(context), token_stream=tokens}
            
    song.voices = {}
    song.metadata = metadata        
    start_new_voice(song, 'default')
    expand_token_stream(song)    
    
    -- finalise the voice
    start_new_voice(song, nil)
    
    if #song.voices>1 then
        local voice_stream = {}
        -- return a table of voices
        for i,v in pairs(song.voices) do
            voice_streams[i] = v.stream
        end
        return voice_streams
    else    
        -- return the default voice stream
        return song.voices['default'].stream    
    end
end


-- module exports
abclua = {
name="abclua",
parse_all_abc = parse_all_abc,
parse_abc = parse_abc,
parse_abc_fragment = parse_abc_fragment,
fragment_to_stream = fragment_to_stream,
parse_abc_file = parse_abc_file,
print_notes = print_notes,
print_lyrics_notes = print_lyrics_notes,
token_stream_to_abc = token_stream_to_abc,
song_to_opus = song_to_opus,
stream_to_opus = stream_to_opus,
make_midi = make_midi,
make_midi_from_stream = make_midi_from_stream,
trim_event_stream = trim_event_stream,
render_grace_notes = render_grace_notes,
register_user_directive = register_user_directive,
abc_from_songs = abc_from_songs,
abc_element = abc_element
}



-- TODO:
-- convert midi to abc (quantize, find key, map notes, specify chord channel (and match chords))
-- render decorations
-- match against instrument notes (penalties for notes)
-- abc-include
-- consider macros when octave modifiers and ties are applied
-- tidy up stream rendering

-- fix lyrics alignment (2.0 compatible and verses)
-- voice overlay with &
-- voice transpose/octave/+8-8

-- styling for playback
-- extend test suite




