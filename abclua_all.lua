-- ABC Lua single file: autogenerated from source files
-- DO NOT EDIT; regenerate using make_abclua.lua
--
-- 
-- Simple ABC parsing for Lua. This library can read a reasonable
-- subset of ABC and generate tables representing the song structure.
--
-- Requires: 
--     Lua 5.1+ http://www.lua.org
--     LPeg http://www.inf.puc-rio.br/~roberto/lpeg/
--
-- License: BSD 3 clause license
--  
-- * Copyright (c) 2013, John Williamson
-- * All rights reserved.
-- *
-- * Redistribution and use in source and binary forms, with or without
-- * modification, are permitted provided that the following conditions are met:
-- *     * Redistributions of source code must retain the above copyright
-- *       notice, this list of conditions and the following disclaimer.
-- *     * Redistributions in binary form must reproduce the above copyright
-- *       notice, this list of conditions and the following disclaimer in the
-- *       documentation and/or other materials provided with the distribution.
-- *     * Neither the name of the <organization> nor the
-- *       names of its contributors may be used to endorse or promote products
-- *       derived from this software without specific prior written permission.
-- *
-- * THIS SOFTWARE IS PROVIDED BY <copyright holder> ``AS IS'' AND ANY
-- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-- * DISCLAIMED. IN NO EVENT SHALL <copyright holder> BE LIABLE FOR ANY
-- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.**
--

local re = require "re"
module(...,package.seeall)
--
-- From source file: utils.lua
--

function repeat_string(str, times)
    -- return the concatenation of a string a given number of times
    -- e.g. repeat_string('abc', '3') = 'abcabcabc'
    return string.rep(str, times)       
end

-- return the greatest common divisor of a and b
function gcd(a, b)
  while a ~= 0 do
    a,b = (b%a),a
  end
  return b
end

function first_difference_string(a,b)
    -- Determines where the mismatch in two strings is
    -- Returns the mismatch point or nil is there isn't one
    local mismatch 
    for i=1,string.len(a) do
        if i>string.len(b) or string.sub(a,1,i)~=string.sub(b,1,i) then
            mismatch = i
            break
        end    
    end
    return mismatch
end


-- set a field of the whole table
function set_property(t, key, value)
    for i,v in pairs(t) do
        v[key] = value
    end
end

function aligned_warning()
end

function copy_array(orig)
    -- copy an array (only integer keys are copied)
    local copy = {}
    for i=1,#orig do
        copy[i] = orig[i]
    end
    return copy
end

function copy_table(orig)
    -- shallow copy a table (does not copy the contents)
    local copy = {}
    for i,v in pairs(orig) do
        copy[i] = v
    end
    return copy   
end


-- copy a table completely (excluding metatables)
-- don't copy keys, just values
function deepcopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[orig_key] = deepcopy(orig_value)
        end        
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end


function time_execution(fn, times)
    -- time the execution of a function
    times = times or 1
    local start_t = os.clock()
    for i=1,times do
        fn()
    end
    local end_t = os.clock() - start_t    
    return end_t/times
end

-- Right trim a string
function rtrim(s)
  local n = #s
  while n > 0 and s:find("^%s", n) do n = n - 1 end
  return s:sub(1, n)
end

-- Print anything - including nested tables
function verbose_table_print (tt, indent, done)
  done = done or {}
  indent = indent or 0
  if type(tt) == "table" then
    for key, value in pairs (tt) do
      io.write(string.rep (" ", indent)) -- indent it
      if type (value) == "table" and not done [value] then
        done [value] = true
        io.write(string.format("[%s] => table\n", tostring (key)));
        io.write(string.rep (" ", indent+4)) -- indent it
        io.write("(\n");
        table_print (value, indent + 7, done)
        io.write(string.rep (" ", indent+4)) -- indent it
        io.write(")\n");
      else
        io.write(string.format("[%s] => %s\n",
            tostring (key), tostring(value)))
      end
    end
  else
    io.write(tt .. "\n")
  end
end

-- Print anything - including nested tables
function table_print (tt, indent, done)
  if tt==nil then
    io.write('nil\n')
    return
  end
  done = done or {}
  indent = indent or 0
  if type(tt) == "table" then
    for key, value in pairs (tt) do
      io.write(string.rep (" ", indent)) -- indent it
      if type (value) == "table" and not done [value] then
        done [value] = true
        io.write(string.format("%s = \n", tostring (key)));
        io.write(string.rep (" ", indent+4)) -- indent it
        io.write("{\n");
        table_print (value, indent + 7, done)
        io.write(string.rep (" ", indent+4)) -- indent it
        io.write("}\n");
      else
        io.write(string.format("%s=%s\n",
            tostring (key), tostring(value)))
      end
    end
  else
    io.write(tt .. "\n")
  end
end


-- Print anything - including nested tables
function table_str (tt, indent, done)
  if tt==nil then
    return('nil')    
  end
  local result = {}
  local done = done or {}
  local indent = indent or 0
  if type(tt) == "table" then
    table.insert(result, '{')
    
    -- enforce consistent key ordering
    local keys = {}
    for i,v in pairs(tt) do
        table.insert(keys, i)
    end
    table.sort(keys)
    
    
    for i,key in ipairs (keys) do            
      local value = tt[key]
      if type (value) == "table" and not done [value] then
        done [value] = true        
        table.insert(result, string.format("%s=%s,", tostring (key), table_str(value,0,done)))        
      else
        table.insert(result, string.format("%s=%s,", tostring (key), tostring(value)))
      end      
    end
    table.insert(result, '}')
    return table.concat(result)
  else
    return tostring(value)
  end
end

function invert_table(t)
    -- invert a table so that values map to keys
    local n = {}
    for i,v in pairs(t) do
        n[v] = i
    end
    return n
end


function append_table(a, b)
    -- Append b to a. Operates in-place, and returns a copy
    -- of the modified array
    for i,v in ipairs(b) do    
        table.insert(a,v)
    end
    return a
end

-- Compatibility: Lua-5.1
function split(str, pat)
   local t = {}  -- NOTE: use {n = 0} in Lua-5.0
   local fpat = "(.-)" .. pat
   local last_end = 1
   local s, e, cap = str:find(fpat, 1)
   while s do
      if s ~= 1 or cap ~= "" then
	 table.insert(t,cap)
      end
      last_end = e+1
      s, e, cap = str:find(fpat, last_end)
   end
   if last_end <= #str then
      cap = str:sub(last_end)
      table.insert(t, cap)
   end
   return t
end

function is_in(str, tab)
-- return true if str is in the given table of strings
    for i,v in ipairs(tab) do
        if str==v then
            return true
        end
    end
    return false
end


function warn(message)
-- print a warning message
    print(message)
end

function find_first_match(t, match)
    -- Find the first element of t, where all of the given field=value pairs match
    -- or nil, if no match
    local is_match
   for i,v in ipairs(t) do
     is_match = true
     -- check all fields of match
     for j,n in pairs(match) do
        if not v[j] or v[j]~=n then
            is_match = false
        end
     end
     -- if we matched, we found it!
     if is_match then
        return i
    end
   end
   return nil
end

function swap(t, a, b)
    -- swap the indices of t so that t[a] = t[b] and t[b] = t[a]
    local ta, tb = t[a], t[b]
    t[b] = ta
    t[a] = tb
end


--
-- From source file: keys.lua
--
-- Functions for handling key signatures and modes
-- and working out sharps and flats in keys.

-- semitones in the major scale
local major = {'c','d','e','f','g','a','b'}
local key_table = 
{
c = {0,0,0,0,0,0,0},
g = {0,0,0,1,0,0,0},
d = {1,0,0,1,0,0,0},
a = {1,0,0,1,1,0,0},
e = {1,1,0,1,1,0,0},
b = {1,1,0,1,1,1,0},
fs = {1,1,1,1,1,1,0},
cs = {1,1,1,1,1,1,1},
f =  {0,0,0,0,0,0,-1},
bb = {0,0,-1,0,0,0,-1},
eb = {0,0,-1,0,0,-1,-1},
ab = {0,-1,-1,0,0,-1,-1},
db = {0,-1,-1,0,-1,-1,-1},
gb = {-1,-1,-1,0,-1,-1,-1},
cb = {-1,-1,-1,-1,-1,-1,-1},

-- not real keys, but sound correct
as = {0,0,-1,0,0,0,0},
ds = {0,0,-1,0,0,-1,-1},
gs = {0,-1,-1,0,0,-1,-1},
fs = {-1,-1,-1,0,-1,-1,-1},
bs = {-1,-1,-1,-1,-1,-1,-1},
}


local diatonic_scale = {[0]='b', 'c', 'd', 'e', 'f', 'g', 'a', 'b'}
local inverse_diatonic_scale = invert_table(diatonic_scale)

function nth_note_of_key(key, n)
    -- return the nth note of a key (e.g. 2nd note of C is D,
    -- 2nd note of G is A etc.)
    local base = inverse_diatonic_scale[key]
    return diatonic_scale[(base+n) % 7]
end


-- offsets for the common modes
local mode_offsets = {maj=0, min=3, mix=5, dor=10, phr=8, lyd=7, loc=1}

function get_major_key(key)
    -- return the semitones in a given major key
    -- (e.g. C = {0,2,4,5,7,9,11})
    local c_major = {0,2,4,5,7,9,11}
    for i,v in ipairs(key_table[key]) do
        
        local semi = c_major[i] + v
        
        -- wrap to 0-12
        if semi<0 then
            semi = semi + 12
        end
        if semi>12 then
            semi = semi - 12
        end
        c_major[i] = semi
    end
    return c_major
end

function get_major_keys()
    -- return a table mapping key names to semitone values
    local keys = {}
    for i,v in pairs(key_table) do
        keys[i] = get_major_key(i)
    end   
    return keys
end


function compute_mode(offset)
    -- compute a mapping from notes in a given mode to the corresponding major key
    -- e.g. compute_mode(3) gives the relative major keys of each possible minor key
    -- return value is a table mapping from the modal key (e.g. E min) to the 
    -- corresponding major key (e.g. G)
    local notes = {}
    local all_notes = all_note_table()
    for i,v in pairs(all_notes) do
        local new_pitch = canonical_note_name((v+offset)%12)
        notes[i] = new_pitch
    end
    return notes
end


local key_matcher = re.compile([[
    key <- ( {:none: ('none') :} / {:pipe: ('hp' / 'Hp' / 'HP' ) :} / (
        {:root: ([a-gA-G]) 'b'? '#'? :}  
        (%s * {:mode: (mode %S*):}) ? 
        (%s * {:accidentals: (accidentals):}) ?         
         ({:clef:  ((%s + <clef>) +) -> {}   :})  ?           
        )) -> {} 
    clef <-  (({:clef: clefs :}  / clef_def /  middle  / transpose / octave / stafflines / custom )  ) 
    custom <- ([^:] + ':' [^=] + '=' [%S] +)
    clef_def <- ('clef=' {:clef: <clefs> :} [0-9] ? ({:plus8: (  '+8' / '-8' ) :})  ? ) 
    clefs <- ('alto' / 'bass' / 'none' / 'perc' / 'tenor' / 'treble' )
    middle <- ('middle=' {:middle: <number> :})
    transpose <- (('transpose='/'t=')  {:transpose: <number> :}) 
    octave <- ('octave=' {:octave: <number> :}) 
    stafflines <- ('stafflines=' {:stafflines: <number> :})
    number <- ( ('+' / '-') ? [0-9]+)
    mode <- ( ({'maj'}) / ({'aeo'}) / ({'ion'}) / ({'mix'}) / ({'dor'}) / ({'phr'}) / ({'lyd'}) /
          ({'loc'}) /  ({'exp'}) / ({'min'}) / {'m'}) 
    accidentals <- ( accidental (%s+ accidental) * ) -> {} 
    accidental <- ( {('^^' / '__' / '_' / '^' / '=')} (duration)? {[a-g]}  ) -> {} 
    duration <- ( (({:num: ([1-9] +) :}) ? ({:slashes: ('/' +)  :})?  ({:den: ((  [1-9]+  ) ) :})?))  -> {}

]])

function parse_key(original_k)
    -- Parse a key definition, in the format <root>[b][#][mode] [accidentals] [expaccidentals]    

    k = original_k:lower()
    local captures = key_matcher:match(k)
    
    -- if no key, the K:none assumed
    if not captures then
        captures = {none='none'}        
    end
    
    -- must preseve case in pipe keys; just reparse without
    -- lowercasing
    if captures.pipe then
        captures = key_matcher:match(original_k)
    end
    
    -- normalise the accidentals
    local accidentals = {}
    local value
    if captures.accidentals then    
        for i,v in ipairs(captures.accidentals) do            
            value = canonicalise_accidental(v)
            table.insert(accidentals, {note=v[3],accidental=value})
        end
    end
    captures.accidentals = accidentals
   
    --replace +8 / -8 with a straightforward transpose
    if captures.clef and captures.clef.plus8 then
        if captures.clef.plus8=='-8' then
            captures.clef.octave = (captures.clef.octave or 0) + 1
        else
            captures.clef.octave = (captures.clef.octave or 0) - 1 
        end
        captures.clef.plus8 = nil
    end
    
    -- replace transpose with t
    if captures.clef and captures.clef.t then
        captures.clef.transpose = captures.clef.t
        captures.clef.t = nil
    end
    
    return captures       
end


function notes_in_key(key)
    -- return the semitone numbers of notes in this key
    local in_key = {}
    local major = get_major_key('c')
    local key_structure = create_key_structure(key)
    
    local j = 1 
    for i,v in pairs(key_structure) do
        -- C major semitones + the flattening/sharpening
        in_key[(major[j]+v)%12] = 1
        j = j + 1
    end
    return in_key
end

function key_semitones(key)
    -- return each semitone in this key, in order.     
    local key_structure = create_key_structure(key)
    local semis = {}
    local k = 0
    local cmajor = get_major_key('c')    
    -- go through each key in scale...
    for i,v in ipairs(major) do
        k = cmajor[i] + key_structure[v]
        table.insert(semis, k)
    end
    return semis
end

function create_key_structure(k)
    -- Create a key structure, which lists each note as written (e.g. A or B)
    -- and maps it to the correct semitone in the interval
    
    local key_mapping = {}    
    
    -- default: C major if no signature
    for i,v in pairs(key_table['c']) do                        
            key_mapping[major[i]] = v
    end        
    
    -- none = c major, all accidentals must be specified
    if k.none then
        return key_mapping
    end
    
    -- Pipe notation (Hp or HP): F sharp and G sharp
    if k.pipe then
        for i,v in pairs(key_table['c']) do                        
                key_mapping[major[i]] = v
        end        
        
        key_mapping['c'] = 1 -- C sharp
        key_mapping['g'] = 1 -- F sharp
        return key_mapping  
    else
        -- find the matching key        
        local root = k.root
        root = root:gsub('#', 's')
        
        -- offset according to mode
        if k.mode then
            -- convert 'm' or 'aeolian' to 'min'
            if k.mode=='aeo'  or k.mode=='m' then
                k.mode = 'min'
            end
            
            -- convert 'ionian' to 'maj'
            if k.mode=='ion' then
                k.mode = 'maj'
            end            
            
            -- get the modal offset
            local modal_root = root            
            
            -- find relative major key -- use sharps and flats from that key
            if mode_offsets[k.mode] then
                local major_mapping = compute_mode(mode_offsets[k.mode])
                root = major_mapping[root] -- get relative major key                        
            end            
        end

        -- map each element of the major scale to the accidental value
        -- (0, 1, or -1)
        for i,v in pairs(key_table[root]) do                        
            key_mapping[major[i]] = v
        end
        
        -- add accidentals to the mapping
        -- these overwrite the key-set values
        if k.accidentals then
            for i,v in pairs(k.accidentals) do
                if v.accidental.num == 0 then
                    key_mapping[v.note] = 0
                else
                    -- we can use fractional accidentals in the key
                    key_mapping[v.note] = v.accidental.num / v.accidental.den
                   
                end
            end
        end
        
                        
    end
    return key_mapping
end




--
-- From source file: parts.lua
--
-- Functions for dealing with parts, repeats and sub-patterns

function add_section(song, repeats)
    -- add the current temporary buffer to the song as a new pattern
    -- repeat it repeat times
    repeats = repeats or 1
        
    if not song.context.in_variant then
        table.insert(song.context.pattern_map, {section=song.opus, repeats=repeats, variants={}})
    else
        table.insert(song.context.pattern_map[#song.context.pattern_map].variants, song.opus)
    end
        
    song.opus = {}
    
end


function start_new_part(song, name)
    -- start a new part with the given name. writes the old part into the part table
    -- and clears the current section
    
    add_section(song, 1) -- add any left over section    
    song.context.part_map[song.context.current_part] = song.context.pattern_map
    song.context.pattern_map = {}
    song.context.current_part = name
    song.context.in_variant = nil
    song.opus = {}
    reset_timing(song)    
end


-- variant tag
local variant_tag = 0

local __copy_table = {}

function copy_if_needed(obj)
    -- return the given object if it's the first
    -- time we've tried to copy it; else return a copy
    if __copy_table[obj] then return copy_table(obj) end
    __copy_table[obj] = true
    return obj
end

function append_with_copy(a, b)
    -- appends b to a, copy elements of a as it does so (if needed)   
    local j=#a+1
    for i=1,#b do
        a[j] = copy_if_needed(b[i])
        j = j + 1
    end
end

function start_variant_part(song, bar)
    -- start a variant part. The variant specifier indicates the ranges that 
    -- this variant will apply to.
    -- Enters a part called (current_part).N where N is each range this part applies to
    -- and registers the sub-part in the variants table
    
    -- parse the variant list
    local endings = bar.variant_range
    
    -- if we are not already in a variant, record the arent part
    if not song.in_variant_part then
        song.context.parent_part = song.context.current_part
        song.in_variant_part = true
    end
        
    -- generate new ID for this tag
    local part_tag = song.context.parent_part .. '.' .. variant_tag
    start_new_part(song, part_tag)
    variant_tag = variant_tag + 1
    
    -- fill in the variants in the parent part map
    if not song.context.part_map[song.context.parent_part].variants then 
            song.context.part_map[song.context.parent_part].variants = {}
    end
            
    for i,v in ipairs(endings) do        
        song.context.part_map[song.context.parent_part].variants[v] = part_tag
    end
                
    
    
end

function expand_patterns(patterns)
    -- expand a pattern list table into a single event stream
    local result = {}
    for i,v in ipairs(patterns) do
        
        for i=1,v.repeats do
            -- repeated measures (including single repeats!)                            
            append_with_copy(result, v.section)            
            -- append variant endings
            if #v.variants>=i then                                
                append_with_copy(result, v.variants[i])
            end
        end
    end    
    return result        
end



function compose_parts(song)
    -- Compose each of the parts in the song into one single event stream
    -- using the parts indicator. If no parts indicator, just uses the default part
    -- Combines all repeats etc. inside each part into a stream as well
    -- The final stream is a fresh copy of all the events
        
    start_new_part(song, nil)
    
    local variant_counts = {}
    
    if song.context.part_sequence then                         
        song.stream = {}        
        for c in song.context.part_sequence:gmatch"." do            
            if song.context.part_map[c] then 
                local pattern = expand_patterns(song.context.part_map[c])
                append_with_copy(song.stream, pattern)
                
                -- count repetitions of this part
                if not variant_counts[c] then
                    variant_counts[c] = 1
                else
                    variant_counts[c] = variant_counts[c] + 1
                end
                
                -- expand the variants
                local vc = variant_counts[c]
                if song.context.part_map[c].variants and song.context.part_map[c].variants[vc] then
                    -- find the name of this variant ending
                    local variant_part_name = song.context.part_map[c].variants[vc]
                    pattern = expand_patterns(song.context.part_map[variant_part_name])
                    append_with_copy(song.stream, pattern)
                
                end            
            end
        end        
        
    else
        -- no parts indicator
        song.stream = expand_patterns(song.context.part_map['default'])
    end
    
end






    




--
-- From source file: lyrics.lua
--
-- functions for dealing with lyrics 

function parse_lyrics(lyrics)
    -- Parse a lyric definition string
    -- Returns a table containing a sequence of syllables and advance field
    -- each advance field specifies how far to move for the next syllable
    -- either an integer number of notes, or "bar" to wait until the next bar
    -- e.g. 'he-llo wo-rld_ oh~yes | a test___' becomes
    -- { 
    -- {syllable='he', advance=1}
    -- {syllable='llo', advance=1}
    -- {syllable='wo', advance=1}
    -- {syllable='rld', advance=2}
    -- {syllable='oh yes', advance='bar'}
    -- {syllable='a', advance=1}
    -- {syllable='test', advance=4}    
    -- }
    
    -- make escaped dashes into backquotes
    lyrics = lyrics:gsub('\\\\-', '`')
    lyrics = rtrim(lyrics)
    local lyrics_pattern = [[
    lyrics <- ( %s* (({:syl: <syllable> / '-' :} ? {:br: <break> :}) -> {} *)  {:syl: (<syllable>)  :} -> {} %s*) -> {}
    break <- ( ( %s +)  / ('-')  )
    
    syllable <- ( ([^%s-] +) )        
    ]]
    
    
    local match = re.match(lyrics, lyrics_pattern)
    -- empty lyric pattern
    if not match then
        return {}
    end
    
    local lyric_sequence = {}
    local note_count
    local advance
    local next_advance = 1 -- always start on first note of the song
    
    -- construct the syllable sequence
    for i,syllable in ipairs(match) do
        
        local syl = syllable.syl        
        
        -- fix backquotes
        syl = syl:gsub('`', '-')
        -- note advance on trailing underscore
        note_count = 1
        for c in syl:gmatch"_" do
            note_count = note_count + 1
        end
        
        -- bar advance
        if string.sub(syl,-1)=='|' then
            advance = 'bar'
        else
            advance = note_count
        end        
        -- remove _, ~ and | from the display syllables
        syl = syl:gsub('|', '')        
        syl = syl:gsub('_', '')        
        syl = syl:gsub('~', ' ')        
        
        table.insert(lyric_sequence, {syllable=syl, advance=next_advance, br=syllable.br})        
        next_advance = advance
    end
    return lyric_sequence
end

-- expand lyrics so it is a sequence of spacers, without counts etc.
function expand_lyrics(lyrics)
    local expanded = {}
    for i,v in ipairs(lyrics) do
    
        if tonumber(v.advance) then
            for j=1,tonumber(v.advance-1) do
                table.insert(expanded, {syllable=nil, advance='note'})
            end
            table.insert(expanded, {syllable=v.syllable, advance='note'})
        end
        -- split bar advances into a bar followed by a note
        if v.advance=='bar' then
            table.insert(expanded, {syllable=nil, advance='bar'})
            table.insert(expanded, {syllable=v.syllable, advance='note'})
        end
    end
    return expanded
end

function merge_lyrics(tokens)
    -- Merge a lyrics in a token stream in place.    
        
    local token_ptr = 1     -- index of the current position at which we look for notes to align to
    local last_lyric_index -- index of the last symbol_line token in the stream (use this to check for stacked symbol lines)
    local last_ptr          -- the token_ptr used by the previous symbol_line definition (so we can jump back)
    
    -- move along to the next matching token in the stream
    -- we call this every time we see a symbol in a symbol line
    local function advance_token_ptr(sym)
        while token_ptr<=#tokens do
            local t = tokens[token_ptr].token
            token_ptr = token_ptr + 1
            -- if we match, return the matching token
            if t==sym.advance then return tokens[token_ptr-1] end                    
        end
        return nil -- ran over end of the token list
    end
            
    -- run through all lyrics
    for ix,token in ipairs(tokens) do                       
        
        if token.token=='words' then                
            local lyrics = expand_lyrics(token.lyrics or {})
            -- deal with stacked lyrics.
            if last_lyric_index==ix-1 then
                -- last token was also a lyric_line; this is te
                -- second, third,... nth line of a stack
                token_ptr = last_ptr                
            else
                -- this is not a stack, or is the first line, so remember
                -- the alignment position
                last_ptr = token_ptr 
            end
           
            -- run through each lyric
            for i,v in ipairs(lyrics) do              
                token = advance_token_ptr(v)           
                -- attach decorations and text to notes
                if token and token.token=='note' then
                    token.note = copy_table(token.note)
                    local syl = v.syllable
                    if syl and syl~='*' and syl~='-' then add_lyric_note(token.note, syl) end
                end                
            end 
            last_lyric_index = ix
            -- advance the pointer to this lyric line
            if token_ptr<ix then token_ptr=ix end             
        end
    end    
end


function insert_lyrics(stream)
    -- Takes a lyrics structure and an event stream, and inserts the lyric
    -- events into the stream accordingly. Returns a new event stream
    -- with the lyrics in place. 
    local v
    local new_stream = {}
    
    for i=1,#stream  do
        v = stream[i]
        if v.event=='note' then
            if v.note.lyrics then
                -- create an index if there is not already one
                v.note.lyrics.index = (v.note.lyrics.index or 0) + 1
                -- insert new lyric
                local lyric = v.note.lyrics[v.note.lyrics.index]
               
                -- must check if there _is_ actually a lyric for this repeat
                if lyric then
                    new_stream[#new_stream+1] = {event='lyric', syllable=lyric}
                end
            end
        end
        new_stream[#new_stream+1] = v
    end
    return new_stream
end



--
-- From source file: chords.lua
--
-- Chord handling functions
local chords = 
{
["+2"] = { 0, 2, },
["+3"] = { 0, 4, },
["+4"] = { 0, 6, },
["+b3"] = { 0, 3, },
["5"] = { 0, 7, },
["b5"] = { 0, 6, },
["6sus4(-5)"] = { 0, 6, 9, },
["aug"] = { 0, 4, 8, },
["dim"] = { 0, 3, 6, },
["dim5"] = { 0, 4, 6, },
["maj"] = { 0, 4, 7, },
["min"] = { 0, 3, 7, },
["m"] = { 0, 3, 7, },
["sus2"] = { 0, 2, 7, },
["sus2sus4(-5)"] = { 0, 2, 6, },
["sus4"] = { 0, 6, 7, },
["6"] = { 0, 4, 7, 9, },
["6sus2"] = { 0, 2, 7, 9, },
["6sus4"] = { 0, 6, 7, 9, },
["7"] = { 0, 4, 7, 10, },
["7#5"] = { 0, 4, 8, 10, },
["7b5"] = { 0, 4, 6, 10, },
["7sus2"] = { 0, 2, 7, 10, },
["7sus4"] = { 0, 6, 7, 10, },
["add2"] = { 0, 2, 4, 7, },
["add4"] = { 0, 4, 6, 7, },
["add9"] = { 0, 4, 7, 14, },
["dim7"] = { 0, 3, 6, 9, },
["dim7susb13"] = { 0, 3, 9, 20, },
["madd2"] = { 0, 2, 3, 7, },
["madd4"] = { 0, 3, 6, 7, },
["madd9"] = { 0, 3, 7, 14, },
["mmaj7"] = { 0, 3, 7, 11, },
["m6"] = { 0, 3, 7, 9, },
["m7"] = { 0, 3, 7, 10, },
["m7#5"] = { 0, 3, 8, 10, },
["m7b5"] = { 0, 3, 6, 10, },
["minadd2"] = { 0, 2, 3, 7, },
["minadd4"] = { 0, 3, 6, 7, },
["minadd9"] = { 0, 3, 7, 14, },
["minmaj7"] = { 0, 3, 7, 11, },
["min6"] = { 0, 3, 7, 9, },
["min7"] = { 0, 3, 7, 10, },
["min7#5"] = { 0, 3, 8, 10, },
["min7b5"] = { 0, 3, 6, 10, },
["maj7"] = { 0, 4, 7, 11, },
["maj7#5"] = { 0, 4, 8, 11, },
["maj7b5"] = { 0, 4, 6, 11, },
["maj7sus2"] = { 0, 2, 7, 11, },
["maj7sus4"] = { 0, 6, 7, 11, },
["sus2sus4"] = { 0, 2, 6, 7, },
["6/7"] = { 0, 4, 7, 9, 10, },
["6add9"] = { 0, 4, 7, 9, 14, },
["7s5b9"] = { 0, 4, 8, 10, 13, },
["7s9"] = { 0, 4, 7, 10, 15, },
["7s9b5"] = { 0, 4, 6, 10, 15, },
["7/11"] = { 0, 4, 7, 10, 18, },
["7/13"] = { 0, 4, 7, 10, 21, },
["7add4"] = { 0, 4, 6, 7, 10, },
["7b9"] = { 0, 4, 7, 10, 13, },
["7b9b5"] = { 0, 4, 6, 10, 13, },
["7sus4/13"] = { 0, 6, 7, 10, 21, },
["9"] = { 0, 4, 7, 10, 14, },
["dim9"] = { 0, 3, 6, 9, 13},
["9s5"] = { 0, 4, 8, 10, 14, },
["9b5"] = { 0, 4, 6, 10, 14, },
["9sus4"] = { 0, 7, 10, 14, 18, },
["m maj9"] = { 0, 3, 7, 11, 14, },
["mmaj9"] = { 0, 3, 7, 11, 14, },
["m6/7"] = { 0, 3, 7, 9, 10, },
["m6/9"] = { 0, 3, 7, 9, 14, },
["m7/11"] = { 0, 3, 7, 10, 18, },
["m7add4"] = { 0, 3, 6, 7, 10, },
["m9"] = { 0, 3, 7, 10, 14, },
["m9/11"] = { 0, 3, 10, 14, 18, },
["m9b5"] = { 0, 3, 6, 10, 14, },
["min maj9"] = { 0, 3, 7, 11, 14, },
["minmaj9"] = { 0, 3, 7, 11, 14, },
["min6/7"] = { 0, 3, 7, 9, 10, },
["min6/9"] = { 0, 3, 7, 9, 14, },
["min7/11"] = { 0, 3, 7, 10, 18, },
["min7add4"] = { 0, 3, 6, 7, 10, },
["min9"] = { 0, 3, 7, 10, 14, },
["min9/11"] = { 0, 3, 10, 14, 18, },
["min9b5"] = { 0, 3, 6, 10, 14, },
["maj6/7"] = { 0, 4, 7, 9, 11, },
["maj7/11"] = { 0, 4, 7, 11, 18, },
["maj7/13"] = { 0, 4, 7, 11, 21, },
["maj9"] = { 0, 4, 7, 11, 14, },
["maj9s5"] = { 0, 4, 8, 11, 14, },
}

    
function apply_inversion(inversion, root, chord_offsets)
    -- apply the inversion
    local notes = {}    
    
    local base_pitch = get_note_number(root)
    if inversion then 
        -- numerical inversion
        if tonumber(inversion) then
            if inversion < #chord_offsets then 
                inversion = (chord_offsets[tonumber(inversion)+1]+base_pitch) % 12
            else
                inversion = nil -- not a real inversion
            end
            
        else
            -- note name inversion
            inversion = get_note_number(inversion) 
        end
    end
   
    for i,v in ipairs(chord_offsets) do
        -- if inversion, shift the note to the octave below
        if inversion and inversion==(v+base_pitch) % 12 then
             table.insert(notes, v+base_pitch-12)
             inversion = nil -- clear the inversion field so we don't re-add the note
        else               
            table.insert(notes, v+base_pitch)
        end        
    end
    
    -- an inversion which was not in the chord itself
    -- (e.g. Cmaj/F)
    if inversion then
        table.insert(notes, inversion-12)
    end
    return notes
end

local chord_matcher = re.compile([[
        chord <- ({:root: root :} ({:type: [^/%s] +:}) ? ('/' {:inversion: (<root>/[1-3]) :}) ?) -> {}
        root <- (([a-g] ('b' / '#') ?) / (<numeral>))
        numeral <- ('iii' / 'ii' / 'iv' / 'vii' / 'vi' / 'v' / 'i') 
    ]])
    
function parse_chord(chord)
    -- Matches chord definitions, returning the root note
    -- the chord type, and the inversion
    -- convert sharp signs to s and lowercase
    
    chord = string.lower(chord)
    
    local match = chord_matcher:match(chord)
    if not match or not match.root then
        return nil
    end    
    
    match.root = match.root:gsub('#', 's')
  
    local inversion        
    -- get inversion pitch
    if match.inversion then 
        if tonumber(match.inversion) then       
            inversion = tonumber(match.inversion)
        else
            inversion = canonical_note_name(get_note_number(match.inversion))
        end       
    end
   
    return {chord_type=match.type or 'maj', root=match.root,inversion=inversion, original_type=match.type}   
end

local numerals = {iii=3, ii=2, i=1, iv=4, v=5, vi=6, vii=7}

function get_chord_notes(chord, custom_table, key)
    -- get the notes in a chord
     local chord_type
     local root, tonic
     local base_pitch
     local semis
     -- deal with numeral chords
     if numerals[chord.root] then 
        -- work out which root note this is
        tonic = numerals[chord.root]
        semis = key_semitones(key)        
        root = canonical_note_name(semis[tonic])
        
        
        -- decide whether major or minor
        if tonic == 2 or tonic==3 or tonic==6 then            
            chord_type = chord.original_type or 'min'
            if chord_type=='7' then chord_type='m7' end
            if chord_type=='9' then chord_type='m9' end
            
        elseif tonic == 7  then
            chord_type = chord.original_type or 'dim'
            if chord_type=='7' then chord_type='dim7' end
            if chord_type=='9' then chord_type='dim9' end
         
        else
            chord_type = chord.original_type or 'maj' 
        end
     else
        -- not a numeral chord
        root = chord.root
        chord_type = chord.original_type or 'maj' -- default to major chord    
     end
    
     local chord_form = custom_table[chord_type] or chords[chord_type]
     -- empty chord if we can't play it
     if not chord_form then return nil end
     local notes = apply_inversion(chord.inversion, root, chord_form)       
     return notes
end


function transpose_chord(chord, shift)
    -- return a transposed chord name given a string and an integer offset
    -- e.g. transpose_chord('Cm', 4) returns 'Em'     
    
      chord.root = transpose_note_name(chord.root, shift)
      -- need to transpose inversions as well
      if chord.inversion then
            chord.inversion = transpose_note_name(chord.inversion, shift)   
      end 
      return chord            
end

function is_chord(str)
    -- Return true if this string is a valid chord identifier
    if parse_chord(str) then
        return true
    else
        return false
    end
end



function voice_chord(notes, octave)
    -- Takes a note sequence for a chord and expands the chord across several octaves
    -- Returns a MIDI note number set
    local octave = octave or 5
    
    local base = octave * 12
    
    local out_notes = {}    

    -- make sure root is in first position
    -- (may not be if chord is inverted)
    table.sort(notes)
    
    -- add original notes
    for i,v in ipairs(notes) do 
        table.insert(out_notes, v+base)
    end
    
    -- root at octave above and below
    local root = notes[1]
    table.insert(out_notes, root+base-12)
    table.insert(out_notes, root+base+12)
    
    -- -- fifth at octave above
    -- if #notes>=3 then
        -- fifth = notes[3]
        -- table.insert(out_notes, fifth+base+12)
    -- end
    
    return out_notes
    
end


function test_chords()
    
    local test_chords = {'Gm', 'G', 'F#min7', 'dM9', 'bbmin', 'Dmin/F', 'Cmaj/E', 'Cmaj/F'}
    for i,v in ipairs(test_chords) do
        print(v)
        table_print(voice_chord(create_chord(v), 5))
        print()
    end   
end




--
-- From source file: stream.lua
--
-- Functions from transforming an raw stream into a timed event stream

function time_stream(stream)
    -- take a stream of events and insert time indicators (in microseconds)
    -- as the t field in each event
    -- Time advances only on notes or rests
    
    local t 
    local in_chord = false
    local max_duration, max_metric
    local measure = 1
    local written_measure = 1
    t = 0    
    local last_bar = 0    
    local event
    local metric_t = 1
    local event_type
    for i=1,#stream do
        event = stream[i]
        event_type = event.event
        event.t = t
        event.metric_t = metric_t
        
        -- record position of last bar
        if event_type=='bar'  then
            last_bar = event.t
            measure = measure + 1
            written_measure = event.bar.meeasure
            event.bar.play_measure = measure
            metric_t = measure
        end
                
        -- now, if we get an overlay, jump time
        -- back to the start of that bar
        if event_type=='overlay' then
            t = last_bar
        end
        
        local duration = 0
        -- rests and notes
        if event_type=='rest' or event_type=='note' then
            duration = event.note.play_duration
            if not in_chord then
                t = t + duration
                metric_t = metric_t + event.note.play_bars
            else
                -- record maximum time in chord; this is how much we will advance by
                if duration > max_duration then
                    max_duration = duration
                    max_metric = event.note.play_bars
                end
            end                                    
        end
        event.duration = duration                
        
        -- chord symbols       
        -- chord starts; stop advancing time
        if event_type=='chord_begin' then
            in_chord = true
            max_duration = 0
            max_metric = 0
        end
        
        if event_type=='chord_end' then
            in_chord = false
            t = t + max_duration -- advance by longest note in chord
            metric_t = measure + max_metric
        end
       
    end
    
    -- make sure events are in order
    --table.sort(stream, function(a,b) return a.t<b.t end)
    
end

function get_note_stream(timed_stream, channel)
    -- Extract all play events from a timed stream, as sequence of note on / note off events
    -- take into account ties in computing note offs
    
   local out = {}
   local notes_on = {}
   
   local channel = channel or 1
   for i,event in ipairs(timed_stream) do        
            if event.event=='note' then      
                
                if not notes_on[event.note.play_pitch] then 
                    table.insert(out, {event='note_on', t=event.t, pitch=event.note.play_pitch, channel=channel})
                    notes_on[event.note.play_pitch] = true
                end
                
                -- don't insert a note off if the note is tied
                if not event.note.tie then                    
                    table.insert(out, {event='note_off', t=event.t+event.duration-1, pitch=event.note.play_pitch, channel=channel})                                    
                    notes_on[event.note.play_pitch] = false
                end          
            end
    end
    return out
end


function print_notes(stream)
    -- print out the notes, as a sequence of pitches
    local notes = {}
    
    for i,event in ipairs(stream) do        
        if event.event == 'note' then                      
           table.insert(notes, event.note.pitch.note)
        end
        if event.event == 'rest' then
            table.insert(notes, '~')
        end
        if event.event == 'bar' then
            table.insert(notes, '|')
        end
        if event.event == 'split_line' then
            table.insert(notes, '\n')
        end
    end
    
    print(table.concat(notes))
    
end




function print_lyrics_notes(stream)
    -- print out the notes and lyrics, as a sequence of pitches interleaved with 
    -- syllables
    local notes = {}
    
    for i,event in ipairs(stream) do        
    
        if event.event == 'lyric' then                      
           table.insert(notes, ' "'..event.syllable..'" ')
        end
    
        if event.event == 'note' then                      
           table.insert(notes, event.note.pitch.note)
        end
        if event.event == 'rest' then
            table.insert(notes, '~')
        end
        if event.event == 'bar' then
            table.insert(notes, '|')
        end
        if event.event == 'split_line' then
            table.insert(notes, '\n')
        end
    end
    
    print(table.concat(notes))
    
end



function filter_event_stream(stream, includes)
    -- return a copy of the stream, keeping only those specified events in the stream
    local filtered = {}
    
    if #stream=={} then
        return {}
    end
    
    if type(includes)=='string' then        
        for i,v in ipairs(stream) do
            if v.event==includes then
                table.insert(filtered, v)            
            end
        end       
    end
    
    if type(includes)=='table' then        
        for i,v in ipairs(stream) do
            for j,n in ipairs(includes) do 
                if v.event==n then
                table.insert(filtered, v)            
                end
            end
        end       
    end    
    return filtered   
end

function duration_stream(stream)
    -- return the duration of the stream, from the first event, to
    -- the end of the last note
    if #stream==0 then
        return 0
    end
    
    local end_time = stream[#stream].t
    -- must add on duration to avoid chopping last note
    if stream[#stream].duration then
        end_time = end_time + stream[#stream].duration
    end
    return end_time
end

function start_time_stream(stream)
    -- return the time of the first event
    if #stream==0 then
        return 0
    end    
    return stream[1].t
end

function zero_time_stream(stream)
    -- fix the time of the first element of the stream to t=0, and shift
    -- the rest of the stream to match
    -- Modifies the stream in place -- copy it if you don't want to modify the 
    -- original data
    if #stream=={} then
        return {}
    end
    
    local t = stream[1].t
    for i,v in ipairs(stream) do
        stream.t = stream.t - t
    end    
end




function render_grace_notes(stream)
    -- Return a the stream with grace notes rendered in 
    -- as ordinary notes. These notes will cut into the following note 
    local out = {}
    for i,v in ipairs(stream) do
        if v.event=='note' and v.note.grace then        
            local sequence = v.note.grace.sequence            
            local duration = 0 -- total duration of the grace notes
            for j,n in ipairs(sequence) do                    
                local grace_duration = n.play_duration/4
                table.insert(out, {event='note', t=duration+v.t, duration=grace_duration, note=n})
                duration = duration + grace_duration
            end            
            
            -- cut into the time of the next note, and push it along
            local cut_note = v
            cut_note.duration = cut_note.duration - duration
            
            -- if we manage to cut the note completely then make sure
            -- it doesn't have negative duration
            if cut_note.duration <= 0 then                
                cut_note.duration = 1                
            end
            cut_note.t = cut_note.t + duration
            table.insert(out, cut_note) 
        else
            table.insert(out, v)
        end
    end    
    return out
end


function trim_event_stream(stream,  mode, start_time, end_time)
    -- return a copy of the stream, including only events that fall inside
    -- [start_time:end_time] (given in microseconds)
    -- mode can be = 'starts' which returns event that start in the given period
    --               'ends' which returns events that end in the given period
    --               'any' which returns events that overlap the period at all
    --               'within' which returns that are wholly in the period
    --               'trim' which is like any, but trims notes to fit the given time
    -- start_time and end_time are optional (default to start and end of the tune)   
    
    if #stream=={} then
        return {}
    end
    
    local filtered = {}
    start_time = start_time or nil
    end_time = end_time or duration_stream(stream)         
    
    
    for i,v in ipairs(stream) do
        local start_t = v.t
        local end_t = v.t
        
        -- notes and rests occupy time
        if v.event == 'note' or v.event=='rest' then
            end_t = v.t + v.duration
        end
        
        -- work out if this event starts or stops in this interval
        local start_in = (start_t>=start_time and  start_t<=end_time) 
        local end_in = (end_t>=start_time and end_t<=end_time)
        
        if mode=='any' then
            if start_in or end_in  then
                table.insert(filtered, v)
            end
        end
        
        if mode=='starts' then
            if start_in then
                table.insert(filtered, v)
            end
        end
        
        if mode=='ends' then
            if end_in then
                table.insert(filtered, v)
            end
        end
        
        if mode=='within' then
            if start_in and end_in then
                table.insert(filtered, v)
            end
        end
        
        if mode == 'trim' then
             if start_in or end_in  then
                -- must copy event to avoid changing the original
                local event = deepcopy(v)
                
                -- starts, but is too long
                if start_in and not end_in then
                    event.duration = end_time - event.t
                end
                
                -- starts before, but ends in
                if end_in and not start_in then
                    event.duration = (event.t+event.duration)-start_time
                    event.t = start_time                    
                end
                table.insert(filtered, event)
             end
        end
        
    end
    
    return filtered
end
    

function transpose_stream(stream, semitones)
    -- Transpose events in the stream (only changes the numerical pitch field
    -- see diatonic_transpose() to transpose a token stream with note renaming etc.)
    for i,v in ipairs(stream) do
        if v.event=='note' then 
            v.pitch = v.pitch + semitones
        end
    end    
end
    
    

function time_stretch_stream(stream, factor)
    -- Change the playback rate of the stream (only changes the numerical duration field)
    -- and then retimes
    for i,v in ipairs(stream) do    
        if v.event.duration  then 
            v.duration = v.duration * factor
        end
    end    
    time_stream(stream)
end

function note_stream_to_opus(note_stream)
    -- make sure events are in time order
    table.sort(note_stream, function(a,b) return a.t<b.t end)
    
    local last_t = 0
    local score = {}    
    local dtime
    for i,event in ipairs(note_stream) do
        dtime = (event.t - last_t)/1000.0 -- microseconds to milliseconds
        table.insert(score, {event.event, dtime, event.channel or 1, event.pitch, event.velocity or 127})
        last_t = event.t
    end
    return score
end



function get_chord_stream(stream, octave)
    -- extract all the named chords from a stream (e.g. "Cm7" or "Dmaj") and write 
    -- them in as note events in a stream
   local out = {}
   local notes_on = {}
   local t
   local channel = channel or 1
   octave = octave or 5
   local notes
   
   for i,event in ipairs(stream) do        
        
        if (event.event=='note' and event.note.chord) or event.event=='chord' then                
            local chord = event.note.chord or event.chord
            
            t = event.t
            -- turn off last chord!
            for j, n in ipairs(notes_on) do
                table.insert(out, {event='note_off', t=t, channel})                                           
                notes_on = {}
            end
            
            -- get the notes for this chord and put them in the sequence
            notes = voice_chord(get_chord_notes(chord), octave)
            for j, n in ipairs(notes) do
                 table.insert(out, {event='note_on', t=t, pitch=n, channel})                           
                 notes_on[n] = true
            end                    
        end
    end
    
    -- turn off last chord
    for j, n in ipairs(notes_on) do
            table.insert(out, {event='note_off', t=t, channel=channel})                                           
            notes_on = {}
    end            
    
    return out 
end


function merge_streams(streams)
    -- merge a list of streams into one single, ordered stream
    local merged_stream = {}
    
    for i,v in pairs(streams) do
        append_table(merged_stream, v)         
    end    
    table.sort(merged_stream, function(a,b) return a.t<b.t end)
    return merged_stream    
end

-- sort out stream functions

function stream_to_opus(stream,  patch)
    -- return the opus form of a single note stream song, with millisecond timing        
    patch = patch or 41 -- default to violin
    local channel = 0
    local note_stream = get_note_stream(stream, channel)
    
     local score = {
        1000,  -- ticks per beat
        {    -- first track
            {'set_tempo', 0, 1000000},
            {'patch_change', 0, channel, patch},            
        },  
     }     
    append_table(score[2], note_stream_to_opus(note_stream))
    return score  
end


function song_to_opus(song, patches)
    -- return the opus form of all the voices song, with millisecond timing
    -- one channel per voice
    
    
    patches = patches or {}
    local channel = 0    
    local merged_stream = {}
    local score = {1000,
        {    
            {'set_tempo', 0, 1000000},     
           {'patch_change', 0,1,1},     
             
        },          
    }    
    -- set the patch for each channel
    local j = 0
    for i,v in pairs(song.voices) do
        if patches[i] then
            table.insert(score[2], {'patch_change', 0, i, patches[i]})
        else
            table.insert(score[2], {'patch_change', 0, j, 1})
        end
        j = j + 1
    end
    
    
    -- merge in each voice
    for i,v in pairs(song.voices) do        
        append_table(merged_stream, get_note_stream(v.stream, channel))         
        channel = channel + 1        
    end
        
   append_table(score[2], note_stream_to_opus(merged_stream))
   
 
   return score
end


function make_midi_from_stream(stream, fname)
    -- Turn a note stream into a MIDI file
     local MIDI = require 'MIDI'

     local opus = stream_to_opus(stream)
     local midifile = assert(io.open(fname,'wb'))
     midifile:write(MIDI.opus2midi(opus))
     midifile:close()
end

function make_midi(song, fname)
    -- make a midi file from a song
    -- merge all of the voices into a single event stream
    local MIDI = require 'MIDI'
    local opus = song_to_opus(song)
    
    local midifile = assert(io.open(fname,'wb'))
    midifile:write(MIDI.opus2midi(opus))
    midifile:close()    
end




--
-- From source file: macro.lua
--
-- subsitution macro handling

-- tables for shifting notes (diatonically)
local transpose_notes = { 
    'C,,', 'D,,', 'E,,', 'F,,', 'G,,', 'A,,', 'B,,',
    'C,', 'D,', 'E,', 'F,', 'G,', 'A,', 'B,',
    'C', 'D', 'E', 'F', 'G', 'A', 'B',
     'c', 'd', 'e', 'f', 'g', 'a', 'b',
     "c'", "d'", "e'", "f'", "g'", "a'", "b'",
     "c''", "d''", "e''", "f''", "g''", "a''", "b''"    
    }
    
local transpose_note_lookup = invert_table(transpose_notes)

function transpose_note(note, offset)
    -- transpose a note (a-g A-G) by the given number of (diatonic) steps
    -- e.g. transpose_note('a', 1) = 'b'
    --      transpose_note('g', 3) = 'c''
    --      transpose_note('E', -1) = 'D'
    
    return transpose_notes[transpose_note_lookup[note]+offset]
end

function transpose_macro(lhs, note, rhs)
    -- create the macro expansion for lhs -> rhs
-- replace n in lhs with note
-- and any letters h..z in rhs with relatively offset pitches

    local lhs = lhs:gsub('n', note)
    local rhs = rhs:gsub('([h-zH-Z])', function (s)
    -- only allow lowercase values
    s = string.lower(s)
    relative = string.byte(s) - string.byte('n')
    return transpose_note(note, relative)
    end)
    return {lhs=lhs, rhs=rhs}
end


function apply_macros(macros, line)
    -- expand macros in the line
    for i,v in ipairs(macros) do
        line = line:gsub(v.lhs, v.rhs)
    end
    return line
end
    
local macro_matcher = re.compile([[
    macro <- (%s * ({:lhs: [^=%s] + :}) %s * '=' %s * ({:rhs: ([^%nl] *) :})) -> {} 
    ]])
    
function parse_macro(macro)
    -- take a raw ABC string block and expand any macros defined it
    -- expansion takes place *before* any other parsing
    local match = macro_matcher:match(macro) 
    return match
    
end



--
-- From source file: directives.lua
--
-- functions for handling custom directives

-- table maps directive names to functions
-- each function takes two arguments: the song structure, and an argument list from
-- the directive (as a table)
local directive_table = {}


function apply_directive(song, directive, arguments)
    -- Apply a directive; look it up in the directive table,
    -- and if there is a match, execute it    
    if directive_table[directive] then        
        directive_table[directive].fn(song, directive, arguments, directive_table[directive].user)
    end
    
    -- record all directives in the context
    if song.context then
       song.context.directives[directive] = song.context.directives[directive] or {}
       table.insert(song.context.directives[directive], arguments)
    end

end

function register_directive(directive, fn, parse, user)
    -- Register a user directive. Will call fn(song, directive, arguments) when
    -- the given directive is found. If parse is true, this directive is executed at parse time
    -- (e.g. to insert new tokens into the stream)    
    -- user can represent user data to be passed to the function on execution
        directive_table[directive] = {fn=fn, parse=parse, user=user}    
    
end

function inject_tokens(song, tokens)
    -- insert tokens immediately after current point
    for i,v in ipairs(tokens) do
        table.insert(song.token_stream, v)
    end
end


function inject_events(song, events)
    -- add events to the opus (to be called from directives)
    for i,v in ipairs(events) do
        table.insert(song.opus, v)
    end
end

function parse_directive(directive)
    -- parse a directive into a directive, followed by sequence of space separated directives
    -- returns true if this directive must be executed at parse time (e.g. abc-include)
    local directive_pattern = [[
    directives <- (%s * ({:directive: %S+ :} ) %s+ ?  {:arguments: ( ({%S+} %s +) * {%S+}  )? -> {}  :} )  -> {}
    ]]
    
    local match = re.match(directive, directive_pattern)
  
    if match and directive_table[match.directive] and directive_table[match.directive].parse then       
        return true, match
    else
        return false, match
    end
    
end



--
-- From source file: fields.lua
--
-- Routines for parsing metadata in headers and inline inside songs

-- create the various pattern matchers



local field_tags = {key = 'K'
,title = 'T'
,ref =  'X'
,area =  'A'
,book =  'B'
,composer =  'C'
,discography =   'D'
,extended = 'E'
,file =   'F'
,group =   'G'
,history =   'H'
,instruction =   'I'
,length =   'L'
,meter =   'M'
,macro =   'm'
,notes =   'N'
,origin =   'O'
,parts =   'P'
,tempo =   'Q'
,rhythm =   'R'
,remark =  'r'
,source =   'S'
,symbol_line =   's'
,user =   'U'
,voice =   'V'
,words =  'w'
,end_words =  'W'
,transcriber =  'Z'
,continuation =  '+'
}

local field_names = invert_table(field_tags)

local parts_matcher = re.compile(
[[
    parts <- (part +) -> {}
    part <- ( ({element}  / ( '(' part + ')' ) )  {:repeat: [0-9]* :}) -> {}    
    element <- [A-Za-z]    
    ]])
    
function parse_parts(m)
    -- Parse a parts definition that specifies the parts to be played
    -- including any repeats
    -- Returns a fully expanded part list
    
    local captures = parts_matcher:match(m)
    
    return captures
    
end


local voice_matcher = re.compile([[
    voice <- (({:id: [%S]+ :}) %s * {:specifiers: (<specifier> *) -> {} :}) -> {}
    specifier <- (%s * {:lhs: ([^=] +) :} + '=' {:rhs: [^%s]* :}) -> {} 
    ]])

function parse_voice(voice)
    -- Parse a voice definition string
    -- Voices of the form V:ID [specifier] [specifier] ...
    -- Returns a table with an ID and a table as used for keys
    -- e.g. V:tenor becomes {id="tenor"}
    
    local parsed_voice = voice_matcher:match(voice)
    return parsed_voice
end



function expand_parts(parts)
    -- Recurisvely expand a parts table into a string
    -- Input is a table with entries which are either an array of tables or
    -- a table with entries [1] = terminal, repeat = repeat count
    local reps = parts['repeat']
    local r
    if not reps or reps=='' then
        r = 1
    else
        r = reps + 0
    end
   
    local sym = ''
    local    t=''
    local i,v
    for i,v in ipairs(parts) do
    
        -- terminal symbol
        if type (v) == "string" then
            t =  t..v
        else
            -- recursive part (i.e. a nested group)
            t = t..expand_parts(v)
        end
    end
    
    -- repeat whatever we got as many times as required
    for i = 1, r do
            sym = sym .. t
    end
       
    return sym
end


function text_token(content, song, field_name)      
    return  {token='field_text', name=field_name, content=content} 
end

function key_token(content, song)
     song.parse.found_key = true -- key marks the end of the header
     return {token='key', key=parse_key(content)}     
end

function length_token(content, song)
        
        return {token='note_length', note_length=parse_length(content)}
end

function tempo_token(content, song)
    local tempo=parse_tempo(content)
    if tempo then
        return  {token='tempo', tempo=tempo}
    end
end

function words_token(content, song) 
        local lyrics = parse_lyrics(content)
        song.parse.last_lyrics = lyrics
        if lyrics then
            return {token='words', lyrics=lyrics}          
        end
end

function instruction_token(content, song)
     local parse_time, directive = parse_directive(content)
     -- + -- must execute parse time directives immediately
     if directive then
         if parse_time and not song.parse.no_expand then
            apply_directive(song, directive.directive, directive.arguments)
         else
            -- + -- otherwise defer
            return {token='instruction', directive=directive}           
         end
     end
end


function voice_token(content, song)    
    local voice = parse_voice(content)
    if voice then                
        ---- in the header this just sets up the voice properties
        if song.parse.in_header then
            return {token='voice_def', voice=voice}
        else
            return {token='voice_change', voice=parse_voice(content)}
        end
    end
end

function user_token(content, song)
    -- user macro for decorations etc.
    if song.parse.no_expand then
        return {token='field_text', name='user', content=content}                   
    else               
        local macro = parse_macro(content)
        if macro then
            -- allow macros to be cleared using !nil!
            if macro.rhs=='!nil!' then
                macro.rhs =nil
            end
            -- assign the macro
            song.parse.user_macros[macro.lhs] = macro.rhs
        end
    end      
end


function parts_token(content, song)
        ---- parts definition if we are still in the header
        ---- look up the parts and expand them out
        if song.parse.in_header then
            local parts = content:gsub('\\.', '') -- remove dots
            parts = parse_parts(content)
            if parts then
                return {token='parts', parts=parts}           
            end
        else            
            ---- otherwise we are starting a new part   
            ---- parts are always one character long, spaces and dots are ignored
            local part = content:gsub('%s', '')
            part = part:gsub('\\.', '')
            part = string.sub(part,1,1)
                        
            return {token='new_part', part=part}           
        end
    
end
    
function meter_token(content, song)    
    -- update meter   
    return {token='meter', meter=parse_meter(content)}              
end

function macro_token(content, song)
    if song.parse.no_expand then
        return {token='field_text', name='macro', content=content}                   
    else
        ---- we DON'T insert macros into the token_stream. Instead
        ---- we expand them as we find them
        local macro = parse_macro(content)
        
        ---- transposing macro
        if re.find(macro.lhs, "'n'") then
            local notes = {'a', 'b', 'c', 'd', 'e', 'f', 'g'}             
            local note                   
            ----- insert one macro for each possible note
            for i,v in ipairs(notes) do
                table.insert(song.parse.macros, transpose_macro(macro.lhs, v, macro.rhs)) 
                table.insert(song.parse.macros, transpose_macro(macro.lhs, string.upper(v), macro.rhs))                                                    
            end
        else
            ---- non-transposing macro
            table.insert(song.parse.macros, macro)
        end
    end    
end
    
function symbol_line_token(content, song)
    -- parse a symbol line    
    -- we may need to append to this later, if we get a continuation field
    song.parse.last_symbol_line = parse_symbol_line(content)
    return {token='symbol_line', symbol_line = song.parse.last_symbol_line}
end    
    
function continuation_token(content, song)
     local parsable = {'length', 'tempo', 'parts', 'meter', 'words', 'key', 'symbol_line', 'macro', 'user', 'voice', 'instruction'} -- those fields we parse individually    
     
     if song.parse.last_field then
        -- append plain text if necessary
        if not is_in(song.parse.last_field, parsable) then        
            return {token='append_field_text', name=song.parse.last_field, content=content}                
        end
         
         -- append lyrics
         if song.parse.last_field=='words' then
               -- we are guaranteed that song.parse.last_lyrics line is set
            local appended_lyrics = parse_lyrics(content)
            for i,v in ipairs(appended_lyrics) do
                table.insert(song.parse.last_lyrics, v)
            end 
         end
         
         -- append to a symbol line
         if song.parse.last_field=='symbol_line' then            
            -- we are guaranteed that song.parse.last_symbol line is set
            local appended_symbols = parse_symbol_line(content)
            for i,v in ipairs(appended_symbols) do
                table.insert(song.parse.last_symbol_line, v)
            end
         end
     end                 
end
        
 local field_fns = {key = key_token
,title = text_token
,ref =  text_token
,area =  text_token
,book =  text_token
,composer =  text_token
,discography = text_token
,extended = text_token
,file = text_token
,group =  text_token
,history = text_token
,instruction =   instruction_token
,length =   length_token
,meter =   meter_token
,macro =   macro_token
,notes =   text_token
,origin =  text_token
,parts =   parts_token
,tempo =   tempo_token
,rhythm =   text_token
,remark =  text_token
,source =   text_token
,symbol_line =   symbol_line_token
,user =   user_token
,voice =   voice_token
,words =  words_token
,end_words =  text_token
,transcriber =  text_token
,continuation =  continuation_token
}


function scan_metadata(str)
    -- quickly scan a string, and fill out the metadata fields
    local meta = {}
    local last_field         
    for i,line in ipairs(split(str, '\n')) do        
        local match, content = line:match('^([%a\\+]):([^]:[|]?.*)')        
        if match then
            field_name = field_names[match]            
            if field_name then                 
                if field_name=='continuation' and last_field then
                    -- continuation fields with +:
                    meta[field_name][#meta[field_name]] = meta[field_name][#meta[field_name]]..content
                else
                    -- standard fields
                    meta[field_name] = meta[field_name] or {}
                    table.insert(meta[field_name], content)
                    last_field = field_name
                end
            end            
        end        
     end
    return meta    
end

function parse_field(f, song, inline, at)
    -- parse a metadata field, of the form X: stuff
    -- (either as a line on its own, or as an inline [x:stuff] field
     local name, field, field_name
     local match, content = f:match('^([%a\\+]):([^]:[|]?.*)')
          
     -- not a metadata field at all
     if not match then
        -- in the header, treat lines without a tag as continuations
        if song.parse.in_header then
            field_name = 'continuation' 
            content = f                
        else
            -- otherwise it was probably a tune line
            return 
        end
     else
        field_name = field_names[match]
        if not field_name then return end -- unknown field
     end

    local token =  field_fns[field_name](content, song, field_name)
          
    if token then        
        if field_name~='continuation' then song.parse.last_field = field_name end        
        token.inline = inline
        token.is_field = true
        
    end
    
    return token
 
end




--
-- From source file: bar.lua
--
function parse_range_list(range_list)
    -- parses a range identifier
    -- as a comma separated list of numbers or ranges
    -- (e.g. "1", "1,2", "2-3", "1-3,5-6")
    -- Returns each value in this range
    
    local matches = range_list
    assert(#matches>0, "Range could not be parsed in bar variant.")
    
    local sequence = {}    
    local present = {}
    local j
    -- append each element of the range list
    for i,v in ipairs(matches) do
        -- single number
        if #v==1 then
            j = tonumber(v[1])
            if not present[j] then
                table.insert(sequence,j)
                present[j] = true -- avoid adding duplicates
            end
        end
        
        -- range of values
        if #v==2 then            
            for j=v[1]+0,v[2]+0 do
                if not present[j] then
                    table.insert(sequence, j)
                    present[j] = true  -- avoid adding duplicates
                end
            end
        end    
    end        
    
    table.sort(sequence) -- sort sequence
    return sequence
end


function parse_variant(variant, song)
    -- variant markers [range    
    variant.variant_range = parse_range_list(variant.variant_range)
    return variant
end

function parse_bar(bar, song)
-- Parse a bar symbol and repeat/variant markers. Bars can be
-- plain bars (|)
-- bars with thick lines (][)
-- repeat begin (|:)
-- repeat end (:|)
-- repeat middle (:||: or :: or :|:)
    
   local type_info = bar 
    
    -- compute number of colons around bar (which is the number of repeats of this section)
    if type_info.mid_repeat then
        type_info.end_reps = type_info.mid_repeat[2]-type_info.mid_repeat[1]
        type_info.start_reps = type_info.mid_repeat[4]-type_info.mid_repeat[3]
    
    
    elseif type_info.end_repeat then
        type_info.end_reps = type_info.end_repeat[2]-type_info.end_repeat[1]        
    
    
    -- thick bars work like repeats with a count of one
    elseif type_info.thickthin or type_info.thinthick or type_info.double then
        type_info.end_reps = 0
        type_info.end_repeat = true
    
    
    elseif type_info.start_repeat then
        type_info.start_reps = type_info.start_repeat[2]-type_info.start_repeat[1]        
           
    
    -- for a colon sequence, interpret :: as one start end repeat, :::: as two start, two end, etc.
    -- odd colon numbers without a bar symbol don't make sense!
    elseif type_info.just_colons then
        local colons = type_info.just_colons[2]-type_info.just_colons[1]
        assert(colons%2==0, "Bad number of colons in :: repeat bar.")
        type_info.start_reps = colons / 2
        type_info.end_reps = colons / 2
        type_info.mid_repeat = type_info.just_colons -- this is a mid repeat
        type_info.just_colons = nil
    end
    
    
    local bar_types = {'mid_repeat', 'end_repeat', 'start_repeat', 'variant',
    'plain', 'double', 'thickthin', 'thinthick'}
    
    local parsed_bar = {}
    
    -- set type field
    for i=1,#bar_types  do
        local v = bar_types[i]
        if type_info[v] then
            parsed_bar.type = v
        end
    end
    
    assert(parsed_bar.type, "Bar parsed incorrectly.")
    
    -- convert ranges into a list of integers
    if bar.variant_range then     
         parsed_bar.variant_range = parse_range_list(bar.variant_range)
    end
    
    parsed_bar.end_reps = type_info.end_reps
    parsed_bar.start_reps = type_info.start_reps
    
    
    return parsed_bar           
end




--
-- From source file: notes.lua
--
-- Functions for compiling notes in context (e.g. computing duration and pitch)

function compute_pitch(note, song)
    -- compute the real pitch (in MIDI notes) of a note event
    -- taking into account: 
    --  written pitch
    --  capitalisation
    --  octave modifier
    --  current key signature
    --  accidentals
    --  transpose and octave shift
    local context = song.context
    local pitch = note.pitch
    -- -1 indicates a rest note
    if note.rest or note.measure_rest or note.space then
        return nil
    end
    
    local accidental
    
    -- in K:none mode or propagate-accidentals is off, 
    -- accidentals don't persist until the end of the bar. 
    if context.key.none or context.propagate_accidentals=='not' then
        -- must specify accidental as there is no key mapping
        accidental = pitch.accidental or {num=0, den=0}
    else
        local accidental_key 
        -- in 'octave' mode, accidentals only propagate within an octave
        -- otherwise, they propagate to all notes of the same pitch class
        if context.propagate_accidentals=='octave' then
           accidental_key = pitch.octave..pitch.note
        else
           accidental_key = pitch.note
        end
        
        -- get the appropriate accidental
        if pitch.accidental then
            context.accidental[accidental_key] = pitch.accidental
            accidental = pitch.accidental
        else
            accidental = context.accidental[accidental_key]
        end            
    end    
    local base_pitch
    base_pitch = midi_note_from_note(context.key_mapping, note, accidental)                
    base_pitch = base_pitch + context.global_transpose + context.voice_transpose
    return base_pitch 
end

function compute_bar_length(song)
    -- return the current length of one bar
    local note_length = song.context.note_length or song.context.default_note_length
    return (song.context.meter.num / song.context.meter.den) * note_length * song.context.timing.base_note_length * 1e6 
end

function compute_duration(note, song)
    -- compute the duration (in microseconds) of a note_def
    
    -- takes into account:
    -- tempo 
    -- note length
    -- triplet state 
    -- broken state
    -- duration field of the note itself
    -- bars for multi-measure rests  
    local timing = song.context.timing
    local duration = note.duration
    local meter = song.context.meter
    if note.space then return 0,0,0 end
    
    -- we are guaranteed to have filled out the num and den fields
    local length = duration.num / duration.den
        
    -- measure rest (duration is in bars, not unit lengths)
    if note.measure_rest then   
        -- one bar =  meter ratio * note length (e.g. 1/16 = 16)
        local bar = compute_bar_length(song) *  length 
        return bar, length*meter.num, length
    end
    
    
    local shift = 1
    local this_note = 1
    local next_note = 1
    
    local prev_note = 1
    
    -- take into account previous dotted note, if needed
    if timing.prev_broken_note then
        prev_note = timing.prev_broken_note
    else
        prev_note = 1
    end
    
    -- deal with broken note information
    -- a < shortens this note by 0.5, and increases the next by 1.5
    -- vice versa for >
    -- multiple > (e.g. >> or >>>) lengthens by 1.75 (0.25) or 1.875 (0.125) etc.
    if duration.broken then
        shift = math.pow(song.context.broken_ratio, math.abs(duration.broken))
        if duration.broken<0 then
            this_note = 1.0 / shift
            next_note = 1.0 + 1 - (1.0 / shift)
        else
            this_note = 1.0 + 1 - (1.0 / shift)
            next_note = (1.0 / shift)
        end
        
        -- store for later
        timing.prev_broken_note = next_note
    else
        timing.prev_broken_note = 1
    end
    
    local beats = length * this_note * prev_note * timing.triplet_compress    
    length = beats * timing.base_note_length * 1e6
    local note_length = song.context.note_length or song.context.default_note_length

    local notes = beats/note_length
    local bars = notes*meter.den/meter.num
    
    return length, notes, bars
end


function expand_grace(song, grace_note)
    -- Expand a grace note sequence 
    -- grace notes have their own separate timing (i.e. no carryover of
    -- broken note state or of triplet state)
    
    -- preserve the timing state
    local preserved_state = deepcopy(song.context.timing)
    
    song.context.timing.prev_broken_note = 1
    reset_triplet_state(song)
       
    local grace = {}
    
    for i,v in ipairs(grace_note) do        
        compile_note(v, song)
        table.insert(grace, v)
    end
    
    -- restore timing state
    song.context.timing = preserved_state
    
    -- insert the grace sequence   
    return grace

end
    
    
function compile_note(note, song)
    -- compile a single note: compute pitch and duration
    local pitch = compute_pitch(note, song)
    local duration, notes, bars = compute_duration(note, song)
    
    -- insert grace notes before the main note, if there are any
    if note.grace then
            note.grace.sequence = expand_grace(song, note.grace) 
    end
    note.play_pitch = pitch
    note.play_duration = duration
    note.play_notes = notes
    note.play_bars = bars
    
    note.play_bar_time = song.context.timing.bar_time    
        -- advance time, update tuplet state
    update_tuplet_state(song)   
    -- advance bar time (in fractions of a bar)
    song.context.timing.bar_time = song.context.timing.bar_time + note.play_bars
    return note
end


function insert_note(note, song, token_index, abc)
        -- insert a new note into the song
       
        note = compile_note(note, song)
        
        -- extract any chords into a separate event
        if note.chord then
            local chord = {event='chord', chord=note.chord, token_index=token_index}
            chord.chord.notes = get_chord_notes(chord.chord, {}, song.context.key)
            table.insert(song.opus, chord)
        end
        
       if note.text then
            local chord = {event='text', text=note.text, token_index=token_index}            
            table.insert(song.opus, chord)
        end
      
     
        -- insert the note events
        if note.play_pitch==nil then
            -- rest            (strip out 0-duration y rests)
            if note.play_duration>0 then
                song.opus[#song.opus+1] = {event='rest', note=note, token_index=token_index, abc=abc}
                
            end            
        else       
            -- pitched note            
            song.opus[#song.opus+1] = {event='note', note=note, token_index=token_index, abc=abc}
        end
       
end



--
-- From source file: emit_abc.lua
--
-- functions for writing out text represenatations of the song token_stream
local field_tags = {key = 'K'
,title = 'T'
,ref =  'X'
,area =  'A'
,book =  'B'
,composer =  'C'
,discography =   'D'
,extended = 'E'
,file =   'F'
,group =   'G'
,history =   'H'
,instruction =   'I'
,length =   'L'
,meter =   'M'
,macro =   'm'
,notes =   'N'
,origin =   'O'
,parts =   'P'
,tempo =   'Q'
,rhythm =   'R'
,remark =  'r'
,source =   'S'
,symbolline =   's'
,user =   'U'
,voice =   'V'
,words =  'w'
,end_words =  'W'
,transcriber =  'Z'
,continuation =  '+'
}

local default_macros =  invert_table({
      ['~'] = '!roll!',
      ['.'] = '!staccato!',
      H = '!fermata!',
      L = '!accent!',
      M = '!lowermordent!',
      O = '!coda!',
      P = '!uppermordent!',
      S = '!segno!',
      T = '!trill!',
      u = '!upbow!',
      v = '!downbow!'
    }   
)

function abc_meter(meter)
    -- return the string representation of a meter
    -- e.g. {num=3, den=4} becomes 'M:3/4'
    -- if there is an explicit emphasis then this produces
    -- a compound numerator (e.g. M:(2+3+2)/4)
    local num = ''
    
    -- free meter
    if meter.num==0 and meter.den==0 then
        return 'M:none'
    end
    
    if #meter.emphasis==1 then
        -- simple meter
        num = meter.num
    else
        -- join together complex meters from the empahsis table
        local e = 0
        num = '(' -- parenthesise complex meters
        for j,n in ipairs(meter.emphasis) do
           if j ~= 1 then -- first emphasis is always on 0; skip that
            num = num .. (n-e) .. '+'
            e = n
           end
        end
        
        -- length of last emphasis is however much to make up
        -- to the total meter length
        num = num .. (meter.num-e) .. ')'
           
    end
   
    local ret = string.format('M:%s/%s' , num, meter.den..'')
    return ret
    
end

function abc_tempo(tempo)
    -- return the string represenation of a tempo definition
    -- e.g. Q:1/4=120 or Q=1/2 1/4 1/2=80 "allegro"
    local q = ''
    
    if not tempo[1] then
        -- tempo without length indicator
        q = ''..tempo.tempo_rate
    else
    
        -- abc out the tempo units
        for i,v in ipairs(tempo) do
            q = q .. string.format('%s/%s ', v.num..'', v.den..'')
        end
        
        -- strip trailing space
        q = string.sub(q, 1, -2)
        
        -- the rate as =140
        q = q .. '=' .. tempo.tempo_rate
    end
        
    -- tempo names (e.g. "allegro")
    if tempo.name then
        q = q .. ' "' .. tempo.name .. '"'
    end
    
   return string.format('Q:%s', q)
end

function abc_key(key)
    -- return the string representation of a key 
    local clef = ''
    local acc = ''
    
    -- no key
    if key.none then
        return 'K:none' 
    end
    
    if key.pipe then
        return 'K:'..key.pipe
    end
    
    -- root and modal modifier
    local root = string.upper(string.sub(key.root,1,1)) .. string.sub(key.root,2,-1)    
    root = root:gsub('s', '#')
    
    if key.mode then     
        root = root .. key.mode
    end

    -- accidentals
    if key.accidentals then
        acc = ''
        for i,v in ipairs(key.accidentals) do
            acc = acc .. ' '.. abc_accidental(v.accidental)..v.note
        end
    end
    
    -- handle clef modifiers 
    if key.clef then
        clef = ' '
        -- alto, treble, etc. as a bare string
        if key.clef.clef then
            clef = clef .. key.clef.clef
        end
        
        -- other settings (e.g. transpose=3) are in
        -- key=value format
        for i,v in pairs(key.clef) do
            if i ~= 'clef' then
                clef = clef .. string.format(' %s=%s',i,v..'')
            end
        end
    end
    
    return string.format('K:%s%s%s', root , acc, clef )
end

function abc_part_string(part_table)
    -- return the string representation of a parts table
    local ret = ''
    for i,v in  ipairs(part_table) do
        -- simple part
        if type(v[1])=='string' then
            ret = ret .. v[1]
        end
        
        -- sub part (e.g A(BC)2A)
        if type(v[1])=='table' then
            ret = ret .. '(' .. abc_part_string(v) .. ')'
        end
        
        
        -- repeats
        if v['repeat'] and string.len(v['repeat'])>0 and (0+v['repeat']) > 1 then
            ret = ret .. v['repeat']
        end
    end
    return ret
   
end

function abc_parts(parts)
    -- return the string representation of a parts structure
    return 'P:'..abc_part_string(parts)
end

function abc_note_length(note_length)
    return 'L:1/' .. note_length
end

function abc_lyrics(lyrics)
    -- return the ABC string for a given lyric structure
    -- lyrics should have:
    --    syllable field giving the syllable
    --    br field giving the break symbol ('-' or ' ')
    --    advance field giving the number of notes to advance to the next syllable
    local lyric_string = {}
    local next_advance
    for i,v in ipairs(lyrics) do
        local syl = v.syllable
        
        -- escape characters (unbreakable space and dash)
        syl = syl:gsub(' ', '~')
        syl = syl:gsub('-', '\\-')
        table.insert(lyric_string, syl)
        
        -- advance will be from the next symbol
        if #lyrics>i then
            next_advance = lyrics[i+1].advance
        else
            next_advance = 1
        end
        
        -- abc in holds (either syllable holds with _ or bar hold with |)
        if next_advance  then
            if next_advance=='bar' then 
                table.insert(lyric_string, '|')
            elseif next_advance>1 then
                for i=2,next_advance do
                    table.insert(lyric_string, '_')
                end
            end
        end
        
        -- insert the break symbol (' ' or '-')
        table.insert(lyric_string, v.br)
    end
    return 'w:'..table.concat(lyric_string)
end


function abc_voice(voice)
    -- return the ABC string represenation of a voice. Has
    -- an ID, and a set of optional specifiers 
    local str = 'V:'..voice.id
    
    for i,v in ipairs(voice.specifiers) do
        str = str..' '..v.lhs..'='..v.rhs
    end
    
    return str
    
end

function abc_new_part(part)
    -- return the abc definition of a new part
    return 'P:'..part
end

function abc_symbol_line(symbol_line)
    -- return the abc string for a symbol line
    -- e.g. s:* * "@here" * * !trill!
    local symbols = {}
    
    for i,v in ipairs(symbol_line) do
        -- get representation of each symbol
        if v.type=='spacer' then
            table.insert(symbols, '*')
        elseif v.type=='bar' then
            table.insert(symbols, '|')
        elseif v.type=='decoration' then
            table.insert(symbols, v.decoration)
        elseif v.type=='chord_text' then
            table.insert(symbols, v.chord_text)
        end
        table.insert(symbols, ' ')
    end
    
    -- strip trailing whitespace
    return 's:'..string.sub(table.concat(symbols), 1, -2)
end


function abc_directive(directive, inline)
    -- Return the ABC notation for a directive (I: or %%)
    -- Uses %% for all non-standard directives and I: only
    -- for standard ones. Forces I: if in inline mode
    local standard_directives = {'abc-charset', 'abc-version', 'abc-include', 'abc-creator'}
    local str
    
    if not directive then
        return ''
    end
    
    if is_in(directive.directive, standard_directives) or inline then
        str = 'I:'..directive.directive
    else
         str = '%%'..directive.directive
    end
    
    -- append space separated arguments
    for i,v in ipairs(directive.arguments) do
        str = str .. ' ' .. v
    end
    return str
end

function abc_field(v, inline)
    -- abc out a field entry (either inline [x:stuff] or 
    -- as its own line 
    -- X:stuff
    
    local str
    
    -- plain text tokens
    if v.token=='append_field_text' then 
        str =  '+' .. ':' .. v.content
    end
    
    if v.token=='field_text' then 
        str = field_tags[v.name] .. ':' .. v.content
    end
    
    -- key, tempo, meter
    if v.token=='meter' then
        str = abc_meter(v.meter)
    end
 
    -- voice definitions
    if v.token=='voice_def' or v.token=='voice_change' then
        str = abc_voice(v.voice)
    end
  
 
    if v.token=='key' then
        str = abc_key(v.key) 
    end

    if v.token=='tempo' then
        str = abc_tempo(v.tempo)
    end
    
    if v.token=='instruction' then
        str = abc_directive(v.directive, v.inline)
    end

    
    if v.token=='parts' then
        str = abc_parts(v.parts)
    end
    
    if v.token=='new_part' then
        str = abc_new_part(v.part)
    end
    
    if v.token=='symbol_line' then
        str = abc_symbol_line(v.symbol_line)
    end
    
    
    if v.token=='words' then
        str = abc_lyrics(v.lyrics)
    end
    
    if v.token=='note_length' then
        str = abc_note_length(v.note_length)
    end
    
    -- if this was a field
    if str then
        if inline then
            return '[' .. str .. ']'
        else
            return str .. '\n'
        end
    end
    
    return nil
end


function abc_triplet(triplet)
    -- abc the string represenation of a triplet specifier
    -- Uses the simplest ABC form
    -- 1-3 elements p:q:r
    -- p:q gives the ratio of the compression
    -- r gives the duration of the effect (in notes)
    
    local triplet_string
    local q_table = {-1,3,2,3,-1,2,-1,3,-1} -- default timing
    
    triplet_string = '('..triplet.p
    
    -- check if we need an r field
    local r_needed = triplet.r and triplet.r ~= triplet.p
    
    -- only need q if it's not default
    -- e.g. triplet p=3, q=2, r=3 should just be written as (3
    local q_needed = triplet.q and (q_table[triplet.p]~=triplet.q)
    
    -- triplet of form (3:2
    if q_needed or r_needed then
        triplet_string = triplet_string .. ':'
        if q_needed then 
            triplet_string = triplet_string .. triplet.q
        end
    end
    
    -- full triplet (only need r if it's not equal to p)
    if r_needed then
        triplet_string = triplet_string .. ':' .. triplet.r
    end
    
    return triplet_string -- .. ' ' -- must include trailing space separator!
end


function abc_accidental(accidental)
    local acc = ''
    if accidental then
        local ad = accidental
        -- microtonal accidenals
        if ad then
            -- 0 is = 
            if ad.den == 0 or ad.num==0 then
                acc = '='
                
            -- plain accidentals
            elseif ad.den == 1 then
                if ad.num==1 then
                    acc = '^'
                elseif ad.num==-1 then
                    acc = '_'
                elseif ad.num==2 then
                    acc = '^^'
                elseif ad.num==-2 then
                    acc = '__'
                else
                    -- triple etc. sharps notated ^3f
                    if ad.num>0 then
                        acc = '^'..ad.num
                    else
                        acc = '_'..-ad.num
                    end
                end
            else
                -- write as /n if possible
                if math.abs(ad.num)~=1 then
                    if ad.num+0<0 then
                        acc = -ad.num
                    else
                        acc = ad.num
                    end
                end
                
                
                if (ad.num+0)<0 then
                    acc = '_'..acc..'/'..ad.den
                else
                    acc = '^'..acc..'/'..ad.den
                end
                
            end
        end
    end
   return acc 
end

function abc_pitch(note_pitch)
    -- get the string represenation of a pitch table
    -- pitch; lowercase = +1 octave
    
 
    -- root note
    local pitch = note_pitch.note
    
    -- octave shifts
    if note_pitch.octave then
        local octave = note_pitch.octave
        
        if octave<1 then
            pitch = string.upper(note_pitch.note)
            octave = octave+1
        end
        
        
        -- increase octave with '
        if octave>1 then
            for i=1,octave-1 do
                pitch = pitch .. "'"
            end
        end 
        -- decrease octave with ,
        if octave<1 then
            for i=1,(1-octave) do
                pitch = pitch .. ","
            end
        end
    end
    
   -- add accidentals
    pitch = abc_accidental(note_pitch.accidental)..pitch
       
    return pitch
end


function abc_duration(note_duration)
    -- get the string representation of the duration of the note
    -- e.g. as a fraction (A/4 or A2/3 or A>)

    local duration 
 
   
    -- work out the duration form
    -- nothing if fraction is 1/1
    -- just a if fraction is a/1
    -- just /b if fraction is 1/a
    -- a/b otherwise
    if note_duration.num==1 and note_duration.den==1 then  
        duration = ''
    elseif note_duration.num~=1 and note_duration.den==1 then
        duration = note_duration.num   
    elseif note_duration.num==1 and note_duration.den~=1 then
        duration = string.format('/%d', note_duration.den)
    else
        duration = string.format('%d/%d', note_duration.num, note_duration.den)
    end
    
    -- special case: /2 becomes just / 
    if note_duration.den==2 and note_duration.num==1 then
        duration = '/'
    end

    -- add broken rhythm symbols (< and >)
    -- broken, this note shortened
    if note_duration.broken < 0 then
        duration = duration..string.rep('<',-note_duration.broken)
        
   end
   
    -- broken, this note lengthened
    if note_duration.broken > 0 then
        duration = duration..string.rep('>', note_duration.broken)        
    end
   
    return duration
end


function abc_note_def(note)
    local note_str = ''
    
    -- measure rests
    if note.measure_rest then
        if note.duration.num==1 and note.duration.den==1 then
            return 'Z'
        else
            if note.duration.den==1 then            
                return 'Z' .. note.duration.num
            else
                -- fractional bar rests aren't really in the standard, but
                -- we can genreate them anyway
                return 'Z' .. note.duration.den ..  '/' ..note.duration.num
            end
        end
    end
    
    -- space notes
    if note.space then
        return 'y'
    end
    
    -- pitch and duration
    if note.rest then
        note_str = 'z'
    else
        note_str = abc_pitch(note.pitch)
    end
    note_str = note_str .. abc_duration(note.duration)
    return note_str
end

function abc_chord(chord)  
    -- return the represenation of a chord
   local chord_str = chord_case(chord.root)
   -- omit maj for major chords
   if chord.chord_type~='maj' then
      chord_str = chord_str..string.lower(chord.chord_type)
   end
   
   if chord.inversion then
        chord_str = chord_str .. '/' .. chord_case(chord.inversion)
    end    
    return string.format('"%s"', chord_str)
end

function abc_decoration(decoration)
    -- return the string of decoration for a note, replacing standard decorations like
    -- !roll! with the default user macro replacements
    local decorations = {}
    for i,v in ipairs(decoration) do
        table.insert(decorations,default_macros[string.lower(v)] or v)
    end
    return table.concat(decorations)
end

function abc_note(note)
    -- abc a note out
    -- Return the string version of the note definition
    -- Includes pitch and duration
    local note_str = ''
    
    -- grace notes (e.g. {gabE}e)
    if note.grace then
        note_str = note_str .. '{'
        if note.grace.acciacatura then
            note_str = note_str .. '/'
        end
        for i,v in ipairs(note.grace) do
            note_str = note_str .. abc_note_def(v)
        end
        note_str = note_str .. '}'
    end
    
    -- chords (e.g. "Cm")
    if note.chord then
        note_str = note_str  .. abc_chord(note.chord) 
    end
    
    -- text annotations (e.g ">hello")
    if note.text then
        note_str = note_str .. abc_text(note.text)
    end
    
    
    -- decorations (e.g. . for legato)
    if note.decoration then        
        note_str = note_str ..  abc_decoration(note.decoration)
    end
    
    -- pitch and duration
    note_str = note_str .. abc_note_def(note)
    
    -- ties
    if note.tie then
        note_str = note_str .. '-'
    end
    
    return note_str
end



function abc_text_element(text)
    return '"' .. (text.position or '').. text.text .. '"'
end

function abc_text(text)
    text_table = {}
    for i,v in ipairs(text) do
        table.insert(text_table, abc_text_element(v))
    end
    return table.concat(text_table)
end


function abc_bar(bar)
    -- Return a string representing a bar element
    -- a bar can be
    -- | single bar
    -- || double bar
    -- [| double thick-thin bar
    -- |] double thin-thick bar
    -- |: start repeat
    -- :| end repeat
    -- :|: mid repeat    
    
    local bar_str = ''
    
    local type_symbols = {plain='|', double='||', thickthin='[|', thinthick='|]'}
    
    for i,v in pairs(type_symbols) do
        if bar.type==i then 
            bar_str = v
        end
    end
    
    if bar.type=='start_repeat' then
        bar_str= '|' .. repeat_string(':', bar.start_reps)
    end
    
    if bar.type=='end_repeat' then
        bar_str= repeat_string(':', bar.end_reps) .. '|'
    end
    
    if bar.type=='mid_repeat' then
        bar_str= repeat_string(':', bar.end_reps) .. '|' .. repeat_string(':', bar.start_reps)
    end
    
    
    -- variant indicators (e.g. for  repeats :|1 x x x :|2 x x x ||)
    if bar.variant_range then      
        -- for part variants, can have multiple indicators
        for i,v in ipairs(bar.variant_range) do
            bar_str = bar_str .. v .. ','
        end
        -- remove last comma
        bar_str = string.sub(bar_str, 1, -2)
    end
    
    return bar_str
end


function abc_variant(variant)
    -- ABC representation of a part varaint [4 or [2,3,4-5
    
    local var_str = '['
    -- for part variants, can have multiple indicators
    for i,v in ipairs(variant.variant_range) do
        var_str = var_str .. v .. ','
    end
    -- remove last comma
    var_str = string.sub(var_str, 1, -2) 
    return var_str
end

local note_elements = {split=' ', split_line='\n', continue_line='\\\n', chord_begin='[', chord_end=']', slur_end=')', slur_begin='('}

function abc_note_element(element)
    -- Return a string representing a note element 
    -- can be a note, rest, bar symbol, variant
    -- chord group, slur group, triplet/tuplet
    -- line break, beam break or some inline text
    
    local static_element = note_elements[element.token]
    
    if static_element then return static_element end
    
    if element.token=='chord' and element.chord then
            return  abc_chord(element.chord) 
    end
    
    if element.token=='overlay' then
        return string.rep('&', element.bars)
    end
        
    if element.token=='text' then     
        return abc_text_element(element.text)
    end
    
    if element.token=='triplet' then
        return abc_triplet(element.triplet)
    end
    
    if element.token=='note' then
        return abc_note(element.note)
    end
    
    if element.token=='bar' then
        return abc_bar(element.bar)
    end
 
    if element.token=='variant' then
        return abc_variant(element.variant)
    end
 
    
    return nil
    
end
 
function abc_element(element)    
    -- return the abc representation of token_stream element
    
    return abc_note_element(element) or abc_field(element, element.inline)
    
end

function emit_abc(token_stream)
-- return the token_stream out as a valid ABC string
    local output = {}       
    for i,v in ipairs(token_stream) do
         table.insert(output, abc_element(v))
    end    
    -- concatenate into a single string
    return rtrim(table.concat(output))
end

function abc_from_songs(songs, creator)
    -- return the ABC representation of a table of songs
    -- the creator field can optionally be specified to identify
    -- the program that created this code
    local out = {}
    if creator then
        -- write out header
        table.insert(out, '%abc-2.1\n')
        table.insert(out, '%%abc-creator '..creator..'\n')
    end
   
    -- each song segment separated by two newlines
    for i,v in ipairs(songs) do
        table.insert(out, emit_abc(v.token_stream))
        table.insert(out, '\n\n')
    end
    return table.concat(out)
end








--
-- From source file: tools.lua
--

local pitch_table = {c=0, d=2, e=4, f=5, g=7, a=9, b=11}
local pitches = {'c', 'd', 'e', 'f', 'g', 'a', 'b'}


function diatonic_transpose_note(original_mapping, shift, new_mapping, inverse_mapping, pitch, accidental)
    -- Transpose a note name (+ accidental) in an original key mapping to a new key mapping which is
    -- shift semitones away    
        local semi = (get_semitone(original_mapping, pitch, accidental)%12 + shift)
        
        -- test for octave shift
        local octave = 0
        if semi<0 then
            octave = math.floor((semi/12))
         end
               
        if semi>11 then
            octave = math.floor(((semi)/12))            
        end        
        
        semi = semi % 12             
        local new_accidental, new_pitch                       
        -- if we don't need an accidental
        if inverse_mapping[semi] then
            new_pitch = inverse_mapping[semi]       
            new_accidental = nil                  
        else
            -- check the next note
            new_pitch = inverse_mapping[(semi+1)%12]                     
            t = new_mapping[new_pitch]            
            if not t or t==-1 then 
                -- check the note lower and sharpen it
                new_pitch = inverse_mapping[(semi-1)%12] 
                t = new_mapping[new_pitch]
                if t==0 then new_accidental={num=1, den=1} end
                if t==-1 then new_accidental={num=0, den=0} end
                if t==1 then new_accidental={num=2, den=1} end
            else
                -- if we can just flatten that one, use that
                if t==0 then new_accidental={num=-1, den=1} end
                if t==1 then new_accidental={num=0, den=0} end            
            end            
        end        
        return new_pitch, new_accidental, octave
end


function diatonic_transpose(tokens, shift)
    -- Transpose a whole token stream by a given number of semitones    
    local current_key, original_key        
    local mapping, key_struct
    local inverse_mapping = {}
    
    
    for i,token in ipairs(tokens) do
        if token.token=='key' then                               
                        
            -- get new root key
            original_key = create_key_structure(token.key)
            token.key.root = transpose_note_name(token.key.root, shift)
            current_key = token.key            
            -- work out the semitones in this key
            mapping = create_key_structure(current_key)                                               
            for i,v in pairs(pitch_table) do                                           
                local k = v+mapping[i]
                k = k % 12
                inverse_mapping[k] = i
            end                       
        end        
        
        -- transpose chords
        if token.token=='chord' then
          token.chord = transpose_chord(token.chord, shift)                        
        end
        
        if token.token=='note' and mapping then
            local pitch,accidental,octave
            
            -- transpose embedded chords
            if token.note.chord then
                token.note.chord = transpose_chord(token.note.chord, shift % 12)                        
            end
        
            -- if we have a pitched note
            if token.note.pitch then        
                -- transpose the note                
                pitch,accidental,octave = diatonic_transpose_note(original_key, shift, mapping, inverse_mapping, token.note.pitch.note, token.note.pitch.accidental)                
                token.note.pitch.note = pitch
                token.note.pitch.accidental = accidental                    
                token.note.pitch.octave = token.note.pitch.octave + octave
            end
            
            -- apply to grace notes
            if token.note.grace then
                for i,v in ipairs(token.note.grace) do
                    pitch,accidental,octave = diatonic_transpose_note(original_key, shift, mapping, inverse_mapping, v.pitch.note, v.pitch.accidental)
                    v.pitch.note = pitch
                    v.pitch.accidental = accidental                
                    v.pitch.octave = v.pitch.octave + octave
                end
            end
            
        end
        
    end       
end


function swap_or_insert(t, match, position, default)
    -- Find match in t; if it exists, swap it into position
    -- if not, insert a default at that position
    local ref = find_first_match(t, match) 
    local elt
    
    -- insert default if does not match
    if not ref then                 
        table.insert(t, position, default)        
    else        
        elt = t[ref]
        table.remove(t, ref)
        -- swap it into place
        table.insert(t, position, elt)
    end
    
end

function validate_token_stream(tokens)
    -- Make sure the given token stream is valid
    -- Forces the token stream to begin with X:, followed by T:, followed by the other
    -- fields, followed by K:, followed by the notes
        
    swap_or_insert(tokens, {token='field_text', name='ref'}, 1, {token='field_text', name='ref', content='1', is_field=true})    
    swap_or_insert(tokens, {token='field_text', name='title'}, 2, {token='field_text', name='title', content='untitled', is_field=true})
                
    local first_note = 1
    -- find first non-field element
    for i,v in ipairs(tokens) do                                                       
        if not v.is_field  then       
            break
        end        
        first_note = i                
    end    
        
    if first_note>#tokens then
        first_note = #tokens
    end


    -- make sure last element before a note is a key  
    local ref = find_first_match(tokens, {token='key'}) 
    if not ref then
        table.insert(tokens, first_note+1, {token='key', key={root='c'}})                               
    else
        local elt = tokens[ref]
        table.remove(tokens, ref)
        ref = find_first_match(tokens, {token='key'}) 
        table.insert(tokens, first_note, elt)
    end
    
    
    return tokens
end


function header_end_index(tokens)
    -- Return the index of the end of the header
    -- returns nil if there is only header
    for i,v in ipairs(tokens) do        
        if not v.is_field then return i end
    end
    return #tokens+1
end



--
-- From source file: tuplets.lua
--
-- Functions for dealing with tuplets

function update_triplet_ratio(song)
    -- compute the current compression ratio
    -- The product of all active triplets
    local ratio = 1
    for i,v in ipairs(song.context.timing.triplet_state) do
        ratio = ratio / v.ratio
    end
    song.context.timing.triplet_compress = ratio
end

function push_triplet(song, p, q, r)
    -- push a new triplet onto the stack
    table.insert(song.context.timing.triplet_state, {count=r, ratio=p/q})
    update_triplet_ratio(song)
end

function reset_triplet_state(song)
    -- reset the triplet state, cancelling all triplets
    song.context.timing.triplet_state = {}
    update_triplet_ratio(song)
end

function update_tuplet_state(song)
    -- a note has occured; change tuplet state
    -- update tuplet counters; if back to zero, remove that triplet
    
    local actives = {}
    for i,v in ipairs(song.context.timing.triplet_state) do
        v.count = v.count-1
        -- keep only triplets with counters > 0
        if v.count > 0 then
            table.insert(actives, v)
        end
    end    
    song.context.timing.triplet_state = actives
        
    -- update the time compression
    update_triplet_ratio(song)

end

function apply_triplet(song, triplet)
    -- set the triplet fields in the song
    local p,q,r
    
    if triplet.q == 'n' then
        -- check if compound time -- if so
        -- the default timing for (5 (7 and (9 changes
        if is_compound_time(song) then
            q = 3
        else    
            q = 2
        end
    else
        q = triplet.q
    end
    
    p = triplet.p
    r = triplet.r 
    
    -- set compression and number of notes to apply this to    
    push_triplet(song, p,q,r)   
end



function parse_triplet(triplet, song)
-- parse a triplet/tuplet definition, which specifies the contraction of the following
-- n notes. General form of p notes in the time of q for the next r notes

    local n, p, q, r
    q=-1
    r=-1
            
    -- simple triplet of form (3:
    if #triplet==1 then
        p = triplet[1]+0                
    end
    
    -- triplet of form (3:2
    if #triplet==2 then
        p = triplet[1]+0                
        q = triplet[2]+0
    end
    
    -- triplet of form (3:2:3 or (3::2 or (3::
    if #triplet==3 then
        p = triplet[1]+0
        if triplet[2] and string.len(triplet[2])>0 then
            q = triplet[2]+0
        end
        if triplet[3] and string.len(triplet[3])>0 then
            r = triplet[3]+0
        end
    end
       
    -- default: r is equal to p
    if r==-1 then
        r = p
    end

    -- default to choosing q from the table
    -- note: for n cases, we can't determine the compression
    -- until we know what meter we will be in when this triplet is encountered
    -- (i.e. at compile time)
    local q_table = {-1,3,2,3,'n',2,'n',3,'n'}
    if q==-1 then
        q = q_table[p]
    end
        
    return {p=p, q=q, r=r}
end


--
-- From source file: pitches.lua
--
-- pitch arithmetic functions
local natural_pitch_table = {c=0, d=2, e=4, f=5, g=7, a=9, b=11}

function get_semitone(key_mapping, pitch, accidental)
    -- return the semitone of a note (0-11) in a given key, with the given accidental
    local base_pitch = natural_pitch_table[pitch]    
           
    -- accidentals / keys
    if accidental then   
        if accidental.den==0 then 
            accidental =  0 
        else
            accidental = accidental.num / accidental.den
        end
        base_pitch = base_pitch + accidental        
    else        
        -- apply key signature sharpening / flattening
        if key_mapping then            
            base_pitch = base_pitch + key_mapping[pitch]
        end
    end        
    return base_pitch 
end

function midi_note_from_note(mapping, note, accidental)
    -- Given a key mapping, get the midi note of a given note        
    -- optionally applying a forced accidental
    accidental = note.pitch.accidental or accidental    
    local base_pitch = get_semitone(mapping, note.pitch.note, accidental)    
    return base_pitch + 60 + (note.pitch.octave or 0) * 12
end

local note_table = {
c=0,
cb=11,
cs=1,
d=2,
db=1,
ds=3,
e=4,
eb=3,
es=5,
f=5,
fb=4,
fs=6,
g=7,
gb=6,
gs=8,
a=9,
ab=8,
as=10,
b=11,
bb=10,
bs=12
}

function all_note_table()
    -- return a list of all notes and their semitone numbers
    return note_table
end

local key_note_table = {
c=0,
cb=11,
cs=1,
d=2,
db=1,
e=4,
eb=3,
f=5,
fs=6,
g=7,
gb=6,
a=9,
ab=8,
b=11,
bb=10
}

local inverse_key_note_table = invert_table(key_note_table)

function midi_to_frequency(midi, reference)
    -- transform a midi note to a frequency (in Hz)
    -- optionally use a different tuning than concert A
    -- specify frequency of A in Hz as the second parameter if required
    reference = reference or 440.0    
    return reference * math.pow(2.0, (midi-69)/12.0)
end


function transpose_note_name(name, shift)
    -- convert a note string into a canonical note string shifted by shift 
    -- semitones. Wraps around at octave boundaries
    return canonical_note_name((get_note_number(name)+shift)%12)
end

function get_note_number(note)
    -- Convert a note string to a note number (0-11)
    -- e.g. get_note_number('C#') returns 1
    local note = note_table[string.lower(note:gsub('#','s'))]
    assert(note, "Tried to get note number of "..(note or '<nil>'))
    return note
end

function canonical_note_name(num)
    -- change a semitone number (0-11) to a note name.
    -- only returns one of the canonical names (so there is no
    -- enharmonic ambiguity). 
    -- This means that canonical_note_name(get_note_number(note)) is not necessarily equal to note 
    return inverse_key_note_table[num % 12]
end

function chord_case(str)
    -- Convert a note name to upper case, with proper # symbol
    return string.upper(string.sub(str,1,1))..string.sub(str,2,-1):gsub('s', '#')
end

function printable_note_name(n)
    -- convert a note number to a note symbol, and then return it as
    -- a printable note (uppercase, with #)
    local str = inverse_key_note_table[n%12]
    return chord_case(str)
end


--
-- From source file: compile.lua
--
-- Functions from transforming a parsed token stream into a song structure and then an event stream

function get_bpm_from_tempo(tempo)
    -- return the real bpm of a tempo 
    local total_note = 0
    for i,v in ipairs(tempo) do
        total_note = total_note + (v.num / v.den)
    end                    
    
   
    local rate = 60.0 / (total_note * tempo.tempo_rate)
    return rate
end

function update_timing(song)
    -- Update the base note length (in seconds), given the current L and Q settings
    -- Returns a timing state update event to be inserted into the output stream
    local rate = 0    
    local note_length = song.context.note_length or song.context.default_note_length
    local timing = song.context.timing
    
    rate = get_bpm_from_tempo(song.context.tempo)
    timing.base_note_length = rate / note_length
    
    timing.grace_note_length = rate / (song.context.grace_length.den/song.context.grace_length.num)
    
    -- deal with unmetered time; one "bar" becomes one whole note
    if song.context.meter.num==0 then
         timing.bar_length = rate*1e6
    else
        timing.bar_length = compute_bar_length(song)
    end
    
        
    table.insert(song.opus, {event='timing_change', timing={base_note_length=timing.base_note_length*1e6, bar_length=timing.bar_length,
    beats_in_bar = song.context.meter.num, note_length=note_length, beat_length = timing.bar_length/song.context.meter.num}})
end    

function is_compound_time(song)
    -- return true if the meter is 6/8, 9/8 or 12/8
    -- and false otherwise
    local meter = song.context.meter
    if meter then
        if meter.den==8 and (meter.num==6 or meter.num==9 or meter.num==12) then
            return true
        end
    end
    return false
end

function apply_repeats(song, bar)
        -- clear any existing material
        if bar.type=='start_repeat' then
            add_section(song, 1)
        end
                                
        -- append any repeats, and variant endings
        if bar.type=='mid_repeat' or bar.type=='end_repeat' or bar.type=='double' or bar.type=='thickthin' or bar.type=='thinthick' then
        
            add_section(song, bar.end_reps+1)
            
            -- mark that we will now go into a variant mode
            if bar.variant_range then
                -- only allows first element in range to be used (e.g. can't do |1,3 within a repeat)
                song.context.in_variant = bar.variant_range[1]
            else
                song.context.in_variant = nil
            end            
        end
        
        
end

function apply_key(song, key) 
    -- apply transpose / octave to the song state
    if key.clef then                 
        if key.clef.octave then
            song.context.global_transpose = 12 * key.clef.octave -- octave shift
        else
            song.context.global_transpose = 0
        end
        
        if key.clef.transpose then 
            song.context.global_transpose = song.context.global_transpose + key.clef.transpose                
        end
    end 
    
    -- update key map
    song.context.key_mapping = create_key_structure(key)
end

function finalise_song(song)
    -- Finalise a song's event stream
    -- Composes the parts, repeats into a single stream
    -- Inserts absolute times into the events 
    -- Inserts the lyrics into the song

    compose_parts(song)
    
    -- clear temporary data
    song.opus = nil
    
    
    -- time the stream and add lyrics    
    song.stream = insert_lyrics(song.stream)
    time_stream(song.stream)       
    
end


function apply_voice_specifiers(song)
    -- apply the voice specifiers. this sets the voice transpose if need be
    song.context.voice_transpose = 0
    -- compute transpose
    local transpose =  song.context.voice_specifiers.transpose or  song.context.voice_specifiers.t or 0
    local octaves =   (song.context.voice_specifiers.octave) or 0
    
    -- look for '+8' or '-8' at the end of a clef (e.g. treble+8)
    if song.context.voice_specifiers.clef then
        local clef = song.context.voice_specifiers.clef
        if string.len(clef)>2 and string.sub(clef,-2)=='+8' then octaves=octaves+1 end
        if string.len(clef)>2 and string.sub(clef,-2)=='-8' then octaves=octaves-1 end
    end
    
    song.context.voice_transpose = 12*octaves + transpose   
    
end


function reset_timing(song)
    -- reset the timing state of the song    
    song.context.timing = {} 
    local timing = song.context.timing
    timing.triplet_state = {}    
    timing.triplet_compress = 1
    timing.prev_broken_note = 1
    timing.bar_time = 0
    update_timing(song)
end


function reset_bar_time(song)
    -- if warnings are enabled, mark underfull and overfull bars
    if song.context.bar_warnings then    
        if song.context.timing.bar_time>1 then
            warn('Overfull bar')
        end
        
        if song.context.timing.bar_time<1 then
            warn('Underfull bar')
        end
    end    
    song.context.timing.bar_time = 0
end

function start_new_voice(song, voice, specifiers)
    -- compose old voice into parts
    if song.context and song.context.voice then
        finalise_song(song)                
        song.voices[song.context.voice] = {stream=song.stream, context=song.context}
    end

    
    song.context.voice_specifiers = {}    
    -- merge in voice specifiers from heder and from this definition line
    if song.voice_specifiers[voice] then
        for i,v in pairs(song.voice_specifiers[voice]) do
            song.context.voice_specifiers[v.lhs] = v.rhs            
        end    
    end
    
    if specifiers then
        for i,v in pairs(specifiers) do
            song.context.voice_specifiers[v.lhs] = v.rhs
        end    
    end    
    
    apply_voice_specifiers(song)
    
    -- reset song state
    -- set up context state
    song.context.current_part = 'default'
    song.context.part_map = {}
    song.context.pattern_map = {}
    
    song.context.voice = voice    
    song.opus = {}
    reset_timing(song)
            
end


function precompile_token_stream(token_stream, context, merge)
    -- run through a token stream, giving duration and pitches to all notes
    -- splitting off chord symbols. Does not expand repeats/parts/voices/etc.
    -- One-to-one mapping of original token stream (no tokens added or removed)
    -- If merge is true, then symbol lines and lyrics are merged into the notes
    -- (which changes the tokens); this is disabled by default.
    local song = {context=context or get_default_context(), opus={}}
    reset_timing(song)

    
    -- merge in lyrics and symbol lines
    if merge then
        merge_symbol_line(token_stream)
        merge_lyrics(token_stream)
    end
    
    for i=1,#token_stream do
        local v = token_stream[i]
        -- notes
        if v.token=='note' then 
           compile_note(v.note, song)           
        end
        
        -- deal with triplet definitions
        if v.token=='triplet' then                
            -- update the context tuplet state so that timing is correct for the next notes
            apply_triplet(song, v.triplet)
        end
        
        -- deal with bars and repeat symbols
        if v.token=='bar' then
            reset_bar_time(song)
            song.context.accidental = {} -- clear any lingering accidentals             
        end
          
        if v.token=='note_length' then
            song.context.note_length = v.note_length
            update_timing(song)
        end
        
        if v.token=='tempo' then
            song.context.tempo = v.tempo
            update_timing(song)
        end
               
        if v.token=='meter' then  
            song.context.meter = v.meter
            update_timing(song)  
        end
        
        if v.token=='chord' then  
            v.chord.notes = get_chord_notes(v.chord, {}, song.context.key)
        end
        
        -- update key
        if v.token=='key' then            
            song.context.key = v.key
            apply_key(song, song.context.key)
        end
    end
    
end

function expand_token_stream(song)
    -- expand a token_stream into a song structure
    local v
    local token
    local context = song.context
    local insert_note = insert_note
    local opus = song.opus
    
    -- this needs to be more efficient
    local token_stream = copy_array(song.token_stream)
   
    -- merge in lyrics and symbol lines
    merge_symbol_line(token_stream)
    merge_lyrics(token_stream)
    
    local abc
    for i=1,#token_stream do
        v = token_stream[i]
        token = v.token
        
        if context.write_abc_events then
            -- write in the ABC notation event as a string
            abc = abc_element(v)
        end
        
        local event
        -- copy in standard events that don't change the context state
        if token == 'note' then
           insert_note(v.note, song, i, abc)
        else
           event = copy_table(v)
           event.event = event.token
           event.token = nil           
           event.token_index = i
           event.abc = abc
           opus[#opus+1] = event
                                                        
            if token=='chord' then  
                v.chord.notes = get_chord_notes(v.chord, {}, context.key)
            
            -- end of header; store metadata so far
            elseif token=='header_end' then
                song.header_metadata = deepcopy(song.metadata)
                song.header_context = deepcopy(context) 
            
           
            -- deal with triplet definitions
            elseif token=='triplet' then                
                -- update the context tuplet state so that timing is correct for the next notes
                apply_triplet(song, v.triplet)
            
            
            -- deal with bars and repeat symbols
            elseif token=='bar' then
                reset_bar_time(song)
                apply_repeats(song, v.bar)  
                context.accidental = {} -- clear any lingering accidentals             
            
            elseif token=='variant' then
                   -- part variant; if we see this we go into a new part            
                    start_variant_part(song, v.variant)        
                
            -- text fields
            elseif token=='field_text'  then       
                if song.metadata[v.name] then
                    table.insert(song.metadata[v.name], v.content)
                else            
                    song.metadata[v.name] =  {v.content}
                end
                           
            
            -- append fields
            elseif token=='append_field_text' then
                local last
                if song.metadata[v.name] then
                    last = song.metadata[v.name][#song.metadata[v.name]] 
                    last = last..' '..v.content
                    song.metadata[v.name][#song.metadata[v.name]]  = last                
                else
                    warn("Continuing a field with +: that doesn't exist.")
                end          
                    
            
            
            -- new voice
            elseif token=='voice_change' then
                start_new_voice(song, v.voice.id, v.voice.specifiers)
            
            
            elseif token=='voice_def' then
                -- store any voice specific settings for later
                song.voice_specifiers[v.voice.id] = v.voice.specifiers
            
            
            elseif token=='instruction' then
                if v.directive then
                    apply_directive(song, v.directive.directive, v.directive.arguments)
                end
            
             
            
            elseif token=='note_length' then
                 context.note_length = v.note_length
                 update_timing(song)
             
            
            elseif token=='tempo' then
                context.tempo = v.tempo
                update_timing(song)
                 -- store tempo string in metadata
                song.metadata.tempo = string.sub(abc_tempo(v.tempo),3)
       
            
            
            
                
            elseif token=='parts' then
                context.part_structure = v.parts
                context.part_sequence = expand_parts(context.part_structure)      
            
            
            elseif token=='new_part' then
                -- can only start a new part if the parts have been defined.
                if context.part_structure then
                    song.in_variant_part = nil -- clear the variant flag
                    start_new_part(song, v.part)    
                end
            
            
            elseif token=='meter' then  
                context.meter = v.meter
                update_timing(song)  
                -- store key string in metadata
                song.metadata.meter = string.sub(abc_meter(v.meter),3)
                

                --set the default note length
                -- if meter.num/meter.den > 0.75 then 1/8
                -- else 1/16    
        
                local ratio = song.context.meter.num / song.context.meter.num
                if ratio>=0.75 then
                    context.default_note_length = 8
                else
                    context.default_note_length = 16
                end        
            
            -- update key
            elseif token=='key' then            
                context.key = v.key
                apply_key(song, context.key)
                
                -- store key string in metadata
                song.metadata.key = string.sub(abc_key(v.key),3)
            end     
        end
  end
    
end


function compile_token_stream(song, context, metadata)
    -- Convert a token_stream into a full
    -- a song datastructure. 
    -- 
    -- song.metadata contains header data about title, reference number, key etc.
    --  stored as plain text
   
    -- The song contains a table of voices
    -- each voice contains:
    -- voice.stream: a series of events (e.g. note on, note off)
    --  indexed by microseconds,
    -- voice.context contains all of the parsed song data
    -- copy any inherited data from the file header
    
    song.default_context = context or get_default_context()
    song.context = song.default_context
   
    song.voices = {}
    song.voice_specifiers = {}
    song.metadata = metadata or {}
    start_new_voice(song, 'default')
    expand_token_stream(song)
    
    -- finalise the voice
    start_new_voice(song, nil)
    
    -- clean up
    song.stream = nil
    
end


--
-- From source file: master_parser.lua
--
-- The master grammar and functions for applying it
local tune_pattern = [[
elements <- (
                (
                    {}                  -- Cross reference (position capture)
                    <element>           -- Each tune body element
                )  
            +) -> {}

element <- (  
    {:field: field :}  /                -- Field e.g [X:title] 
    {:top_note: <complete_note>:}  /    -- A note definition 'A/2>'
    {:overlay: '&'+ :} /                -- Bar overlay symbol '&'
    {:bar: <bar> :}   /                 -- Bar symbol  '[|'  
    {:variant: <variant> :} /           -- Part variant
    {:free_text: free :} /              -- Chords or annonations "Dm7" or ">Some text"
    {:triplet: triplet :} /             -- Triplet definition '(3 abc'
    {:slur_begin: '(' :} /              -- Start of a slur group '(abc...' 
    {:slur_end: ')' :} /                -- End of a slur group '...ded)'
    {:chord_begin: '[' :} /             -- Start of chord group '[CEG...'
    {:chord_end: ']' :} /               -- End of chord group '...eg]'
    {:s: %s+ :}  /                      -- Space (splits beams in notes)
    {:continuation: '\' :} /            -- End of line continuation character
    '`' /                               -- backquote (ignored)
    comment  /                           -- comment line '% this is a comment' (ignored)
    {:linebreak_maybe: [$] :}             -- possible newline
    ) -> {}
    
    
comment <- ('%' .*)                     -- % followed by anything is a comment

free <- ( '"' 
         {:text: [^"]* :}               -- Free text within quotes 
         '"' 
        ) -> {}

oldbar <- ( 
        {:type: (('[') * ('|' / ':') + (']') *) :}  -- The bar symbol
        ({:variant_range: (<range_set>) :}) ?       -- Optional variant range :|1 or :|2,3
        ) -> {}
        
        
bar <- (    (
                {:mid_repeat: <mid_repeat> :} /  
                {:end_repeat: <end_repeat> :}  / 
                {:start_repeat: <start_repeat> :} / 
                {:double: <double> :} /
                {:thickthin: <thickthin> :} / 
                {:thinthick: <thinthick> :} /  
                {:plain: <plain> :} / 
                {:just_colons: <just_colons> :} 
            )
            {:variant_range: (<range_set>) :} ?     -- Optional variant indicator
            ) -> {}        
            
mid_repeat <- (                         -- Mid repeat ::|::
                                        -- Note the position captures capture the number of colons
                {} <colons> {} (<plain>+) {} <colons>{}     
              ) -> {}
              
start_repeat <- (                       -- Start repeat |:
                (<thickthin> / <double> / <plain> ) {} <colons> {}      
                ) -> {}
                
end_repeat <- (                         -- End repeat :|
                {} <colons> {} 
                (<thinthick> / <double> / <plain> )
              ) -> {}
              
just_colons <- (
                {} ':' <colons>  {}     -- Two or more colons (alternative mid repeat form)
                ) -> {}
                
plain <- '|'          -- Plain bar
thickthin <- (  '[' + '|' + )      -- Thick thin bar
thinthick <- ('|' + ']' + )        -- Thin thick bar
double <- ('|' ('[' / ']') * '|')  -- Double bar        
colons <- (':' +)                  -- colons
        
variant <- (
     '['                               -- A part variant (e.g. '| [4 a bc | [5 d e f')
    {:variant_range: <range_set> :}     -- Followed by a numerical range 
           )   -> {}
        
range_set <- (
                (<range>) (',' <range>) *       -- List of range elements
            ) -> {}
            
range <- (  
        <range_id> / <number>    -- Range or number
        ) -> {}
        
range_id <- (                    -- Range indicator 2-3
            <number> '-' <number>
            )
            
number <- ({ [0-9]+ }) 
         
complete_note <- (
                -- A full note definition
                ({:grace: (grace)  :}) ?  -- Grace notes as a sequence in braces {df} 
                ({:chord: (chord +)->{}  :}) ?  -- Chord or text annotation "Cm7"
                ({:decoration: ({decoration} +)->{} :}) ?  -- Sequence of decorations
                (
                    (
                        {:pitch: (note) :} /        -- Pitch of the note if a note
                        {:rest: (rest) :} /         -- or a rest
                        {:space: (space) :}/        -- or a "y" space
                        {:measure_rest: <measure_rest> :}   -- or a measure rest
                    ) 
                    {:duration: (duration)  :}?     -- Duration, as a fraction
                    {:broken: (<broken>)  :}?)      -- Broken rhythm symbols '>'
                    (%s * {:tie: '-'  :}) ?       -- Any following tie symbol A2-|A3
                ) -> {} 
                
triplet <- (
            '('                         -- Begins with a bracker 
            {[0-9]+}                    -- Followed by a number
            (':' {[0-9]+ ?}             -- Optionally followed by a number ':' or just ':' 
                (':' {[0-9]+} ? )       -- Followed by a number
                ?) 
            ? ) 
            -> {}
            
grace <- (                              -- Grace note definition
        '{'                             -- Begins with open brace
        {:acciacatura: '/' :} ?         -- Optional slash at start to distingush acciatacura
        full_note + '}'                 -- Then a sequence of notes
        ) -> {}
        

chord <- (
        ["]                             -- Quoted string  
        {([^"] *)}                      
        ["]
    )
full_note <- (                          -- Note, as appears in a grace note 
                (
                    {:pitch: (note) :} /     -- Pitch 
                    {:rest: (rest) :} /      -- Or rest
                    {:space: (space) :}/     -- Or space
                    {:measure_rest: <measure_rest> :}  -- Or measure rest
                ) 
                {:duration: (duration)  :}?     -- Optional duration, as a fraction 
                {:broken: (<broken>)  :}?       -- Broken note specifier
            ) -> {}

rest <- ( 'z' / 'x' )                  -- z or x for a rest
space <- 'y'                           -- y for invisible no-duration rest

measure_rest <- (
                ('Z' / 'X')            -- Measure rest
                ) -> {}

broken <- ( 
            ('<' +) /                 -- sequence of '<' 
            ('>' +)                   -- or '>' for broken notes
          )
          
note <- (                           -- note with a pitch
            (                       -- Optional accidental
            {:accidental: (
                           {accidental} -- Accidental symbol
                           duration ?   -- Fraction for microtonal accidentals 
                          ) -> {}  :}
            )? 
            
            {:note:  ([a-g]/[A-G]) :}   -- Note pitch
            {:octave: (octave)  :} ?    -- Octave specifier
        ) -> {}
        
decoration <- (                         -- Note decorations
                ('!' ([^!] *) '!') /    -- !xyz! style    
                ('+' ([^+] *) '+') /    -- +xyz+ style
                ([h-wH-W] / '~' / '.')              -- or a predefined decoration
                )
                
octave <- (
    ( ['] / ',') +                  -- Octave specifier; any sequence of ' or ,
    )
    
accidental <- ( 
    ('^^' /  '__' /  '^' / '_' / '=') -- Accidental symbol
    ) 
    
duration <- (                       -- Fraction pattern for durations
            {:num: [0-9] + :} ?     -- Numerator (optional)
            {:slashes: '/' +  :} ?  -- A sequence of slashes (optional) e.g. to recognise A//
            {:den: [0-9]+  :} ?     -- Denominator
            )  -> {}
            
field <- (                          -- Inline field [T:title]
            '['                     -- Open brackets
            {:contents:         
                [a-zA-Z]            -- One letter tag of the field
                ':'                 -- Colon
                [^]%nl] +           -- Everything until ] (nb %nl hack never matches)
            :}
            ']'                     -- Close brackets
        ) -> {}        
]]


local tune_matcher = re.compile(tune_pattern)

function abc_body_parser(str)
    return tune_matcher:match(str)
end


function parse_free_text(text)
    -- split off an annotation symbol from free text, if it is there
    local annotations = {'^', '_', '@', '<', '>'}
    -- separate annotation symbols
    local position, new_text
    if string.len(text)>1 and is_in(string.sub(text,1,1), annotations) then
        position = string.sub(text,1,1)
        new_text = string.sub(text,2)
    else
        new_text = text
    end
    return {position=position, text=new_text}
end


function read_tune_segment(tune_data, song)
    -- read the next token in the note stream    
  
    local insert = table.insert
    local token_stream = song.token_stream
    local last_cross_ref = nil
    local token 
  
    for i,v in ipairs(tune_data) do
        token = nil
        if type(v) == 'number' then
            -- insert cross refs, if they are enabled
            if song.parse.cross_ref then
                 last_cross_ref =  {at=v, line=song.parse.line, tune_line=song.parse.tune_line, tune=song.parse.tune, file=song.parse.filename}
            end
        else
            if v.top_note then                         
                -- add a note to the token stream                
                local cnote = parse_note(v.top_note, song.parse.user_macros)                          
                token =  {token='note', note=cnote}                     
            -- store annotations
            elseif v.free_text then
                -- could be a standalone chord
                local chord = parse_chord(v.free_text.text)                                                
                if chord then
                    token =  {token='chord', chord=chord}
                else                    
                    token =  {token='text', text=parse_free_text(v.free_text.text)}
                end
            
            -- parse inline fields (e.g. [r:hello!])
            elseif v.field then                
                -- this automatically writes it to the token_stream
                -- not correct for inline fields!
                token = parse_field(v.field.contents, song, true)
                
            -- deal with triplet definitions
            elseif v.triplet then                                        
                token =  {token='triplet', triplet=parse_triplet(v.triplet, song)}                            
            
            -- voice overlay
            elseif v.overlay then
                token =  {token='overlay', bars=string.len(v.overlay)}
            
            
            -- beam splits
            elseif v.s then
                token =  {token='split'}
            
            
            -- linebreaks
            elseif v.linebreak then
                token =  {token='split_line'}
            
            
            elseif v.continue_line then
                token =  {token='continue_line'}
            
                                        
            -- deal with bars and repeat symbols
            elseif v.bar then   
                local bar = parse_bar(v.bar)
                song.parse.measure = song.parse.measure + 1 -- record the measures numbers as written
                bar.measure = song.parse.measure
                token =  {token='bar', bar=bar}               
            elseif v.variant then
                token =  {token='variant', variant=parse_variant(v.variant)}               
            
            
            -- chord groups
            elseif v.chord_begin then            
                
                token =  {token='chord_begin'}                                
            
            
            elseif v.chord_end then
                token =  {token='chord_end'}                                               
            
            
            elseif v.slur_begin then
                token =  {token='slur_begin'}
            
            
            elseif v.slur_end then
                token = {token='slur_end'}
                
            elseif v.linebreak_maybe then
                -- dollar/exclamation linebreak symbols
                -- (enabled by I:linebreak)    
                if song.parse.linebreaks.dollar or song.parse.linebreaks.exclamation then
                    token = {token='split_line'}
                end
           end
                      
            -- insert token and set the cross reference
            if token then
                token.cross_ref = last_cross_ref
                insert(token_stream, token)
            end
        end
    end
    
end


--
-- From source file: parse_abc.lua
--
-- Grammar for parsing tune definitions
function expand_macros(song, line)
    -- expand any macros in a line   
    local converged = false
    local iterations = 0
    local expanded_line
    
    -- ignore blank lines
    if string.len(line)==0 then return nil end
    expanded_line = apply_macros(song.parse.macros, line)    
    -- macros changed this line; must now re-parse the line
    match = abc_body_parser(expanded_line)
    if not match then
        warn('Macro expansion produced invalid output '..line..expanded_line)
        return nil -- if macro expansion broke the parsing, ignore this line
    end
    
    return match    
    
end

function parse_abc_line(line, song)
    -- Parse one line of ABC, updating the song
    -- datastructure. Temporary state is held in
    -- information from line to line
    line = line:gsub('^[%s]*', '')
                
    -- replace stylesheet directives with I: information fields
    line = line:gsub("^%%%%", "I:")    
    local field_token
    
    
    -- read metadata fields    
    if song.parse.in_header or string.sub(line,2,2)==':' then        
        field_token = parse_field(line, song)
        if field_token then
            -- add cross reference
            if song.parse.cross_ref then
                field_token.cross_ref = {at=1, line=song.parse.line, tune_line=song.parse.tune_line, tune=song.parse.tune, file=song.parse.filename}
            end
           
            table.insert(song.token_stream, field_token)
        end
        if song.parse.found_key and song.parse.in_header then
            song.parse.in_header = false
            -- table.insert(song.token_stream, {token='header_end'})
        end    
    end
         
    --
    -- read tune
    --
    if not field_token and not song.parse.in_header then
        local match
        
        -- make I:linebreak ! work
        if song.parse.linebreaks.exclamation then
            line = line:gsub('!', '$')
        end
        
        if not song.parse.no_expand and (#song.parse.macros>0)  then               
            match = expand_macros(song, line)                
        else
            match = abc_body_parser(line)
        end
                
        -- if it was a tune line, then parse it
        -- (if not, it should be a metadata field)
        if match then                                           
            -- we found tune notes; this isn't a file header
            song.parse.has_notes = true
            
            -- insert linebreaks if there is not a continuation symbol
            -- (only if <eol> is set in the linebreaks (as it is by default))
            if song.parse.linebreaks.eol then
                if  not match[#match].continuation then
                    table.insert(match, {linebreak=''})    
                else
                    table.insert(match, {continue_line=''})    
                end
            end
            
            read_tune_segment(match, song)
        end
    end        
end    


local line_splitter = re.compile([[
lines <- (%nl* ({[^%nl]+} %nl*)+) -> {}
]])

function parse_abc_string(song, str)    
    -- parse an ABC file and fill in the song structure
    -- this is a separate method so that recursive calls can be made to it 
    -- to include subfiles            
    local lines = line_splitter:match(str)    
    if lines then
        for i=1,#lines do        
            song.parse.tune_line = i
            local success, err = pcall(parse_abc_line, lines[i], song)
            if not success then
                warn('Parse error reading line '  .. lines[i].. '\n'.. err)
            end
            song.parse.line = song.parse.line + 1
        end
    end
end
    
function default_user_macros()
    -- return the set of default user macros
    return 
    {
      ['~'] = '!roll!',
      ['.'] = '!staccato!',
      H = '!fermata!',
      L = '!accent!',
      M = '!lowermordent!',
      O = '!coda!',
      P = '!uppermordent!',
      S = '!segno!',
      T = '!trill!',
      u = '!upbow!',
      v = '!downbow!'
    }   
        
end

function parse_abc(str, options, in_header)
    -- parse and ABC file and return a song with a filled in token_stream field
    -- representing all of the tokens in the stream    
    local song = {}        
    song.token_stream = {}
    options = options or {}        
    -- default to being in the header
    if in_header==nil then
        in_header = true
    end
    
    -- set the default parse options (copying in options from <options>)
    song.parse = {in_header=in_header, 
        has_notes=false, 
        macros={}, 
        user_macros=default_user_macros(), 
        measure = options.measure or 1, 
        no_expand=options.no_expand or false, 
        cross_ref=options.cross_ref or false, 
        line=options.line or 1, 
        tune=options.tune or 1, 
        linebreaks={eol=true},
        strict=options.strict or false,
        filename=options.filename or 'fragment'
        }    
    parse_abc_string(song, str)
     
    return song 
end
    
function compile_abc(str, options)
    -- parse an ABC string and compile it
    song = parse_abc(str, options) 
    compile_token_stream(song,  get_default_context(), {})    
    return song
end
    
function get_default_context()
    return   {
    tempo = {tempo_rate=120, [1]={num=1, den=8}}, 
    use_parts = false,
    meter = {num=4, den=4},
    key = { root='C', mode='maj', clef={}},
    key_mapping = {c=0,d=0,e=0,f=0,g=0,a=0,b=0},
    global_transpose = 0,
    voice_transpose = 0,
    grace_length = {num=1, den=32},
    propagate_accidentals = 'pitch',
    accidental = {},
    directives = {},
    broken_ratio=2,
    default_note_length = 8,
    write_abc_events = false
    }
end
    
local section_matcher = re.compile([[
     abc_tunes <- (section (break+ section) * last_line ?) -> {}
     break <- (([ ] * %nl)  )
     section <- { (line +)  }
     line <- ( ([^%nl] +  %nl) )
     last_line <- ( ([^%nl]+) )
    ]] 
)    

function parse_and_compile(tune_str, options, context, metadata)
    -- parse a tune and compile it; returns nil if cannot be parsed or compiled
    local success, tune = pcall(parse_abc,tune_str,options)
    if not success then 
        warn("Could not parse tune beginning: "..string.sub(tune_str, 1, 64)) 
        warn(tune)
        return nil
    end
    local success,err  = pcall(compile_token_stream,tune,context,metadata)
    if not success then 
        warn("Could not compile tune beginning: "..string.sub(tune_str, 1, 64)) 
        warn(err)
        return nil
    end
    return tune
end

function songbook_block_iterator(str, options)
    -- Iterator for iterating through tune blocks in a songbook    
    str = str..'\n'
    return coroutine.wrap( 
        function ()                
        -- tunes must begin with a field (although there
        -- can be directives or comments first)
        local sections = section_matcher:match(str)
         
        -- malformed file
        if not sections or #sections==0 then
            return 
        end
        
        -- only include patterns with a field in them; ignore 
        -- free text blocks
        for i,v in ipairs(sections) do    
            if v:gmatch('\n[a-zA-Z]:') then                            
                coroutine.yield(v)
            end
        end
    end)
    
end


function parse_abc_coroutine(str, options)
    -- Iterator for iterating through tunes in a songbook
    -- This is preferable to just reading the entire thing into an table
    -- as it saves memory.
    -- split file into sections
   
    options = options or {}
    -- set the current line number, for cross referencing
    options.line = 1
    options.tune = 1
    
    local iterator = songbook_block_iterator(str, options)
        
    -- set defaults for the whole tune
    local default_metadata = {}
    local default_context = get_default_context()
    
    local tune_str 
    tune_str = iterator()
    
    if not tune_str then
        return -- no tunes at all
    end
    
    -- first tune might be a file header
    local first_tune = parse_and_compile(tune_str, options, default_context, default_metadata)
    
    -- if no notes, is a global header for this whole file
    if first_tune and not first_tune.parse.has_notes then
        default_metadata = first_tune.metadata
        default_context = first_tune.context
    else
        default_metadata = {}
        default_context = get_default_context()
    end
    
    -- return the first tune
    coroutine.yield(first_tune)
    
    local tune_number = 2
    
    local line 
    if first_tune then
        line = first_tune.parse.line
    end
    
    -- remaining tunes
    tune_str = iterator()
    while tune_str do
        options.tune = tune_number  
        options.line = line
        
        -- parse/compile the tune
        local tune = parse_and_compile(tune_str, options, deepcopy(default_context), deepcopy(default_metadata))
        coroutine.yield(tune)    
        tune_str = iterator()
        
        -- need to keep track of lines across songs for cross referencing
        line = tune.parse.line
        tune_number = tune_number + 1      
    end
end

function parse_abc_song_iterator(str, options)
    -- return an iterator to iterate over songs in a songbook
    return coroutine.wrap(function() parse_abc_coroutine(str, options)end)
end

function parse_abc_multisong(str, options) 
    -- return a table of songs from a songbook
    local songs = {}
    for song in parse_abc_song_iterator(str, options) do
        table.insert(songs, song)
    end
    return songs 
end

function parse_abc_file(filename, options)
    -- Read a file and send it for parsing. Returns the 
    -- corresponding song table.
    local f = io.open(filename, 'r')
    assert(f, "Could not open file "..filename)
    local contents = f:read('*a')
    
    -- store filename for later
    options.filename=filename
    return parse_abc_multisong(contents, options)
end

function parse_abc_fragment(str, options)
    -- Parse a short abc fragment, and return the token stream table    
    options = options or {}    
    local song = parse_abc(str, options, options.in_header or false)
    return song.token_stream
end

function compile_tokens(tokens, context)
    --Converts a token stream from a fragment into a timed event stream
    -- Returns the event stream if this is a single voice fragment, or
    -- a table of voices, if it is a multi-voice fragment
    --    
    context = context or get_default_context()
    
    local song = {token_stream=tokens}
    compile_token_stream(song, context, {})
                
    if #song.voices>1 then
        local voice_stream = {}
        -- return a table of voices
        for i,v in pairs(song.voices) do
            voice_streams[i] = {stream=v.stream, context=v.context}
        end
        return voice_streams
    else    
        -- return the default voice stream
        return song.voices['default'].stream, song.voices['default'].context    
    end
end


-- module exports
local abclua = {
name="abclua",
parse_abc_multisong = parse_abc_multisong,
parse_abc = parse_abc,
parse_abc_fragment = parse_abc_fragment,
compile_tokens = compile_tokens,
parse_abc_file = parse_abc_file,
print_notes = print_notes,
print_lyrics_notes = print_lyrics_notes,
emit_abc = emit_abc,
song_to_opus = song_to_opus,
stream_to_opus = stream_to_opus,
make_midi = make_midi,
make_midi_from_stream = make_midi_from_stream,
trim_event_stream = trim_event_stream,
render_grace_notes = render_grace_notes,
register_directive = register_directive,
abc_from_songs = abc_from_songs,
diatonic_transpose = diatonic_transpose,
get_note_stream = get_note_stream,
get_chord_stream = get_chord_stream,
abc_element = abc_element,
validate_token_stream = validate_token_stream,
filter_event_stream = filter_event_stream,
get_note_number = get_note_number,
get_bpm_from_tempo = get_bpm_from_tempo,
printable_note_name = printable_note_name,
precompile_token_stream = precompile_token_stream,
parse_abc_song_iterator = parse_abc_song_iterator,
scan_metadata = scan_metadata,
songbook_block_iterator = songbook_block_iterator,
version=0.2,
}


-- TODO:

-- Text string encodings
-- Make automatic tune reproduce tester
-- ABCLint -> check abc files for problems

-- MIDI error on repeats with chords (doubles up chords)
-- transposing macros don't work when octave modifiers and ties are applied

-- Q:
-- multiple chords on one note
-- state changes in repeats/parts
-- user macros in symbol lines




--
-- From source file: parse_note.lua
--
-- Functions for parsing and canonicalising notes

local broken_table = {
['<']=-1, 
['<<']=-2, 
['<<<']=-3, 
['<<<<']=-4, 
['<<<<<']=-5, 
['<<<<<<']=-6, 
['>']=1, 
['>>']=2, 
['>>>']=3, 
['>>>>']=4, 
['>>>>>']=5, 
['>>>>>>']=6, 
}

local function canonicalise_duration(duration, broken)
    -- fill in duration field; remove slashes
    -- and fill in numerator and denominator
    
    if duration.slashes and not duration.den then
         local den = 1
         local l = string.len(duration.slashes)
         den = math.pow(2, l)         
         duration.den = den
    end
    
    duration.num = duration.num or 1
    duration.den = duration.den or 1
        
    duration.slashes = nil

    duration.broken = broken_table[broken] or 0
    -- if broken then        
        -- local l = string.len(broken)
        -- local char = string.sub(broken, 1,1)        
        -- if char==">" then duration.broken = l 
        -- elseif char=="<" then duration.broken = -l end        
    -- else
        -- duration.broken = 0
    -- end
end

function canonicalise_accidental(accidental)
    -- Transform string indicator to integer and record any fractional part
    -- (for microtonal tuning)
    local acc = accidental[1]
    local frac_acc = accidental[2]
    local value
    local fraction = {num=1, den=1}

    -- fractional accidentals
    if frac_acc and (frac_acc.num or frac_acc.slashes) then
        canonicalise_duration(frac_acc)
        fraction = frac_acc 
    end
        
    local values = {
    ['^']={num=fraction.num, den=fraction.den},
    ['^^']={num=2*fraction.num, den=fraction.den},
    ['_']={num=-fraction.num, den=fraction.den},
    ['__']={num=-2*fraction.num, den=fraction.den},
    ['=']={num=0, den=0}}
    
    return values[acc]
    
end

function add_chord_or_annotation_note(note, text)
    -- Take a text string; if it's a an annotation, 
    -- add it to the annotations; otherwise, set the chord for this note
    -- Note: each note can only have one chord. Setting a new chord
    -- overwrites the old one.    
    local chord = parse_chord(text) 
        
    if chord then
        -- update chord for this note (only one chord per note)
        note.chord = chord
    else
        -- store free text annotations 
        note.text = note.text or {}
        table.insert(note.text, parse_free_text(text))                
    end
end

function add_decoration_note(note, decoration)
    -- Add a text string as a decoration to a note
    note.decoration = note.decoration or {}
    table.insert(note.decoration, decoration)    
end

function add_lyric_note(note, lyric)
    -- Add a lyric syllable to a note
    note.lyrics = note.lyrics or {}
    table.insert(note.lyrics, lyric)    
end



local function canonicalise_note(note)
    -- Canonicalise a note, filling in the full duration field. 
    -- Remove slashes from the duration
    -- Fills in full duration field
    -- Replaces broken with an integer representing the dotted value (e.g. 0 = plain, 1 = once dotted,
    --  2 = twice, etc.)        
    canonicalise_duration(note.duration, note.broken)        
    
  local pitch = note.pitch
  if pitch then
      -- add octave shifts  
      
        local octave = 0
        if pitch.octave then            
            for c in pitch.octave:gmatch"." do
                if c == "'" then
                    octave = octave + 1
                end
                if c==',' then 
                    octave = octave - 1
                end
            end
        end        
        -- +1 octave for lower case notes
        if pitch.note == string.lower(pitch.note) then
            octave = octave + 1           
        end        
        pitch.note = string.lower(pitch.note)
        pitch.octave = octave        
        if pitch.accidental then
            pitch.accidental  =  canonicalise_accidental(pitch.accidental)
        end
    end
    
    

    local note_chord = note.chord
    note.chord = nil
    -- parse chords
    
    if note_chord then        
        for i,v in ipairs(note_chord) do           
            add_chord_or_annotation_note(note, v)            
        end
    end
         
    return note        
end

function parse_note(note, user_macro)
    -- Clean up a note structure. 
    -- Clean up the duration and pitch of notes and any grace notes
    -- Replace the decoration string with a sequence of decorators
    -- fix the note itself
         
    if note.decoration then        
        -- clean up decorations (replace +xxx+ with !xxx!)    
        for i,v in ipairs(note.decoration) do            
            if string.sub(v,1,1)=='+'  then
                note.decoration[i] = '!'..string.sub(v,2,-2)..'!'
            end
            
            -- apply user macro
            if v:match('^[h-wH-W.~]$') then 
                if user_macro[v] then
                    if string.sub(user_macro[v],1,1)=='"' then                        
                        table.insert(note.chord, user_macro[v])
                    else
                        note.decoration[i] = user_macro[v]
                    end
                end
                
            end
        end        
    end
    
    canonicalise_note(note)        
    
    -- and the grace notes
    if note.grace then
        for i,v in ipairs(note.grace) do
            canonicalise_note(v)
        end
    end
    return note    
end






--
-- From source file: meter_tempo.lua
--


local tempo_matcher = re.compile([[
tempo <- (

    (["] {:name: [^"]* :} ["] %s *) ?
    ( 
    (  (  (div (%s + div) *)  )  %s * '=' %s * {:tempo_rate: number:} )  /
    (  'C=' {:tempo_rate: number:} ) /
    (  {:tempo_rate: number :} ) 
    ) ?
    (%s + ["] {:name: [^"]* :} ["] %s *) ?
) -> {}

div <- ({:num: number:} %s * '/' %s * {:den: number:}) -> {}
number <- ( [0-9] + )
]])

-- standard tempo names
local tempo_names = {
larghissimo=40,
moderato=104,
adagissimo= 44,
allegro= 120,
allegretto= 112,
lentissimo= 48,
largo=        56,
vivace =168,
adagio=59,
vivo=180,
lento=62,
presto=192,
larghetto=66,
allegrissimo=208,
adagietto=76,
vivacissimo=220,
andante=88,
prestissimo=240,
andantino=96
}

function parse_tempo(l)
    -- Parse a tempo string
    -- Returns a tempo table, with an (optional) name and tempo_rate field
    -- tempo_rate is in units per second
    -- the numbered elements specify the unit lengths to be played up to that point
    -- each element has a "num" and "den" field to specify the numerator and denominator
    local captures = tempo_matcher:match(l)        
    if captures and captures.name and not captures.tempo_rate then    
        -- fill in rate / division if we just have a name        
        if tempo_names[string.lower(captures.name)] then
           captures.tempo_rate = tempo_names[string.lower(captures.name)]
           captures[1] = {num=1, den=4}
        end
         
    end
    
    -- default if not filled in
    if not captures.tempo_rate then
         captures = {tempo_rate=120, [1]={num=1, den=8}}
    end
    
    return captures
end

local length_matcher = re.compile("('1' ('/' {[0-9] +}) ?) -> {}")
function parse_length(l)
    -- Parse a string giving note length, as a fraction "1/n" (or plain "1")
    -- Returns integer representing denominator.
    local captures = length_matcher:match(l)             
    if captures and captures[1] then
        return captures[1]+0
    else
        return 1    
    end
end



function get_simplified_meter(meter)
    -- return meter as a simple num/den form
    -- with the beat emphasis separate
    -- by summing up all num elements
    -- (e.g. (2+3+2)/8 becomes 7/8)
    -- the beat emphasis is stored as
    -- emphasis = {1,3,5}

    if meter.common then
        return {num=4, den=4, emphasis={0}}
    end
    
    if meter.cut then
        return {num=2, den=2, emphasis={0}}
    end
    
    if meter.none then
        return {num=0, den=0, emphasis={0}}
    end
    
    local total_num = 0
    local emphasis = {}
    for i,v in ipairs(meter.num) do
        table.insert(emphasis, total_num)
        total_num = total_num + v
    end
    return {num=total_num, den=meter.den, emphasis=emphasis}
end

local meter_matcher = re.compile([[
    meter <- (fraction / cut / common / none) 
    common <- ({:common: 'C' :}) -> {}
    cut <- ({:cut: 'C|' :}) -> {}
    none <- ({:none: 'none' :})  -> {}    
    fraction <- ({:num: complex :} %s * '/' %s * {:den: [0-9]+ :}) -> {}    
    complex <- ( '(' ? ((number + '+') * number) ->{} ')' ? )
    number <- {([0-9]+)}     
    ]])

function parse_meter(m)
    -- Parse a string giving the meter definition
    -- Returns fraction as a two element table
    local captures = meter_matcher:match(m)    
    
    if not captures then
        captures = {none='none'}
    end
    return get_simplified_meter(captures)
    
end




--
-- From source file: register_directives.lua
--
local grace_matcher = re.compile([[ 
    length <- ({:num: (number) :} '/' {:den: (number) :}) -> {}
    number <- ([0-9]+)
    ]])


function directive_set_grace_note_length(song, directive, arguments)
    -- set the length of grace notes
    -- Directive should be of the form I:gracenotes 1/64
    if arguments[1] then
        -- extract ratio
        local ratio = grace_matcher:match(arguments[1])
        if ratio then
            song.context.grace_note_length = {num=ratio.num, den=ratio.den}
        end
    end
    update_timing(song) -- must recompute note lengths
end


function directive_abc_include(song, directive, arguments)
    -- Include a file. We can just directly invoke parse_abc_string() on 
    -- the file contents. The include file must have only one tune -- no multi-tune files
    
    local filename = arguments[1]
    if filename then
        local f = io.open(filename, 'r')            
        song.includes = song.includes or {}
        
        -- disallow include loops!
        if song.includes[filename] then
            return 
        end
        
        -- remember we included this file
        song.includes[filename] = filename
        
        -- check if the file exists
        if f then
            -- and we can read it...
            local contents = f:read('*a')
            if contents then
                -- then recursively invoke parse_abc_string
                parse_abc_string(song, contents)
            end
        end
    end
end

function directive_broken_ratio(song, directive, arguments)
        -- set the broken rhythm ratio
        local p = arguments[2]
        local q = arguments[3] or 1
        song.context.broken_ratio = p/q
end


function directive_propagate_accidentals(song, directive, arguments)
    -- Set the accidental propagation mode. Can be
    -- 'not': do not propagate accidentals
    -- 'ocatave': propagate only within an octave until end of bar
    -- 'pitch': propagate within pitch class until end of bar
    song.context.propagate_accidentals = arguments[1]
end


function directive_enable_bar_warnings(song, directive, arguments)
    -- turn on bar warnings, so that overfull and underfull bars cause
    -- warnings to be printed
    song.context.bar_warnings = true
end

function directive_set_bar_number(song, directive, arguments)
    -- set the current (or first) bar number
    song.parse.measure = tonumber(arguments[1])
end

function directive_linebreak(song, directive, arguments)
    -- set the linebreak symbol
    -- can be list of elements: '$' '!' <EOL>
    -- or can be '<none>'
    if #arguments==1 and arguments[1]:lower()=='<none>' then 
        song.parse.linebreaks = {}
        return
    end
    
    song.parse.linebreaks = {}
    for i,v in ipairs(arguments) do
        local arg = v:lower()
        if arg=='<eol>' then song.parse.linebreaks.eol = true end
        if arg=='$' then song.parse.linebreaks.dollar = true end
        if arg=='!' then song.parse.linebreaks.exclamation = true end       
    end
    
end

register_directive('enable-bar-warnings', directive_enable_bar_warnings)
register_directive('gracenote', directive_set_grace_note_length)
register_directive('abc-include', directive_abc_include, true)
register_directive('linebreak', directive_linebreak, true)
register_directive('broken-ratio', directive_broken_ratio)

register_directive('propagate-accidentals', directive_propagate_accidentals)

register_directive('setbarnb', directive_set_bar_number, true)
register_directive('measurefirst', directive_set_bar_number, true)




--
-- From source file: symbol_line.lua
--
-- functions for dealing with symbol lines

function parse_symbol_line(symbols)
    -- Parse a symbol defintion line
    -- Returns a table containing each symbol and an advance field
    -- Advance can be 1 or "bar"    
    local symbol_list = split(symbols, '%s')
    local all_symbols = {}
    local symbol, advance
    for i,v in ipairs(symbol_list) do       
        symbol = nil
        if v=='|' then symbol = {type='bar', advance='bar'} end
        if v=='*' then symbol = {type='spacer', advance='note'} end
        if v:match('![^!]+!') then symbol = {type='decoration', decoration=v, advance='note'} end
        if v:match('"[^"]+"') then symbol = {type='chord_text', chord_text=v, advance='note'} end        
        if symbol then
            table.insert(all_symbols, symbol)
        end
    end
    
    return all_symbols
end


function merge_symbol_line(tokens)
    -- Merge a symbol lines in a token stream in place.
    -- Adds decorations, chord symbols and free text to note events in the sequence.
        
    local token_ptr = 1     -- index of the current position at which we look for notes to align to
    local last_symbol_index -- index of the last symbol_line token in the stream (use this to check for stacked symbol lines)
    local last_ptr          -- the token_ptr used by the previous symbol_line definition (so we can jump back)
    
    -- move along to the next matching token in the stream
    -- we call this every time we see a symbol in a symbol line
    local function advance_token_ptr(sym)
        while token_ptr<=#tokens do
            local t = tokens[token_ptr].token
            token_ptr = token_ptr + 1
            -- if we match, return the matching token
            if t==sym.advance then return tokens[token_ptr-1] end                    
        end
        return nil -- ran over end of the token list
    end
    -- run through all symbols
    for ix,token in ipairs(tokens) do                        
        if token.token=='symbol_line' then            
            local symbols = token.symbol_line or {}                       
            -- deal with stacked symbols.
            if last_symbol_index==ix-1 then
                -- last token was also a symbol_line; this is te
                -- second, third,... nth line of a stack
                token_ptr = last_ptr                
            else
                -- this is not a stack, or is the first line, so remember
                -- the alignment position
                last_ptr = token_ptr 
            end
           
            -- run through each symbol
            for i,v in ipairs(symbols) do                                                         
                token = advance_token_ptr(v)           
                
                -- attach decorations and text to notes
                if token and token.token=='note' then
                    token.note = copy_table(token.note)
                    if v.type=='decoration' then add_decoration_note(token.note, v.decoration) end                    
                    -- add annotation / change chord (removing quotes)
                    if v.type=='chord_text' then add_chord_or_annotation_note(token.note, string.sub(v.chord_text,2,-2)) end                                                   
                end                
            end 
            last_symbol_index = ix
            -- advance the pointer to this symbol line
            if token_ptr<ix then token_ptr=ix end             
        end
    end
    
end

return abclua