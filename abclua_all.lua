-- ABC Lua single file: autogenerated from source files
-- DO NOT EDIT; regenerate using make_abclua.lua
--
-- 
-- Simple ABC parsing for Lua. This library can read a reasonable
-- subset of ABC and generate tables representing the song structure.
--
-- Requires: 
--     Lua 5.2.1 http://www.lua.org
--     LPeg http://www.inf.puc-rio.br/~roberto/lpeg/
--
-- License: BSD 3 clause license
--  
-- * Copyright (c) 2013, John Williamson
-- * All rights reserved.
-- *
-- * Redistribution and use in source and binary forms, with or without
-- * modification, are permitted provided that the following conditions are met:
-- *     * Redistributions of source code must retain the above copyright
-- *       notice, this list of conditions and the following disclaimer.
-- *     * Redistributions in binary form must reproduce the above copyright
-- *       notice, this list of conditions and the following disclaimer in the
-- *       documentation and/or other materials provided with the distribution.
-- *     * Neither the name of the <organization> nor the
-- *       names of its contributors may be used to endorse or promote products
-- *       derived from this software without specific prior written permission.
-- *
-- * THIS SOFTWARE IS PROVIDED BY <copyright holder> ``AS IS'' AND ANY
-- * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
-- * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
-- * DISCLAIMED. IN NO EVENT SHALL <copyright holder> BE LIABLE FOR ANY
-- * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
-- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
-- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
-- * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
-- * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.**
--

local re = require "re"
local directive_set_bar_number
local directive_enable_bar_warnings
local directive_propagate_accidentals
local directive_broken_ratio
local directive_abc_include
local directive_set_grace_note_length
local parse_meter
local get_simplified_meter
local parse_length
local parse_tempo
local parse_note
local make_note
local canonicalise_note
local canonicalise_accidental
local canonicalise_duration
local compile_tokens
local parse_abc_fragment
local parse_abc_file
local parse_abc_multisong
local get_default_context
local compile_abc
local parse_abc
local parse_abc_string
local parse_abc_line
local expand_macros
local read_tune_segment
local add_note_to_stream
local parse_free_text
local compile_token_stream
local expand_token_stream
local start_new_voice
local reset_bar_time
local reset_timing
local apply_voice_specifiers
local finalise_song
local apply_key
local apply_repeats
local is_compound_time
local update_timing
local get_bpm_from_tempo
local printable_note_name
local chord_case
local canonical_note_name
local get_note_number
local transpose_note_name
local midi_to_frequency
local all_note_table
local midi_note_from_note
local get_semitone
local parse_triplet
local apply_triplet
local update_tuplet_state
local reset_triplet_state
local push_triplet
local update_triplet_ratio
local validate_token_stream
local swap_or_insert
local diatonic_transpose
local diatonic_transpose_note
local abc_from_songs
local emit_abc
local abc_element
local abc_note_element
local abc_bar
local abc_note
local abc_chord
local abc_note_def
local abc_duration
local abc_pitch
local abc_accidental
local abc_triplet
local abc_field
local abc_directive
local abc_new_part
local abc_voice
local abc_lyrics
local abc_note_length
local abc_parts
local abc_part_string
local abc_key
local abc_tempo
local abc_meter
local insert_note
local expand_grace
local compute_duration
local compute_bar_length
local compute_pitch
local default_note_length
local parse_bar
local parse_range_list
local parse_field
local expand_parts
local parse_voice
local parse_parts
local parse_directive
local inject_events
local inject_tokens
local register_directive
local apply_directive
local parse_macro
local apply_macros
local transpose_macro
local transpose_note
local make_midi
local make_midi_from_stream
local song_to_opus
local stream_to_opus
local merge_streams
local get_chord_stream
local note_stream_to_opus
local time_stretch_stream
local transpose_stream
local trim_event_stream
local render_grace_notes
local zero_time_stream
local start_time_stream
local duration_stream
local filter_event_stream
local print_lyrics_notes
local print_notes
local get_note_stream
local time_stream
local test_chords
local voice_chord
local invert_chord
local parse_chord
local is_chord
local transpose_chord
local match_chord
local apply_inversion
local test_lyric_parsing
local insert_lyrics
local insert_lyrics_stream
local parse_lyrics
local compose_parts
local expand_patterns
local start_variant_part
local start_new_part
local add_section
local create_key_structure
local parse_key
local compute_mode
local get_major_keys
local get_major_key
local nth_note_of_key
local swap
local find_first_match
local warn
local is_in
local split
local append_table
local invert_table
local table_print 
local verbose_table_print 
local rtrim
local deepcopy
local copy_table
local set_property
local first_difference_string
local gcd
local repeat_string

--
-- From source file: utils.lua
--

function repeat_string(str, times)
    -- return the concatenation of a string a given number of times
    -- e.g. repeat_string('abc', '3') = 'abcabcabc'
    return string.rep(str, times)       
end

-- return the greatest common divisor of a and b
function gcd(a, b)
  while a ~= 0 do
    a,b = (b%a),a
  end
  return b
end

function first_difference_string(a,b)
    -- Determines where the mismatch in two strings is
    -- Returns the mismatch point or nil is there isn't one
    local mismatch 
    for i=1,string.len(a) do
        if i>string.len(b) or string.sub(a,1,i)~=string.sub(b,1,i) then
            mismatch = i
            break
        end    
    end
    return mismatch
end


-- set a field of the whole table
function set_property(t, key, value)
    for i,v in pairs(t) do
        v[key] = value
    end
end

function copy_table(orig)
    -- shallow copy a table (does not copy the contents)
    local copy = {}
    for i,v in pairs(orig) do
        copy[i] = v
    end
    return copy   
end

-- copy a table completely (excluding metatables)
function deepcopy(orig)
    local orig_type = type(orig)
    local copy
    if orig_type == 'table' then
        copy = {}
        for orig_key, orig_value in next, orig, nil do
            copy[deepcopy(orig_key)] = deepcopy(orig_value)
        end        
    else -- number, string, boolean, etc
        copy = orig
    end
    return copy
end

-- Right trim a string
function rtrim(s)
  local n = #s
  while n > 0 and s:find("^%s", n) do n = n - 1 end
  return s:sub(1, n)
end

-- Print anything - including nested tables
function verbose_table_print (tt, indent, done)
  done = done or {}
  indent = indent or 0
  if type(tt) == "table" then
    for key, value in pairs (tt) do
      io.write(string.rep (" ", indent)) -- indent it
      if type (value) == "table" and not done [value] then
        done [value] = true
        io.write(string.format("[%s] => table\n", tostring (key)));
        io.write(string.rep (" ", indent+4)) -- indent it
        io.write("(\n");
        table_print (value, indent + 7, done)
        io.write(string.rep (" ", indent+4)) -- indent it
        io.write(")\n");
      else
        io.write(string.format("[%s] => %s\n",
            tostring (key), tostring(value)))
      end
    end
  else
    io.write(tt .. "\n")
  end
end

-- Print anything - including nested tables
function table_print (tt, indent, done)
  if tt==nil then
    io.write('nil\n')
    return
  end
  done = done or {}
  indent = indent or 0
  if type(tt) == "table" then
    for key, value in pairs (tt) do
      io.write(string.rep (" ", indent)) -- indent it
      if type (value) == "table" and not done [value] then
        done [value] = true
        io.write(string.format("%s = \n", tostring (key)));
        io.write(string.rep (" ", indent+4)) -- indent it
        io.write("{\n");
        table_print (value, indent + 7, done)
        io.write(string.rep (" ", indent+4)) -- indent it
        io.write("}\n");
      else
        io.write(string.format("%s=%s\n",
            tostring (key), tostring(value)))
      end
    end
  else
    io.write(tt .. "\n")
  end
end

function invert_table(t)
    -- invert a table so that values map to keys
    local n = {}
    for i,v in pairs(t) do
        n[v] = i
    end
    return n
end


function append_table(a, b)
    -- Append b to a. Operates in-place, and returns a copy
    -- of the modified array
    for i,v in ipairs(b) do    
        table.insert(a,v)
    end
    return a
end

-- Compatibility: Lua-5.1
function split(str, pat)
   local t = {}  -- NOTE: use {n = 0} in Lua-5.0
   local fpat = "(.-)" .. pat
   local last_end = 1
   local s, e, cap = str:find(fpat, 1)
   while s do
      if s ~= 1 or cap ~= "" then
	 table.insert(t,cap)
      end
      last_end = e+1
      s, e, cap = str:find(fpat, last_end)
   end
   if last_end <= #str then
      cap = str:sub(last_end)
      table.insert(t, cap)
   end
   return t
end

function is_in(str, tab)
-- return true if str is in the given table of strings
    for i,v in ipairs(tab) do
        if str==v then
            return true
        end
    end
    return false
end


function warn(message)
-- print a warning message
    print(message)
end

function find_first_match(t, match)
    -- Find the first element of t, where all of the given field=value pairs match
    -- or nil, if no match
    local is_match
   for i,v in ipairs(t) do
     is_match = true
     -- check all fields of match
     for j,n in pairs(match) do
        if not v[j] or v[j]~=n then
            is_match = false
        end
     end
     -- if we matched, we found it!
     if is_match then
        return i
    end
   end
   return nil
end

function swap(t, a, b)
    -- swap the indices of t so that t[a] = t[b] and t[b] = t[a]
    local ta, tb = t[a], t[b]
    t[b] = ta
    t[a] = tb
end


--
-- From source file: keys.lua
--
-- Functions for handling key signatures and modes
-- and working out sharps and flats in keys.

-- semitones in the major scale
local major = {'c','d','e','f','g','a','b'}
local key_table = 
{
c = {0,0,0,0,0,0,0},
g = {0,0,0,1,0,0,0},
d = {1,0,0,1,0,0,0},
a = {1,0,0,1,1,0,0},
e = {1,1,0,1,1,0,0},
b = {1,1,0,1,1,1,0},
fs = {1,1,1,1,1,1,0},
cs = {1,1,1,1,1,1,1},
f =  {0,0,0,0,0,0,-1},
bb = {0,0,-1,0,0,0,-1},
eb = {0,0,-1,0,0,-1,-1},
ab = {0,-1,-1,0,0,-1,-1},
db = {0,-1,-1,0,-1,-1,-1},
gb = {-1,-1,-1,0,-1,-1,-1},
cb = {-1,-1,-1,-1,-1,-1,-1},

-- not real keys, but sound correct
as = {0,0,-1,0,0,0,0},
ds = {0,0,-1,0,0,-1,-1},
gs = {0,-1,-1,0,0,-1,-1},
fs = {-1,-1,-1,0,-1,-1,-1},
bs = {-1,-1,-1,-1,-1,-1,-1},
}


local diatonic_scale = {[0]='b', 'c', 'd', 'e', 'f', 'g', 'a', 'b'}
local inverse_diatonic_scale = invert_table(diatonic_scale)

function nth_note_of_key(key, n)
    -- return the nth note of a key (e.g. 2nd note of C is D,
    -- 2nd note of G is A etc.)
    local base = inverse_diatonic_scale[key]
    return diatonic_scale[(base+n) % 7]
end


-- offsets for the common modes
local mode_offsets = {maj=0, min=3, mix=5, dor=10, phr=8, lyd=7, loc=1}

function get_major_key(key)
    -- return the semitones in a given major key
    -- (e.g. C = {0,2,4,5,7,9,11})
    local c_major = {0,2,4,5,7,9,11}
    for i,v in ipairs(key_table[key]) do
        
        local semi = c_major[i] + v
        
        -- wrap to 0-12
        if semi<0 then
            semi = semi + 12
        end
        if semi>12 then
            semi = semi - 12
        end
        c_major[i] = semi
    end
    return c_major
end

function get_major_keys()
    -- return a table mapping key names to semitone values
    local keys = {}
    for i,v in pairs(key_table) do
        keys[i] = get_major_key(i)
    end   
    return keys
end


function compute_mode(offset)
    -- compute a mapping from notes in a given mode to the corresponding major key
    -- e.g. compute_mode(3) gives the relative major keys of each possible minor key
    -- return value is a table mapping from the modal key (e.g. E min) to the 
    -- corresponding major key (e.g. G)
    local notes = {}
    local all_notes = all_note_table()
    for i,v in pairs(all_notes) do
        local new_pitch = canonical_note_name((v+offset)%12)
        notes[i] = new_pitch
    end
    return notes
end


local key_matcher = re.compile([[
    key <- ( {:none: ('none') :} / {:pipe: ('Hp' / 'HP') :} / (
        {:root: ([a-gA-G]) 'b'? '#'? :}  
        (%s * {:mode: (mode %S*):}) ? 
        (%s * {:accidentals: (accidentals):}) ?         
         ({:clef:  ((%s + <clef>) +) -> {}   :})  ?           
        )) -> {} 
    clef <-  (({:clef: clefs :}  / clef_def /  middle  / transpose / octave / stafflines / custom )  ) 
    custom <- ([^:] + ':' [^=] + '=' [%S] +)
    clef_def <- ('clef=' {:clef: <clefs> :} [0-9] ? ({:plus8: (  '+8' / '-8' ) :})  ? ) 
    clefs <- ('alto' / 'bass' / 'none' / 'perc' / 'tenor' / 'treble' )
    middle <- ('middle=' {:middle: <number> :})
    transpose <- (('transpose='/'t=')  {:transpose: <number> :}) 
    octave <- ('octave=' {:octave: <number> :}) 
    stafflines <- ('stafflines=' {:stafflines: <number> :})
    number <- ( ('+' / '-') ? [0-9]+)
    mode <- ( ({'maj'}) / ({'aeo'}) / ({'ion'}) / ({'mix'}) / ({'dor'}) / ({'phr'}) / ({'lyd'}) /
          ({'loc'}) /  ({'exp'}) / ({'min'}) / {'m'}) 
    accidentals <- ( accidental (%s+ accidental) * ) -> {} 
    accidental <- ( {('^^' / '__' / '_' / '^' / '=')} (duration)? {[a-g]}  ) -> {} 
    duration <- ( (({:num: ([1-9] +) :}) ? ({:slashes: ('/' +)  :})?  ({:den: ((  [1-9]+  ) ) :})?))  -> {}

]])

function parse_key(k)
    -- Parse a key definition, in the format <root>[b][#][mode] [accidentals] [expaccidentals]    

    k = k:lower()
    local captures = key_matcher:match(k)
    
    -- normalise the accidentals
    local accidentals = {}
    local value
    if captures.accidentals then    
        for i,v in ipairs(captures.accidentals) do            
            value = canonicalise_accidental(v)
            table.insert(accidentals, {note=v[3],accidental=value})
        end
    end
    captures.accidentals = accidentals
   
    --replace +8 / -8 with a straightforward transpose
    if captures.clef and captures.clef.plus8 then
        if captures.clef.plus8=='-8' then
            captures.clef.octave = (captures.clef.octave or 0) + 1
        else
            captures.clef.octave = (captures.clef.octave or 0) - 1 
        end
        captures.clef.plus8 = nil
    end
    
    -- replace transpose with t
    if captures.clef and captures.clef.t then
        captures.clef.transpose = captures.clef.t
        captures.clef.t = nil
    end
    
    return captures       
end




function create_key_structure(k)
    -- Create a key structure, which lists each note as written (e.g. A or B)
    -- and maps it to the correct semitone in the interval
    
    local key_mapping = {}    
    
    -- default: C major if no signature
    for i,v in pairs(key_table['c']) do                        
            key_mapping[major[i]] = v
    end        
    
    -- none = c major, all accidentals must be specified
    if k.none then
        return key_mapping
    end
    
    -- Pipe notation (Hp or HP): F sharp and G sharp
    if k.pipe then
        for i,v in pairs(key_table['c']) do                        
                key_mapping[major[i]] = v
        end        
        
        key_mapping[1] = 1 -- C sharp
        key_mapping[4] = 1 -- F sharp
                    
    else
        -- find the matching key        
        local root = k.root
        root = root:gsub('#', 's')
        
        -- offset according to mode
        if k.mode then
            -- convert 'm' or 'aeolian' to 'min'
            if k.mode=='aeo'  or k.mode=='m' then
                k.mode = 'min'
            end
            
            -- convert 'ionian' to 'maj'
            if k.mode=='ion' then
                k.mode = 'maj'
            end            
            
            -- get the modal offset
            local modal_root = root            
            
            -- find relative major key -- use sharps and flats from that key
            if mode_offsets[k.mode] then
                local major_mapping = compute_mode(mode_offsets[k.mode])
                root = major_mapping[root] -- get relative major key                        
            end            
        end

        -- map each element of the major scale to the accidental value
        -- (0, 1, or -1)
        for i,v in pairs(key_table[root]) do                        
            key_mapping[major[i]] = v
        end
        
        -- add accidentals to the mapping
        -- these overwrite the key-set values
        if k.accidentals then
            for i,v in pairs(k.accidentals) do
                if v.accidental.num == 0 then
                    key_mapping[v.note] = 0
                else
                    -- we can use fractional accidentals in the key
                    key_mapping[v.note] = v.accidental.num / v.accidental.den
                end
            end
        end
        
                        
    end
    return key_mapping
end




--
-- From source file: parts.lua
--
-- Functions for dealing with parts, repeats and sub-patterns


function add_section(song, repeats)
    -- add the current temporary buffer to the song as a new pattern
    -- repeat it repeat times
    repeats = repeats or 1
        
    if not song.context.in_variant then
        table.insert(song.context.pattern_map, {section=song.opus, repeats=repeats, variants={}})
    else
        table.insert(song.context.pattern_map[#song.context.pattern_map].variants, song.opus)
    end
    
    song.temp_part = {}
    song.opus = song.temp_part
    
end


function start_new_part(song, name)
    -- start a new part with the given name. writes the old part into the part table
    -- and clears the current section
    
    add_section(song, 1) -- add any left over section    
    song.context.part_map[song.context.current_part] = song.context.pattern_map
    song.context.pattern_map = {}
    song.context.current_part = name
    song.context.in_variant = nil
    song.temp_part = {}
    reset_timing(song)
    song.opus = song.temp_part   
end


-- variant tag
local variant_tag = 0



function start_variant_part(song, bar)
    -- start a variant part. The variant specifier indicates the ranges that 
    -- this variant will apply to.
    -- Enters a part called (current_part).N where N is each range this part applies to
    -- and registers the sub-part in the variants table
    
    -- parse the variant list
    local endings = bar.variant_range
    
    -- if we are not already in a variant, record the arent part
    if not song.in_variant_part then
        song.context.parent_part = song.context.current_part
        song.in_variant_part = true
    end
        
    -- generate new ID for this tag
    local part_tag = song.context.parent_part .. '.' .. variant_tag
    start_new_part(song, part_tag)
    variant_tag = variant_tag + 1
    
    -- fill in the variants in the parent part map
    if not song.context.part_map[song.context.parent_part].variants then 
            song.context.part_map[song.context.parent_part].variants = {}
    end
            
    for i,v in ipairs(endings) do
        
        song.context.part_map[song.context.parent_part].variants[v] = part_tag
    end
                
    
    
end

function expand_patterns(patterns)
    -- expand a pattern list table into a single event stream
    local result = {}
    for i,v in ipairs(patterns) do
        
        for i=1,v.repeats do
            -- repeated measures (including single repeats!)
            append_table(result, v.section)    
            
            -- append variant endings
            if #v.variants>=i then
                append_table(result, v.variants[i])    
            
            end
        end
    end
    
    return result        
end



function compose_parts(song)
    -- Compose each of the parts in the song into one single event stream
    -- using the parts indicator. If no parts indicator, just uses the default part
    -- Combines all repeats etc. inside each part into a stream as well
    -- The final stream is a fresh copy of all the events
    
    
    start_new_part(song, nil)
    
    local variant_counts = {}
    
    if song.context.part_sequence then                         
        song.stream = {}        
        for c in song.context.part_sequence:gmatch"." do            
            if song.context.part_map[c] then 
                local pattern = deepcopy(expand_patterns(song.context.part_map[c]))
                append_table(song.stream, pattern)
                
                -- count repetitions of this part
                if not variant_counts[c] then
                    variant_counts[c] = 1
                else
                    variant_counts[c] = variant_counts[c] + 1
                end
                
                -- expand the variants
                local vc = variant_counts[c]
                if song.context.part_map[c].variants and song.context.part_map[c].variants[vc] then
                    -- find the name of this variant ending
                    local variant_part_name = song.context.part_map[c].variants[vc]
                    pattern = deepcopy(expand_patterns(song.context.part_map[variant_part_name]))
                    append_table(song.stream, pattern)
                
                end            
            end
        end        
        
    else
        -- no parts indicator
        song.stream = expand_patterns(song.context.part_map['default'])
    end
    
end






    




--
-- From source file: lyrics.lua
--
-- functions for dealing with lyrics

function parse_lyrics(lyrics)
    -- Parse a lyric definition string
    -- Returns a table containing a sequence of syllables and advance field
    -- each advance field specifies how far to move for the next syllable
    -- either an integer number of notes, or "bar" to wait until the next bar
    -- e.g. 'he-llo wo-rld_ oh~yes | a test___' becomes
    -- { 
    -- {syllable='he', advance=1}
    -- {syllable='llo', advance=1}
    -- {syllable='wo', advance=1}
    -- {syllable='rld', advance=2}
    -- {syllable='oh yes', advance='bar'}
    -- {syllable='a', advance=1}
    -- {syllable='test', advance=4}    
    -- }
    
    -- make escaped dashes into backquotes
    lyrics = lyrics:gsub('\\\\-', '`')

    local lyrics_pattern = [[
    lyrics <- ( (({:syl: <syllable> :} {:br: <break> :}) -> {} *)  {:syl: (<syllable>)  :} -> {} ) -> {}
    break <- ( ( %s +)  / ('-')  )
    
    syllable <- ( ([^%s-] +) )        
    ]]
    
    local match = re.match(lyrics, lyrics_pattern)
    -- empty lyric pattern
    if not match then
        return {}
    end
    
    local lyric_sequence = {}
    
    local next_advance = 1 -- always start on first note of the song
    
    -- construct the syllable sequence
    for i,syllable in ipairs(match) do
        local syl = syllable.syl
        -- fix backquotes
        syl = syl:gsub('`', '-')
        -- note advance on trailing underscore
        local note_count = 1
        for c in syl:gmatch"_" do
            note_count = note_count + 1
        end
        
        local advance = next_advance
        
        -- bar advance
        if string.sub(syl,-1)=='|' then
            next_advance = 'bar'
        else
            next_advance = note_count
        end
        
        -- remove _, ~ and | from the display syllables
        for i,v in ipairs(match) do
            syl = syl:gsub('|', '')        
            syl = syl:gsub('_', '')        
            syl = syl:gsub('~', ' ')        
        end
                
        table.insert(lyric_sequence, {syllable=syl, advance=advance, br=syllable.br})
    end
    return lyric_sequence
end


function insert_lyrics_stream(lyrics, stream, new_stream, stream_index)
    -- Takes a lyrics structure and an event stream, and inserts the lyric
    -- events into the stream accordingly. Returns a new event stream
    -- with the lyrics in place. Lyrics are aligned to lyric_align events in the stream
    local lyric_index = 1
    
    local note_wait 
    local advance = false
    
    -- determine where to wait for the first lyric
    if lyrics[lyric_index] then
        note_wait = lyrics[lyric_index].advance
    else
        note_wait = 'end'
    end
    
    local v
    while stream_index<#stream do    
        v = stream[stream_index]
        
        -- insert original event
        table.insert(new_stream, v)
        
        -- if waiting for a bar, reset on next bar symbol
        if v.event == 'bar' then         
            if note_wait == 'bar' then
                advance = true                
            end
        end
        
        -- note; decrement wait if we're not looking for a bar
        if v.event=='note' then
            if note_wait ~= 'end' and note_wait ~= 'bar' then
                note_wait = note_wait - 1                
                -- wait hit zero; insert the lyric syllable
                if note_wait == 0 then
                    advance = true                                        
                end                
            end            
        end
            
        -- if we've waited long enough, insert the lyric symbol into the stream
        if advance then
            
            table.insert(new_stream, {event='lyric', syllable=lyrics[lyric_index].syllable})
            lyric_index = lyric_index + 1                    
            -- move on the lyric pointer
            if lyric_index > #lyrics then
                note_wait = 'end'
            else
                note_wait = lyrics[lyric_index].advance                
            end
            
            advance = false
        end
        
        -- if we get an align event then return and start on the next lyric segment
        if v.event=='lyric_align' then
            return stream_index
        end
      
        stream_index = stream_index + 1
    end
    
    return stream_index
end


function insert_lyrics(lyrics, stream)
    -- insert a sequence of lyrics into the stream
    -- each lyric line (except the first, which starts at the first note) is aligned with
    -- the corresponding "lyric_align" event in the event stream
    
    local index = 1 -- index into the original stream
    local new_stream = {}
    
    -- insert each lyric line in turn
    for i,v in ipairs(lyrics) do
        index = insert_lyrics_stream(v, stream, new_stream, index)+1
    end
    -- copy in any left over events 
    for i=index, #stream do
        table.insert(new_stream, stream[i])
    end
    return new_stream
end



function test_lyric_parsing()
    -- test the lyrics parser
    local tests = {
    'hello',
    'he-llo',
    'he-llo th-is~a te\\-st___',
    'he-llo wo-rld_ oh~yes | a test___',
    'this is sim-ple~but fine'
    }
    
    for i,v in ipairs(tests) do    
        print(v)
        table_print(parse_lyrics(v))
        print()
    end
    
    
end


--
-- From source file: chords.lua
--
-- Chord handling functions
local chords = 
{
["+2"] = { 0, 2, },
["+3"] = { 0, 4, },
["+4"] = { 0, 6, },
["+b3"] = { 0, 3, },
["5"] = { 0, 7, },
["b5"] = { 0, 6, },
["6sus4(-5)"] = { 0, 6, 9, },
["aug"] = { 0, 4, 8, },
["dim"] = { 0, 3, 6, },
["dim5"] = { 0, 4, 6, },
["maj"] = { 0, 4, 7, },
["min"] = { 0, 3, 7, },
["m"] = { 0, 3, 7, },
["sus2"] = { 0, 2, 7, },
["sus2sus4(-5)"] = { 0, 2, 6, },
["sus4"] = { 0, 6, 7, },
["6"] = { 0, 4, 7, 9, },
["6sus2"] = { 0, 2, 7, 9, },
["6sus4"] = { 0, 6, 7, 9, },
["7"] = { 0, 4, 7, 10, },
["7#5"] = { 0, 4, 8, 10, },
["7b5"] = { 0, 4, 6, 10, },
["7sus2"] = { 0, 2, 7, 10, },
["7sus4"] = { 0, 6, 7, 10, },
["add2"] = { 0, 2, 4, 7, },
["add4"] = { 0, 4, 6, 7, },
["add9"] = { 0, 4, 7, 14, },
["dim7"] = { 0, 3, 6, 9, },
["dim7susb13"] = { 0, 3, 9, 20, },
["madd2"] = { 0, 2, 3, 7, },
["madd4"] = { 0, 3, 6, 7, },
["madd9"] = { 0, 3, 7, 14, },
["mmaj7"] = { 0, 3, 7, 11, },
["m6"] = { 0, 3, 7, 9, },
["m7"] = { 0, 3, 7, 10, },
["m7#5"] = { 0, 3, 8, 10, },
["m7b5"] = { 0, 3, 6, 10, },
["minadd2"] = { 0, 2, 3, 7, },
["minadd4"] = { 0, 3, 6, 7, },
["minadd9"] = { 0, 3, 7, 14, },
["minmaj7"] = { 0, 3, 7, 11, },
["min6"] = { 0, 3, 7, 9, },
["min7"] = { 0, 3, 7, 10, },
["min7#5"] = { 0, 3, 8, 10, },
["min7b5"] = { 0, 3, 6, 10, },
["maj7"] = { 0, 4, 7, 11, },
["maj7#5"] = { 0, 4, 8, 11, },
["maj7b5"] = { 0, 4, 6, 11, },
["maj7sus2"] = { 0, 2, 7, 11, },
["maj7sus4"] = { 0, 6, 7, 11, },
["sus2sus4"] = { 0, 2, 6, 7, },
["6/7"] = { 0, 4, 7, 9, 10, },
["6add9"] = { 0, 4, 7, 9, 14, },
["7s5b9"] = { 0, 4, 8, 10, 13, },
["7s9"] = { 0, 4, 7, 10, 15, },
["7s9b5"] = { 0, 4, 6, 10, 15, },
["7/11"] = { 0, 4, 7, 10, 18, },
["7/13"] = { 0, 4, 7, 10, 21, },
["7add4"] = { 0, 4, 6, 7, 10, },
["7b9"] = { 0, 4, 7, 10, 13, },
["7b9b5"] = { 0, 4, 6, 10, 13, },
["7sus4/13"] = { 0, 6, 7, 10, 21, },
["9"] = { 0, 4, 7, 10, 14, },
["9s5"] = { 0, 4, 8, 10, 14, },
["9b5"] = { 0, 4, 6, 10, 14, },
["9sus4"] = { 0, 7, 10, 14, 18, },
["m maj9"] = { 0, 3, 7, 11, 14, },
["mmaj9"] = { 0, 3, 7, 11, 14, },
["m6/7"] = { 0, 3, 7, 9, 10, },
["m6/9"] = { 0, 3, 7, 9, 14, },
["m7/11"] = { 0, 3, 7, 10, 18, },
["m7add4"] = { 0, 3, 6, 7, 10, },
["m9"] = { 0, 3, 7, 10, 14, },
["m9/11"] = { 0, 3, 10, 14, 18, },
["m9b5"] = { 0, 3, 6, 10, 14, },
["min maj9"] = { 0, 3, 7, 11, 14, },
["minmaj9"] = { 0, 3, 7, 11, 14, },
["min6/7"] = { 0, 3, 7, 9, 10, },
["min6/9"] = { 0, 3, 7, 9, 14, },
["min7/11"] = { 0, 3, 7, 10, 18, },
["min7add4"] = { 0, 3, 6, 7, 10, },
["min9"] = { 0, 3, 7, 10, 14, },
["min9/11"] = { 0, 3, 10, 14, 18, },
["min9b5"] = { 0, 3, 6, 10, 14, },
["maj6/7"] = { 0, 4, 7, 9, 11, },
["maj7/11"] = { 0, 4, 7, 11, 18, },
["maj7/13"] = { 0, 4, 7, 11, 21, },
["maj9"] = { 0, 4, 7, 11, 14, },
["maj9s5"] = { 0, 4, 8, 11, 14, },
}

local common_chords = 
{
["aug"] = { 0, 4, 8, },
["dim"] = { 0, 3, 6, },
["dim5"] = { 0, 4, 6, },
["maj"] = { 0, 4, 7, },
["min"] = { 0, 3, 7, },
["sus2"] = { 0, 2, 7, },
["sus4"] = { 0, 6, 7, },
["6"] = { 0, 4, 7, 9, },
["7"] = { 0, 4, 7, 10, },
["7sus2"] = { 0, 2, 7, 10, },
["7sus4"] = { 0, 6, 7, 10, },
["add2"] = { 0, 2, 4, 7, },
["add4"] = { 0, 4, 6, 7, },
["add9"] = { 0, 4, 7, 14, },
["dim7"] = { 0, 3, 6, 9, },
["madd9"] = { 0, 3, 7, 14, },
["mmaj7"] = { 0, 3, 7, 11, },
["m6"] = { 0, 3, 7, 9, },
["m7"] = { 0, 3, 7, 10, },
["m7#5"] = { 0, 3, 8, 10, },
["m7b5"] = { 0, 3, 6, 10, },
["maj7"] = { 0, 4, 7, 11, },
["maj7#5"] = { 0, 4, 8, 11, },
["maj7b5"] = { 0, 4, 6, 11, },
["9"] = { 0, 4, 7, 10, 14, },
["mmaj9"] = { 0, 3, 7, 11, 14, },
["m6/7"] = { 0, 3, 7, 9, 10, },
["m6/9"] = { 0, 3, 7, 9, 14, },
["m7/11"] = { 0, 3, 7, 10, 18, },
["m7add4"] = { 0, 3, 6, 7, 10, },
["m9"] = { 0, 3, 7, 10, 14, },
["m9/11"] = { 0, 3, 10, 14, 18, },
["m9b5"] = { 0, 3, 6, 10, 14, },
["maj9"] = { 0, 4, 7, 11, 14, },
}


local chord_matcher = re.compile([[
        chord <- ({:root: root :} ({:type: [^/%s] +:}) ? ('/' {:inversion: (<root>/[1-3]) :}) ?) -> {}
        root <- ([a-g] ('b' / 's') ?)
    ]])
    
    
function apply_inversion(inversion, base_pitch, chord_offsets)
    -- apply the inversion
    local notes = {}    
    
    for i,v in ipairs(chord_offsets) do
        -- if inversion, shift the note to the octave below
        if inversion and inversion==(v+base_pitch) % 12 then
             table.insert(notes, v+base_pitch-12)
             inversion = nil -- clear the inversion field so we don't re-add the note
        else               
            table.insert(notes, v+base_pitch)
        end        
    end
    
    -- an inversion which was not in the chord itself
    -- (e.g. Cmaj/F)
    if inversion then
        table.insert(notes, inversion-12)
    end
    return notes
end

function match_chord(chord, custom_table)
    -- Matches chord definitions, returning the root note
    -- the chord type, and the notes in that chord (as semitone offsets)
    -- convert sharp signs to s and lowercase
    -- optionally take a table of custom chord types
    custom_table = custom_table or {}    
    chord = chord:gsub('#', 's')
    chord = string.lower(chord)
           
    local match = chord_matcher:match(chord)
    if not match or not match.root then
        return nil
    end
    
    local base_pitch = get_note_number(match.root)
    local inversion
        
        
    match.type = match.type or 'maj' -- default to major chord    
    local chord_offsets    
        
    local chord_form = custom_table[match.type] or chords[match.type]
    if chord_form  then
        chord_offsets = chord_form
    else    
        return nil -- not a valid chord
    end    
    
    -- get inversion pitch
    if match.inversion then 
        if tonumber(match.inversion) then
            local note = (chord_form[tonumber(match.inversion)] + get_note_number(base_pitch)) % 12
        else
            inversion = get_note_number(match.inversion)
        end       
    end
    
    local notes = apply_inversion(inversion, base_pitch, chord_offsets)       
    return {chord_type=match.type, base_pitch=match.root, offsets=chord_offsets, notes=notes, inversion=canonical_note_name(inversion)}   
end



function transpose_chord(chord, shift)
    -- return a transposed chord name given a string and an integer offset
    -- e.g. transpose_chord('Cm', 4) returns 'Em'     
    
      chord.base_pitch = transpose_note_name(chord.base_pitch, shift)
      -- need to transpose inversions as well
      if chord.inversion then
            chord.inversion = transpose_note_name(chord.inversion, shift)   
      end 
      return chord            
end

function is_chord(str)
    -- Return true if this string is a valid chord identifier
    if match_chord(str) then
        return true
    else
        return false
    end
end


function parse_chord(chord, custom)
    -- parse a chord, returning a chord structure
    return match_chord(chord, custom)    
end

function invert_chord(chord)
-- takes a chord defintion string (e.g. "Gm" or "Fm7" or "Asus2") and returns the notes in it
-- as a table of pitches (with C=0)

    
    local match = chord
    local notes = {}
    local inversion
    if match then  
       inversion = match.inversion      
        for i,v in ipairs(match.notes) do
            -- if inversion, shift the note to the octave below
            if inversion and inversion==(v+match.base_pitch) % 12 then
                 table.insert(notes, v+match.base_pitch-12)
                 inversion = nil -- clear the inversion field so we don't re-add the note
            else               
                table.insert(notes, v+match.base_pitch)
            end
        end
    end
    
    -- an inversion which was not in the chord itself
    -- (e.g. Cmaj/F)
    if inversion then
        table.insert(notes, inversion-12)
    end
    
    return notes
    
end

function voice_chord(notes, octave)
    -- Takes a note sequence for a chord and expands the chord across several octaves
    -- Returns a MIDI note number set
    local octave = octave or 5
    
    local base = octave * 12
    
    local out_notes = {}    

    -- make sure root is in first position
    -- (may not be if chord is inverted)
    table.sort(notes)
    
    -- add original notes
    for i,v in ipairs(notes) do 
        table.insert(out_notes, v+base)
    end
    
    -- root at octave above and below
    local root = notes[1]
    table.insert(out_notes, root+base-12)
    table.insert(out_notes, root+base+12)
    
    -- -- fifth at octave above
    -- if #notes>=3 then
        -- fifth = notes[3]
        -- table.insert(out_notes, fifth+base+12)
    -- end
    
    return out_notes
    
end


function test_chords()
    
    local test_chords = {'Gm', 'G', 'F#min7', 'dM9', 'bbmin', 'Dmin/F', 'Cmaj/E', 'Cmaj/F'}
    for i,v in ipairs(test_chords) do
        print(v)
        table_print(voice_chord(create_chord(v), 5))
        print()
    end   
end




--
-- From source file: stream.lua
--
-- Functions from transforming an raw stream into a timed event stream

function time_stream(stream)
    -- take a stream of events and insert time indicators (in microseconds)
    -- as the t field in each event
    -- Time advances only on notes or rests
    
    local t 
    local in_chord = false
    local max_duration 
    local measure = 1
    local written_measure = 1
    t = 0    
    local last_bar = 0
    local bar_time
    
    for i,event in ipairs(stream) do        
        event.t = t
        
        -- record position of last bar
        if event.event=='bar' and event.bar.type~='variant' then
            last_bar = event.t
            measure = measure + 1
            written_measure = event.bar.meeasure
        end
        
        
        -- now, if we get an overlay, jump time
        -- back to the start of that bar
        if event.event=='overlay' then
            t = last_bar
        end
        
        -- rests and notes
        if event.event=='rest' or event.event=='note' then
            if not in_chord then
                t = t + event.duration
            else
                -- record maximum time in chord; this is how much we will advance by
                if event.duration > max_duration then
                    max_duration = event.duration
                end
            end            
            bar_time = event.bar_time
        end
        
        -- record bar/bar-relative timing
        event.measure = {play_measure = measure, written_measure=measure, bar_time=bar_time}        
        
        -- chord symbols
       
        -- chord starts; stop advancing time
        if event.event=='chord_begin' then
            in_chord = true
            max_duration = 0
        end
        
        if event.event=='chord_end' then
            in_chord = false
            t = t + max_duration -- advance by longest note in chord
        end
       
       
    end
    
    -- make sure events are in order
    --table.sort(stream, function(a,b) return a.t<b.t end)
    
end

function get_note_stream(timed_stream, channel)
    -- Extract all play events from a timed stream, as sequence of note on / note off events
    -- take into account ties in computing note offs
    
   local out = {}
   local notes_on = {}
   
   local channel = channel or 1
   for i,event in ipairs(timed_stream) do        
            if event.event=='note' then                
                if not notes_on[event.pitch] then 
                    table.insert(out, {event='note_on', t=event.t, pitch=event.pitch, channel=channel})
                    notes_on[event.pitch] = true
                end
                
                -- don't insert a note off if the note is tied
                if not event.note.tie then                    
                    table.insert(out, {event='note_off', t=event.t+event.duration-1, pitch=event.pitch, channel=channel})                                    
                    notes_on[event.pitch] = false
                end          
            end
    end
    return out
end


function print_notes(stream)
    -- print out the notes, as a sequence of pitches
    local notes = {}
    
    for i,event in ipairs(stream) do        
        if event.event == 'note' then                      
           table.insert(notes, event.note.pitch.note)
        end
        if event.event == 'rest' then
            table.insert(notes, '~')
        end
        if event.event == 'bar' then
            table.insert(notes, '|')
        end
        if event.event == 'split_line' then
            table.insert(notes, '\n')
        end
    end
    
    print(table.concat(notes))
    
end




function print_lyrics_notes(stream)
    -- print out the notes and lyrics, as a sequence of pitches interleaved with 
    -- syllables
    local notes = {}
    
    for i,event in ipairs(stream) do        
    
        if event.event == 'lyric' then                      
           table.insert(notes, ' "'..event.syllable..'" ')
        end
    
        if event.event == 'note' then                      
           table.insert(notes, event.note.pitch.note)
        end
        if event.event == 'rest' then
            table.insert(notes, '~')
        end
        if event.event == 'bar' then
            table.insert(notes, '|')
        end
        if event.event == 'split_line' then
            table.insert(notes, '\n')
        end
    end
    
    print(table.concat(notes))
    
end



function filter_event_stream(stream, includes)
    -- return a copy of the stream, keeping only those specified events in the stream
    local filtered = {}
    
    if #stream=={} then
        return {}
    end
    
    if type(includes)=='string' then        
        for i,v in ipairs(stream) do
            if v.event==includes then
                table.insert(filtered, v)            
            end
        end       
    end
    
    if type(includes)=='table' then        
        for i,v in ipairs(stream) do
            for j,n in ipairs(includes) do 
                if v.event==n then
                table.insert(filtered, v)            
                end
            end
        end       
    end    
    return filtered   
end

function duration_stream(stream)
    -- return the duration of the stream, from the first event, to
    -- the end of the last note
    if #stream==0 then
        return 0
    end
    
    local end_time = stream[-1].t
    -- must add on duration to avoid chopping last note
    if stream[-1].duration then
        end_time = end_time + stream[-1].duration
    end
    return end_time
end

function start_time_stream(stream)
    -- return the time of the first event
    if #stream==0 then
        return 0
    end    
    return stream[1].t
end

function zero_time_stream(stream)
    -- fix the time of the first element of the stream to t=0, and shift
    -- the rest of the stream to match
    -- Modifies the stream in place -- copy it if you don't want to modify the 
    -- original data
    if #stream=={} then
        return {}
    end
    
    local t = stream[1].t
    for i,v in ipairs(stream) do
        stream.t = stream.t - t
    end    
end




function render_grace_notes(stream)
    -- Return a the stream with grace notes rendered in 
    -- as ordinary notes. These notes will cut into the following note 
    local out = {}
    for i,v in ipairs(stream) do
        if v.event=='note' and v.note.grace then        
            local sequence = v.note.grace.sequence            
            local duration = 0 -- total duration of the grace notes
            for j,n in ipairs(sequence) do                    
                table.insert(out, {event='note', t=duration+v.t, duration=n.duration, pitch=n.pitch, note=n.grace})
                duration = duration + n.duration
            end            
            
            -- cut into the time of the next note, and push it along
            local cut_note = v
            cut_note.duration = cut_note.duration - duration
            
            -- if we manage to cut the note completely then make sure
            -- it doesn't have negative duration
            if cut_note.duration <= 0 then                
                cut_note.duration = 1                
            end
            cut_note.t = cut_note.t + duration
            table.insert(out, cut_note) 
        else
            table.insert(out, v)
        end
    end    
    return out
end


function trim_event_stream(stream,  mode, start_time, end_time)
    -- return a copy of the stream, including only events that fall inside
    -- [start_time:end_time] (given in microseconds)
    -- mode can be = 'starts' which returns event that start in the given period
    --               'ends' which returns events that end in the given period
    --               'any' which returns events that overlap the period at all
    --               'within' which returns that are wholly in the period
    --               'trim' which is like any, but trims notes to fit the given time
    -- start_time and end_time are optional (default to start and end of the tune)   
    
    if #stream=={} then
        return {}
    end
    
    local filtered = {}
    start_time = start_time or nil
    end_time = end_time or duration_stream(stream)         
    
    
    for i,v in ipairs(stream) do
        local start_t = v.t
        local end_t = v.t
        
        -- notes and rests occupy time
        if v.event == 'note' or v.event=='rest' then
            end_t = v.t + v.duration
        end
        
        -- work out if this event starts or stops in this interval
        local start_in = (start_t>=start_time and  start_t<=end_time) 
        local end_in = (end_t>=start_time and end_t<=end_time)
        
        if mode=='any' then
            if start_in or end_in  then
                table.insert(filtered, v)
            end
        end
        
        if mode=='starts' then
            if start_in then
                table.insert(filtered, v)
            end
        end
        
        if mode=='ends' then
            if end_in then
                table.insert(filtered, v)
            end
        end
        
        if mode=='within' then
            if start_in and end_in then
                table.insert(filtered, v)
            end
        end
        
        if mode == 'trim' then
             if start_in or end_in  then
                -- must copy event to avoid changing the original
                local event = deepcopy(v)
                
                -- starts, but is too long
                if start_in and not end_in then
                    event.duration = end_time - event.t
                end
                
                -- starts before, but ends in
                if end_in and not start_in then
                    event.duration = (event.t+event.duration)-start_time
                    event.t = start_time                    
                end
                table.insert(filtered, event)
             end
        end
        
    end
    
    return filtered
end
    

function transpose_stream(stream, semitones)
    -- Transpose events in the stream (only changes the numerical pitch field
    -- see diatonic_transpose() to transpose a token stream with note renaming etc.)
    for i,v in ipairs(stream) do
        if v.event=='note' then 
            v.pitch = v.pitch + semitones
        end
    end    
end
    
    

function time_stretch_stream(stream, factor)
    -- Change the playback rate of the stream (only changes the numerical duration field)
    -- and then retimes
    for i,v in ipairs(stream) do    
        if v.event.duration  then 
            v.duration = v.duration * factor
        end
    end    
    time_stream(stream)
end

function note_stream_to_opus(note_stream)
    -- make sure events are in time order
    table.sort(note_stream, function(a,b) return a.t<b.t end)
    
    local last_t = 0
    local score = {}    
    local dtime
    for i,event in ipairs(note_stream) do
        dtime = (event.t - last_t)/1000.0 -- microseconds to milliseconds
        table.insert(score, {event.event, dtime, event.channel or 1, event.pitch, event.velocity or 127})
        last_t = event.t
    end
    return score
end



function get_chord_stream(stream, octave)
    -- extract all the named chords from a stream (e.g. "Cm7" or "Dmaj") and write 
    -- them in as note events in a stream
   local out = {}
   local notes_on = {}
   local t
   local channel = channel or 1
   octave = octave or 5
   local notes
   
   for i,event in ipairs(stream) do        
        
        if (event.event=='note' and event.note.chord) or event.event=='chord' then                
            local chord = event.note.chord or event.chord
            
            t = event.t
            -- turn off last chord!
            for j, n in ipairs(notes_on) do
                table.insert(out, {event='note_off', t=t, channel})                                           
                notes_on = {}
            end
            
            -- get the notes for this chord and put them in the sequence
            notes = voice_chord(chord.notes, octave)
            for j, n in ipairs(notes) do
                 table.insert(out, {event='note_on', t=t, pitch=n, channel})                           
                 notes_on[n] = true
            end                    
        end
    end
    
    -- turn off last chord
    for j, n in ipairs(notes_on) do
            table.insert(out, {event='note_off', t=t, channel=channel})                                           
            notes_on = {}
    end            
    
    return out 
end


function merge_streams(streams)
    -- merge a list of streams into one single, ordered stream
    local merged_stream = {}
    
    for i,v in pairs(streams) do
        append_table(merged_stream, v)         
    end    
    table.sort(merged_stream, function(a,b) return a.t<b.t end)
    return merged_stream    
end

-- sort out stream functions

function stream_to_opus(stream,  patch)
    -- return the opus form of a single note stream song, with millisecond timing        
    patch = patch or 41 -- default to violin
    local channel = 0
    local note_stream = get_note_stream(stream, channel)
    
     local score = {
        1000,  -- ticks per beat
        {    -- first track
            {'set_tempo', 0, 1000000},
            {'patch_change', 0, channel, patch},            
        },  
     }     
    append_table(score[2], note_stream_to_opus(note_stream))
    return score  
end


function song_to_opus(song, patches)
    -- return the opus form of all the voices song, with millisecond timing
    -- one channel per voice
    
    
    patches = patches or {}
    local channel = 0    
    local merged_stream = {}
    local score = {1000,
        {    
            {'set_tempo', 0, 1000000},     
           {'patch_change', 0,1,1},     
             
        },          
    }    
    -- set the patch for each channel
    local j = 0
    for i,v in pairs(song.voices) do
        if patches[i] then
            table.insert(score[2], {'patch_change', 0, i, patches[i]})
        else
            table.insert(score[2], {'patch_change', 0, j, 1})
        end
        j = j + 1
    end
    
    
    -- merge in each voice
    for i,v in pairs(song.voices) do        
        append_table(merged_stream, get_note_stream(v.stream, channel))         
        channel = channel + 1        
    end
        
   append_table(score[2], note_stream_to_opus(merged_stream))
   
 
   return score
end


function make_midi_from_stream(stream, fname)
    -- Turn a note stream into a MIDI file
     local MIDI = require 'MIDI'

     local opus = stream_to_opus(stream)
     local midifile = assert(io.open(fname,'wb'))
     midifile:write(MIDI.opus2midi(opus))
     midifile:close()
end

function make_midi(song, fname)
    -- make a midi file from a song
    -- merge all of the voices into a single event stream
    local MIDI = require 'MIDI'
    local opus = song_to_opus(song)
    
    local midifile = assert(io.open(fname,'wb'))
    midifile:write(MIDI.opus2midi(opus))
    midifile:close()    
end




--
-- From source file: macro.lua
--
-- subsitution macro handling

-- tables for shifting notes (diatonically)
local transpose_notes = { 
    'C,,', 'D,,', 'E,,', 'F,,', 'G,,', 'A,,', 'B,,',
    'C,', 'D,', 'E,', 'F,', 'G,', 'A,', 'B,',
    'C', 'D', 'E', 'F', 'G', 'A', 'B',
     'c', 'd', 'e', 'f', 'g', 'a', 'b',
     "c'", "d'", "e'", "f'", "g'", "a'", "b'",
     "c''", "d''", "e''", "f''", "g''", "a''", "b''"    
    }
    
local transpose_note_lookup = invert_table(transpose_notes)

function transpose_note(note, offset)
    -- transpose a note (a-g A-G) by the given number of (diatonic) steps
    -- e.g. transpose_note('a', 1) = 'b'
    --      transpose_note('g', 3) = 'c''
    --      transpose_note('E', -1) = 'D'
    
    return transpose_notes[transpose_note_lookup[note]+offset]
end

function transpose_macro(lhs, note, rhs)
    -- create the macro expansion for lhs -> rhs
-- replace n in lhs with note
-- and any letters h..z in rhs with relatively offset pitches

    local lhs = lhs:gsub('n', note)
    local rhs = rhs:gsub('([h-zH-Z])', function (s)
    -- only allow lowercase values
    s = string.lower(s)
    relative = string.byte(s) - string.byte('n')
    return transpose_note(note, relative)
    end)
    return {lhs=lhs, rhs=rhs}
end


function apply_macros(macros, line)
    -- expand macros in the line
    for i,v in ipairs(macros) do
        line = line:gsub(v.lhs, v.rhs)
    end
    return line
end
    
local macro_matcher = re.compile([[
    macro <- (%s * ({:lhs: [^=%s] + :}) %s * '=' %s * ({:rhs: ([^%nl] *) :})) -> {} 
    ]])
    
function parse_macro(macro)
    -- take a raw ABC string block and expand any macros defined it
    -- expansion takes place *before* any other parsing
    local match = macro_matcher:match(macro) 
    return match
    
end



--
-- From source file: directives.lua
--
-- functions for handling custom directives

-- table maps directive names to functions
-- each function takes two arguments: the song structure, and an argument list from
-- the directive (as a table)
local directive_table = {}


function apply_directive(song, directive, arguments)
    -- Apply a directive; look it up in the directive table,
    -- and if there is a match, execute it    
    if directive_table[directive] then        
        directive_table[directive].fn(song, directive, arguments, directive_table[directive].user)
    end
    
    -- record all directives in the context
    if song.context then
       song.context.directives[directive] = song.context.directives[directive] or {}
       table.insert(song.context.directives[directive], arguments)
    end

end

function register_directive(directive, fn, parse, user)
    -- Register a user directive. Will call fn(song, directive, arguments) when
    -- the given directive is found. If parse is true, this directive is executed at parse time
    -- (e.g. to insert new tokens into the stream)    
    -- user can represent user data to be passed to the function on execution
        directive_table[directive] = {fn=fn, parse=parse, user=user}    
    
end

function inject_tokens(song, tokens)
    -- insert tokens immediately after current point
    for i,v in ipairs(tokens) do
        table.insert(song.token_stream, v)
    end
end


function inject_events(song, events)
    -- add events to the opus (to be called from directives)
    for i,v in ipairs(events) do
        table.insert(song.opus, v)
    end
end

function parse_directive(directive)
    -- parse a directive into a directive, followed by sequence of space separated directives
    -- returns true if this directive must be executed at parse time (e.g. abc-include)
    local directive_pattern = [[
    directives <- (%s * ({:directive: %S+ :} ) %s+ ?  {:arguments: ( ({%S+} %s +) * {%S+}  )? -> {}  :} )  -> {}
    ]]
    
    local match = re.match(directive, directive_pattern)
  
    if match and directive_table[match.directive] and directive_table[match.directive].parse then       
        return true, match
    else
        return false, match
    end
    
end



--
-- From source file: fields.lua
--
-- Routines for parsing metadata in headers and inline inside songs

-- create the various pattern matchers

local fields = {}
fields.key = [[('K:' {.*} ) -> {}]]
fields.title = [[('T:' %s * {.*}) -> {}]]
fields.ref =  [[('X:' %s * {.*}) -> {}]]
fields.area =  [[('A:' %s * {.*}) -> {}]]
fields.book =  [[('B:' %s * {.*}) -> {}]]
fields.composer =  [[('C:' %s * {.*}) -> {}]]
fields.discography =  [[('D:' %s * {.*}) -> {}]]
fields.file =  [[('F:' %s * {.*}) -> {}]]
fields.group =  [[('G:' %s * {.*}) -> {}]]
fields.history =  [[('H:' %s * {.*}) -> {}]]
fields.instruction =  [[('I:' %s * {.*}) -> {}]]
fields.length =  [[('L:' %s * {.*}) -> {}]]
fields.meter =  [[('M:' %s * {.*}) -> {}]]
fields.macro =  [[('m:' %s * {.*}) -> {}]]
fields.notes =  [[('N:' %s * {.*}) -> {}]]
fields.origin =  [[('O:' %s * {.*}) -> {}]]
fields.parts =  [[('P:' %s * {.*}) -> {}]]
fields.tempo =  [[('Q:' %s * {.*}) -> {}]]
fields.rhythm =  [[('R:' %s * {.*}) -> {}]]
fields.remark =  [[('r:' %s * {.*}) -> {}]]
fields.source =  [[('S:' %s * {.*}) -> {}]]
fields.symbolline =  [[('s:' %s * {.*}) -> {}]]
fields.user =  [[('U:' %s * {.*}) -> {}]]
fields.voice =  [[('V:' %s * {.*}) -> {}]]
fields.words =  [[('w:' %s * {.*}) -> {}]]
fields.end_words =  [[('W:' %s * {.*}) -> {}]]
fields.transcriber =  [[('Z:' %s * {.*}) -> {}]]
fields.continuation =  [[('+:' %s * {.*}) -> {}]]


-- compile field matchers
for i,v in pairs(fields) do
    fields[i] = re.compile(v)
end

local parts_matcher = re.compile(
[[
    parts <- (part +) -> {}
    part <- ( ({element}  / ( '(' part + ')' ) )  {:repeat: [0-9]* :}) -> {}    
    element <- [A-Za-z]    
    ]])
    
function parse_parts(m)
    -- Parse a parts definition that specifies the parts to be played
    -- including any repeats
    -- Returns a fully expanded part list
    
    local captures = parts_matcher:match(m)
    
    return captures
    
end


local voice_matcher = re.compile([[
    voice <- (({:id: [%S]+ :}) %s * {:specifiers: (<specifier> *) -> {} :}) -> {}
    specifier <- (%s * {:lhs: ([^=] +) :} + '=' {:rhs: [^%s]* :}) -> {} 
    ]])

function parse_voice(voice)
    -- Parse a voice definition string
    -- Voices of the form V:ID [specifier] [specifier] ...
    -- Returns a table with an ID and a table as used for keys
    -- e.g. V:tenor becomes {id="tenor"}
    
    local parsed_voice = voice_matcher:match(voice)
    return parsed_voice
end



function expand_parts(parts)
    -- Recurisvely expand a parts table into a string
    -- Input is a table with entries which are either an array of tables or
    -- a table with entries [1] = terminal, repeat = repeat count
    local reps = parts['repeat']
    local r
    if not reps or reps=='' then
        r = 1
    else
        r = reps + 0
    end
   
    local sym = ''
    local    t=''
    local i,v
    for i,v in ipairs(parts) do
    
        -- terminal symbol
        if type (v) == "string" then
            t =  t..v
        else
            -- recursive part (i.e. a nested group)
            t = t..expand_parts(v)
        end
    end
    
    -- repeat whatever we got as many times as required
    for i = 1, r do
            sym = sym .. t
    end
       
    return sym
end




function parse_field(f, song, inline)
    -- parse a metadata field, of the form X: stuff
    -- (either as a line on its own, or as an inline [x:stuff] field
     local name, field, match, field_name, content
          
     -- find matching field
     local field_name = nil
     for name, field in pairs(fields) do
        match = field:match(f)         
        if match then
            field_name = name
            content = match[1]                
        end
     end
     
            
     -- not a metadata field at all
     if not field_name then
        -- in the header, treat lines without a tag as continuations
        if song.parse.in_header then
            field_name = 'continuation' 
            content = f                
        else
            -- otherwise it was probably a tune line
            return false
        end
     end    
        
    local token
   
    local parsable = {'length', 'tempo', 'parts', 'meter', 'words', 'key', 'macro', 'user', 'voice', 'instruction'} -- those fields we parse individually
    local field = {name=field_name, content=content}
    -- continuation
    if field_name=='continuation' then
        if song.parse.last_field then
            -- append plain text if necessary
            if not is_in(song.parse.last_field, parsable) then            
                token = {token='append_field_text', name=song.parse.last_field, content=content}                
            end
            
             if song.parse.last_field=='words' then
                 token = {token='words', lyrics=parse_lyrics(content)}
             end
         end
         
    else
        -- if not a parsable field, store it as plain text
    
        song.parse.last_field = field_name
        if not is_in(field_name, parsable) then
            token =  {token='field_text', name=field_name, content=content}
        end

    end
    
    
    -- update specific tune settings
    if field_name=='length' then
        token = {token='note_length', note_length=parse_length(content)}
    end
            
    -- update tempo
    if field_name=='tempo' then            
        token = {token='tempo', tempo=parse_tempo(content)}
    end
    
    -- parse lyric definitions
    if field_name=='words' then                        
         token = {token='words', lyrics=parse_lyrics(content)}           
    end
    
     -- parse lyric definitions
    if field_name=='instruction' then                       
         local parse_time, directive = parse_directive(content)
         -- must execute parse time directives immediately
         
         if parse_time and not song.parse.no_expand then
            apply_directive(song, directive.directive, directive.arguments)
         else
            -- otherwise defer
            token = {token='instruction', directive=directive}           
         end
    end
            
     -- parse voice definitions
    if field_name=='voice' then  
        -- in the header this just sets up the voice properties
        if song.parse.in_header then
            token = {token='voice_def', voice=parse_voice(content)}
        else
            token = {token='voice_change', voice=parse_voice(content)}
        end
    end
      
   
    if field_name=='parts' then            
        -- parts definition if we are still in the header
        -- look up the parts and expand them out
        if song.parse.in_header then
            local parts = content:gsub('\\.', '') -- remove dots
            parts = parse_parts(content)
            token = {token='parts', parts=parts}           
        else
            
            -- otherwise we are starting a new part   
            -- parts are always one character long, spaces and dots are ignored
            local part = content:gsub('%s', '')
            part = part:gsub('\\.', '')
            part = string.sub(part,1,1)
                        
            token = {token='new_part', part=part}           
        end
    end
    
    
    if field_name=='user' then
        -- user macro (not transposable)
        if song.parse.no_expand then
            token = {token='field_text', name='user', content=content}                   
        else        
            table.insert(song.parse.user_macros, parse_macro(content))
        end
    end
    
    if field_name=='macro' then
        if song.parse.no_expand then
            token = {token='field_text', name='macro', content=content}                   
        else
            -- we DON'T insert macros into the token_stream. Instead
            -- we expand them as we find them
            local macro = parse_macro(content)
            
            -- transposing macro
            if re.find(macro.lhs, "'n'") then
                local notes = {'a', 'b', 'c', 'd', 'e', 'f', 'g'}             
                local note                   
                -- insert one macro for each possible note
                for i,v in ipairs(notes) do
                    table.insert(song.parse.macros, transpose_macro(macro.lhs, v, macro.rhs)) 
                    table.insert(song.parse.macros, transpose_macro(macro.lhs, string.upper(v), macro.rhs))                                                    
                end
            else
                -- non-transposing macro
                table.insert(song.parse.macros, macro)
            end
        end
    end
    
    -- update meter
    if field_name=='meter' then            
        token = {token='meter', meter=parse_meter(content)}           
    end       
    
    -- update key
    if field_name=='key' then            
        token = {token='key', key=parse_key(content)}
        song.parse.found_key = true -- key marks the end of the header
    end
    
    if token then
        token.inline = inline
        token.is_field = true
        table.insert(song.token_stream, token)
    end
    
    return true
 
end




--
-- From source file: bar.lua
--
local range_matcher = re.compile([[
    range_list <- ((<range>) (',' <range>) *) -> {}
    range <- (   <range_id> / <number> ) -> {}
    range_id <- (<number> '-' <number>)
    number <- ({ [0-9]+ }) 
    ]])

function parse_range_list(range_list)
    -- parses a range identifier
    -- as a comma separated list of numbers or ranges
    -- (e.g. "1", "1,2", "2-3", "1-3,5-6")
    -- Returns each value in this range
    
    local matches = range_matcher:match(range_list)    
    local sequence = {}    
    -- append each element of the range list
    for i,v in ipairs(matches) do
        -- single number
        if #v==1 then
            table.insert(sequence, v[1]+0)
        end
        
        -- range of values
        if #v==2 then            
            for j=v[1]+0,v[2]+0 do
                table.insert(sequence, j)
            end
        end    
    end
    
    
    return sequence

end


local bar_matcher = re.compile([[bar <- (  
        {:mid_repeat: <mid_repeat> :} /  {:end_repeat: <end_repeat> :}  / {:start_repeat: <start_repeat> :} / {:double: <double> :}
        /  {:thickthin: <thickthin> :} / {:thinthick: <thinthick> :} /  {:plain: <plain> :} / {:variant: <variant> :} / {:just_colons: <just_colons> :} ) -> {}        
        mid_repeat <- ({}<colons> {}(<plain>+){} <colons>{}) -> {}
        start_repeat <- (<plain> {} <colons> {} ) -> {}
        end_repeat <- ({}<colons> {} <plain> ) -> {}
        just_colons <- ({} ':' <colons>  {}) -> {}
        plain <- ('|')
        thickthin <- (('[' / ']') '|')
        thinthick <- ('|' ('[' / ']') )
        double <- ('|' '|')
        
        variant <- ('[')
        colons <- (':' +) 
]])

function parse_bar(bar, song)
-- Parse a bar symbol and repeat/variant markers. Bars can be
-- plain bars (|)
-- bars with thick lines (][)
-- repeat begin (|:)
-- repeat end (:|)
-- repeat middle (:||: or :: or :|:)
-- variant markers [range
   local type_info = bar_matcher:match(bar.type)
    
    -- compute number of colons around bar (which is the number of repeats of this section)
    if type_info.mid_repeat then
        type_info.end_reps = type_info.mid_repeat[2]-type_info.mid_repeat[1]
        type_info.start_reps = type_info.mid_repeat[4]-type_info.mid_repeat[3]
    end
    
    if type_info.end_repeat then
        type_info.end_reps = type_info.end_repeat[2]-type_info.end_repeat[1]        
    end
    
    -- thick bars work like repeats with a count of one
    if type_info.thickthin or type_info.thinthick or type_info.double then
        type_info.end_reps = 0
        type_info.end_repeat = true
    end
    
    if type_info.start_repeat then
        type_info.start_reps = type_info.start_repeat[2]-type_info.start_repeat[1]        
    end        
    
    -- for a colon sequence, interpret :: as one start end repeat, :::: as two start, two end, etc.
    -- odd colon numbers without a bar symbol don't make sense!
    if type_info.just_colons then
       
        type_info.start_reps = type_info.just_colons[2]-type_info.just_colons[1] / 2
        type_info.start_reps = type_info.just_colons[4]-type_info.just_colons[3] / 2
        type_info.mid_repeat = type_info.just_colons -- this is a mid repeat
        type_info.just_colons = nil
    end
    
    
    local bar_types = {'mid_repeat', 'end_repeat', 'start_repeat', 'variant',
    'plain', 'double', 'thickthin', 'thinthick'}
    
    local parsed_bar = {}
    
    -- set type field
    for i,v in ipairs(bar_types) do
        if type_info[v] then
            parsed_bar.type = v
        end
    end
    
    -- convert ranges into a list of integers
    if bar.variant_range then     
         parsed_bar.variant_range = parse_range_list(bar.variant_range)
    end
    
    parsed_bar.end_reps = type_info.end_reps
    parsed_bar.start_reps = type_info.start_reps
    
    
    
    return parsed_bar           
end




--
-- From source file: notes.lua
--
-- Functions for compiling notes in context (e.g. computing duration and pitch)

function default_note_length(song)
    -- return the default note length
    -- if meter.num/meter.den > 0.75 then 1/8
    -- else 1/16
    if song.context.meter then
        local ratio = song.context.meter.num / song.context.meter.num
        if ratio>=0.75 then
            return 8
        else
            return 16
        end
    end
    return 8
end

function compute_pitch(note, song)
    -- compute the real pitch (in MIDI notes) of a note event
    -- taking into account: 
    --  written pitch
    --  capitalisation
    --  octave modifier
    --  current key signature
    --  accidentals
    --  transpose and octave shift
    
    -- -1 indicates a rest note
    if note.rest or note.measure_rest or note.space then
        return nil
    end
    
    local accidental
    
    -- in K:none mode or propagate-accidentals is off, 
    -- accidentals don't persist until the end of the bar. 
    if song.context.key.none or song.context.propagate_accidentals=='not' then
        -- must specify accidental as there is no key mapping
        accidental = note.pitch.accidental or {num=0, den=0}
    else
        local accidental_key 
        -- in 'octave' mode, accidentals only propagate within an octave
        -- otherwise, they propagate to all notes of the same pitch class
        if song.context.propagate_accidentals=='octave' then
           accidental_key = note.pitch.octave..note.pitch.note
        else
           accidental_key = note.pitch.note
        end
        
        -- get the appropriate accidental
        if note.pitch.accidental then
            song.context.accidental[accidental_key] = note.pitch.accidental
            accidental = note.pitch.accidental
        else
            accidental = song.context.accidental[accidental_key]
        end            
    end    
    local base_pitch
    base_pitch = midi_note_from_note(song.context.key_mapping, note, accidental)                
    base_pitch = base_pitch + song.context.global_transpose + song.context.voice_transpose
    return base_pitch 
end

function compute_bar_length(song)
    -- return the current length of one bar
    local note_length = song.context.note_length or default_note_length(song)
    return (song.context.meter.num / song.context.meter.den) * note_length * song.context.timing.base_note_length * 1e6 
end

function compute_duration(note, song)
    -- compute the duration (in microseconds) of a note_def
    
    -- takes into account:
    -- tempo 
    -- note length
    -- triplet state 
    -- broken state
    -- duration field of the note itself
    -- bars for multi-measure rests  
    
    if note.space then return 0 end
    
    -- we are guaranteed to have filled out the num and den fields
    local length = note.duration.num / note.duration.den
    
    
    -- measure rest (duration is in bars, not unit lengths)
    if note.measure_rest then   
        -- one bar =  meter ratio * note length (e.g. 1/16 = 16)
        return compute_bar_length(song) *  length
    end
    
    
    local shift = 1
    local this_note = 1
    local next_note = 1
    
    local prev_note = 1
    
    -- take into account previous dotted note, if needed
    if song.context.timing.prev_broken_note then
        prev_note = song.context.timing.prev_broken_note
    else
        prev_note = 1
    end
    
    -- deal with broken note information
    -- a < shortens this note by 0.5, and increases the next by 1.5
    -- vice versa for >
    -- multiple > (e.g. >> or >>>) lengthens by 1.75 (0.25) or 1.875 (0.125) etc.
    if note.duration.broken then
        shift = math.pow(song.context.broken_ratio, math.abs(note.duration.broken))
        
        if shift<0 then
            this_note = 1.0 / -shift
            next_note = 1.0 + 1 - (1.0 / -shift)
        else
            this_note = 1.0 + 1 - (1.0 / shift)
            next_note = (1.0 / shift)
        end
        
        -- store for later
        song.context.timing.prev_broken_note = next_note
    else
        song.context.timing.prev_broken_note = 1
    end
        
    length = length * song.context.timing.base_note_length * this_note * prev_note * 1e6 * song.context.timing.triplet_compress
   
  
    return length   
end


function expand_grace(song, grace_note)
    -- Expand a grace note sequence 
    -- grace notes have their own separate timing (i.e. no carryover of
    -- broken note state or of triplet state)
    
    -- preserve the timing state
    local preserved_state = deepcopy(song.context.timing)
    
    song.context.timing.prev_broken_note = 1
    reset_triplet_state(song)
       
    local grace = {}
    
    for i,v in ipairs(grace_note) do
        local note_def = v
        local pitch = compute_pitch(note_def, song)
        local duration = compute_duration(note_def, song)
        table.insert(grace, {pitch=pitch, duration=duration, grace=note_def})
    end
    
    -- restore timing state
    song.context.timing = preserved_state
    
    -- insert the grace sequence   
    return grace

end
    
    



function insert_note(note, song)
        -- insert a new note into the song
        local note_def = note
        local pitch = compute_pitch(note_def, song)
        local duration = compute_duration(note_def, song)
       
        -- insert grace notes before the main note, if there are any
        if note.grace then
            note.grace.sequence = expand_grace(song, note.grace) 
        end
        
        -- extract any chords into a separate event
        if note.chord then
            table.insert(song.opus, {event='chord', chord=note.chord})
        end
      
        -- insert the note events
        if pitch==nil then
            -- rest            (strip out 0-duration y rests)
            if duration>0 then
                table.insert(song.opus, {event='rest', duration=duration, bar_time = song.context.timing.bar_time,
                note=note})    
            end            
        else       
            -- pitched note
            table.insert(song.opus, {event='note', pitch=pitch, bar_time = song.context.timing.bar_time, duration=duration, note = note})
            
        end
    
        update_tuplet_state(song)
   
        
        -- advance bar time (in fractions of a bar)
        song.context.timing.bar_time = song.context.timing.bar_time + duration / song.context.timing.bar_length
end



--
-- From source file: emit_abc.lua
--
-- functions for writing out text represenatations of the song token_stream
local field_tags = {key = 'K'
,title = 'T'
,ref =  'X'
,area =  'A'
,book =  'B'
,composer =  'C'
,discography =   'D'
,file =   'F'
,group =   'G'
,history =   'H'
,instruction =   'I'
,length =   'L'
,meter =   'M'
,macro =   'm'
,notes =   'N'
,origin =   'O'
,parts =   'P'
,tempo =   'Q'
,rhythm =   'R'
,remark =  'r'
,source =   'S'
,symbolline =   's'
,user =   'U'
,voice =   'V'
,words =  'w'
,end_words =  'W'
,transcriber =  'Z'
,continuation =  '+'
}

function abc_meter(meter)
    -- return the string representation of a meter
    -- e.g. {num=3, den=4} becomes 'M:3/4'
    -- if there is an explicit emphasis then this produces
    -- a compound numerator (e.g. M:(2+3+2)/4)
    local num = ''
    
    -- free meter
    if meter.num==0 and meter.den==0 then
        return 'M:none'
    end
    
    if #meter.emphasis==1 then
        -- simple meter
        num = meter.num
    else
        -- join together complex meters from the empahsis table
        local e = 0
        num = '(' -- parenthesise complex meters
        for j,n in ipairs(meter.emphasis) do
           if j ~= 1 then -- first emphasis is always on 0; skip that
            num = num .. (n-e) .. '+'
            e = n
           end
        end
        
        -- length of last emphasis is however much to make up
        -- to the total meter length
        num = num .. (meter.num-e) .. ')'
           
    end
   
    local ret = string.format('M:%s/%s' , num, meter.den..'')
    return ret
    
end

function abc_tempo(tempo)
    -- return the string represenation of a tempo definition
    -- e.g. Q:1/4=120 or Q=1/2 1/4 1/2=80 "allegro"
    local q = ''
    
    if not tempo[1] then
        -- tempo without length indicator
        q = ''..tempo.tempo_rate
    else
    
        -- abc out the tempo units
        for i,v in ipairs(tempo) do
            q = q .. string.format('%s/%s ', v.num..'', v.den..'')
        end
        
        -- strip trailing space
        q = string.sub(q, 1, -2)
        
        -- the rate as =140
        q = q .. '=' .. tempo.tempo_rate
    end
        
    -- tempo names (e.g. "allegro")
    if tempo.name then
        q = q .. ' "' .. tempo.name .. '"'
    end
    
   return string.format('Q:%s', q)
end

function abc_key(key)
    -- return the string representation of a key 
    local clef = ''
    local acc = ''
    
    -- no key
    if key.none then
        return 'K:none' 
    end
    
    if key.pipe then
        return 'K:HP'
    end
    
    -- root and modal modifier
    local root = string.upper(string.sub(key.root,1,1)) .. string.sub(key.root,2,-1)    
    
    if key.mode then     
        root = root .. key.mode
    end

    -- accidentals
    if key.accidentals then
        acc = ''
        for i,v in ipairs(key.accidentals) do
            acc = acc .. ' '.. abc_accidental(v.accidental)..v.note
        end
    end
    
    -- handle clef modifiers 
    if key.clef then
        clef = ' '
        -- alto, treble, etc. as a bare string
        if key.clef.clef then
            clef = clef .. key.clef.clef
        end
        
        -- other settings (e.g. transpose=3) are in
        -- key=value format
        for i,v in pairs(key.clef) do
            if i ~= 'clef' then
                clef = clef .. string.format(' %s=%s',i,v..'')
            end
        end
    end
    
    return string.format('K:%s%s%s', root , acc, clef )
end

function abc_part_string(part_table)
    -- return the string representation of a parts table
    local ret = ''
    for i,v in  ipairs(part_table) do
        -- simple part
        if type(v[1])=='string' then
            ret = ret .. v[1]
        end
        
        -- sub part (e.g A(BC)2A)
        if type(v[1])=='table' then
            ret = ret .. '(' .. abc_part_string(v) .. ')'
        end
        
        
        -- repeats
        if v['repeat'] and string.len(v['repeat'])>0 and (0+v['repeat']) > 1 then
            ret = ret .. v['repeat']
        end
    end
    return ret
   
end

function abc_parts(parts)
    -- return the string representation of a parts structure
    return 'P:'..abc_part_string(parts)
end

function abc_note_length(note_length)
    return 'L:1/' .. note_length
end

function abc_lyrics(lyrics)
    -- return the ABC string for a given lyric structure
    -- lyrics should have:
    --    syllable field giving the syllable
    --    br field giving the break symbol ('-' or ' ')
    --    advance field giving the number of notes to advance to the next syllable
    local lyric_string = {}
    local next_advance
    for i,v in ipairs(lyrics) do
        local syl = v.syllable
        
        -- escape characters (unbreakable space and dash)
        syl = syl:gsub(' ', '~')
        syl = syl:gsub('-', '\\-')
        table.insert(lyric_string, syl)
        
        -- advance will be from the next symbol
        if #lyrics>i then
            next_advance = lyrics[i+1].advance
        else
            next_advance = 1
        end
        
        -- abc in holds (either syllable holds with _ or bar hold with |)
        if next_advance  then
            if next_advance=='bar' then 
                table.insert(lyric_string, '|')
            elseif next_advance>1 then
                for i=2,next_advance do
                    table.insert(lyric_string, '_')
                end
            end
        end
        
        -- insert the break symbol (' ' or '-')
        table.insert(lyric_string, v.br)
    end
    return 'w:'..table.concat(lyric_string)
end


function abc_voice(voice)
    -- return the ABC string represenation of a voice. Has
    -- an ID, and a set of optional specifiers 
    local str = 'V:'..voice.id
    
    for i,v in ipairs(voice.specifiers) do
        str = str..' '..v.lhs..'='..v.rhs
    end
    
    return str
    
end

function abc_new_part(part)
    -- return the abc definition of a new part
    return 'P:'..part
end


function abc_directive(directive, inline)
    -- Return the ABC notation for a directive (I: or %%)
    -- Uses %% for all non-standard directives and I: only
    -- for standard ones. Forces I: if in inline mode
    local standard_directives = {'abc-charset', 'abc-version', 'abc-include', 'abc-creator'}
    local str
    
    if not directive then
        return ''
    end
    
    if is_in(directive.directive, standard_directives) or inline then
        str = 'I:'..directive.directive
    else
         str = '%%'..directive.directive
    end
    
    -- append space separated arguments
    for i,v in ipairs(directive.arguments) do
        str = str .. ' ' .. v
    end
    return str
end

function abc_field(v, inline)
    -- abc out a field entry (either inline [x:stuff] or 
    -- as its own line 
    -- X:stuff
    
    local str
    
    -- plain text tokens
    if v.token=='append_field_text' then 
        str =  '+' .. ':' .. v.content
    end
    
    if v.token=='field_text' then 
        str = field_tags[v.name] .. ':' .. v.content
    end
    
    -- key, tempo, meter
    if v.token=='meter' then
        str = abc_meter(v.meter)
    end
 
    -- voice definitions
    if v.token=='voice_def' or v.token=='voice_change' then
        str = abc_voice(v.voice)
    end
  
 
    if v.token=='key' then
        str = abc_key(v.key) 
    end

    if v.token=='tempo' then
        str = abc_tempo(v.tempo)
    end
    
    if v.token=='instruction' then
        str = abc_directive(v.directive, v.inline)
    end

    
    if v.token=='parts' then
        str = abc_parts(v.parts)
    end
    
    if v.token=='new_part' then
        str = abc_new_part(v.part)
    end
    
    
    if v.token=='words' then
        str = abc_lyrics(v.lyrics)
    end
    
    if v.token=='note_length' then
        str = abc_note_length(v.note_length)
    end
    
    -- if this was a field
    if str then
        if inline then
            return '[' .. str .. ']'
        else
            return str .. '\n'
        end
    end
    
    return nil
end


function abc_triplet(triplet)
    -- abc the string represenation of a triplet specifier
    -- Uses the simplest ABC form
    -- 1-3 elements p:q:r
    -- p:q gives the ratio of the compression
    -- r gives the duration of the effect (in notes)
    
    local triplet_string
    local q_table = {-1,3,2,3,-1,2,-1,3,-1} -- default timing
    
    triplet_string = '('..triplet.p
    
    -- check if we need an r field
    local r_needed = triplet.r and triplet.r ~= triplet.p
    
    -- only need q if it's not default
    -- e.g. triplet p=3, q=2, r=3 should just be written as (3
    local q_needed = triplet.q and (q_table[triplet.p]~=triplet.q)
    
    -- triplet of form (3:2
    if q_needed or r_needed then
        triplet_string = triplet_string .. ':'
        if q_needed then 
            triplet_string = triplet_string .. triplet.q
        end
    end
    
    -- full triplet (only need r if it's not equal to p)
    if r_needed then
        triplet_string = triplet_string .. ':' .. triplet.r
    end
    
    return triplet_string .. ' ' -- must include trailing space separator!
end


function abc_accidental(accidental)
    local acc = ''
    if accidental then
        local ad = accidental
        -- microtonal accidenals
        if ad then
            -- 0 is = 
            if ad.den == 0 or ad.num==0 then
                acc = '='
                
            -- plain accidentals
            elseif ad.den == 1 then
                if ad.num==1 then
                    acc = '^'
                elseif ad.num==-1 then
                    acc = '_'
                elseif ad.num==2 then
                    acc = '^^'
                elseif ad.num==-2 then
                    acc = '__'
                else
                    -- triple etc. sharps notated ^3f
                    if ad.num>0 then
                        acc = '^'..ad.num
                    else
                        acc = '_'..-ad.num
                    end
                end
            else
                -- write as /n if possible
                if math.abs(ad.num)~=1 then
                    if ad.num+0<0 then
                        acc = -ad.num
                    else
                        acc = ad.num
                    end
                end
                
                
                if (ad.num+0)<0 then
                    acc = '_'..acc..'/'..ad.den
                else
                    acc = '^'..acc..'/'..ad.den
                end
                
            end
        end
    end
   return acc 
end

function abc_pitch(note_pitch)
    -- get the string represenation of a pitch table
    -- pitch; lowercase = +1 octave
    
 
    -- root note
    local pitch = note_pitch.note
    
    -- octave shifts
    if note_pitch.octave then
        local octave = note_pitch.octave
        
        if octave<1 then
            pitch = string.upper(note_pitch.note)
            octave = octave+1
        end
        
        
        -- increase octave with '
        if octave>1 then
            for i=1,octave-1 do
                pitch = pitch .. "'"
            end
        end 
        -- decrease octave with ,
        if octave<1 then
            for i=1,(1-octave) do
                pitch = pitch .. ","
            end
        end
    end
    
   -- add accidentals
    pitch = abc_accidental(note_pitch.accidental)..pitch
       
    return pitch
end


function abc_duration(note_duration)
    -- get the string representation of the duration of the note
    -- e.g. as a fraction (A/4 or A2/3 or A>)

    local duration = ''
 
    -- work out the duration form
    -- nothing if fraction is 1/1
    -- just a if fraction is a/1
    -- just /b if fraction is 1/a
    -- a/b otherwise
    if note_duration.num~=1 then
        duration = duration .. note_duration.num
    end
    if note_duration.den~=1 then
        duration = duration .. '/' .. note_duration.den
    end

    -- add broken rhythm symbols (< and >)
    -- broken, this note shortened
    if note_duration.broken < 0 then
        for i=1,-note_duration.broken do
            duration = duration..'<'
        end
    end
   
    -- broken, this note lengthened
    if note_duration.broken > 0 then
        for i=1,note_duration.broken do
            duration = duration..'>'
        end
    end
   
    return duration
end


function abc_note_def(note)
    local note_str = ''
    
    -- measure rests
    if note.measure_rest then
        if note.duration.num==1 and note.duration.den==1 then
            return 'Z'
        else
            if note.duration.den==1 then            
                return 'Z' .. note.duration.num
            else
                -- fractional bar rests aren't really in the standard, but
                -- we can genreate them anyway
                return 'Z' .. note.duration.den ..  '/' ..note.duration.num
            end
        end
    end
    
    -- space notes
    if note.space then
        return 'y'
    end
    
    -- pitch and duration
    if note.rest then
        note_str = 'z'
    else
        note_str = abc_pitch(note.pitch)
    end
    note_str = note_str .. abc_duration(note.duration)
    return note_str
end

function abc_chord(chord)  
    
    -- return the represenation of a chord
   local chord_str = chord_case(chord.base_pitch)
   -- omit maj for major chords
   if chord.chord_type~='maj' then
      chord_str = chord_str..string.lower(chord.chord_type)
   end
   
   if chord.inversion then
        chord_str = chord_str .. '/' .. chord_case(chord.inversion)
    end    
    return chord_str
end

function abc_note(note)
    -- abc a note out
    -- Return the string version of the note definition
    -- Includes pitch and duration
    local note_str = ''
    
    -- grace notes (e.g. {gabE}e)
    if note.grace then
        note_str = note_str .. '{'
        for i,v in ipairs(note.grace) do
            note_str = note_str .. abc_note_def(v)
        end
        note_str = note_str .. '}'
    end
    
    -- chords (e.g. "Cm")
    if note.chord then
        note_str = note_str .. '"' .. abc_chord(note.chord) .. '"'
    end
    
    -- decorations (e.g. . for legato)
    if note.decoration then        
        note_str = note_str ..  table.concat(note.decoration)        
    end
    
    -- pitch and duration
    note_str = note_str .. abc_note_def(note)
    
    -- ties
    if note.tie then
        note_str = note_str .. '-'
    end
    
    return note_str
end



function abc_bar(bar)
    -- Return a string representing a bar element
    -- a bar can be
    -- | single bar
    -- || double bar
    -- [| double thick-thin bar
    -- |] double thin-thick bar
    -- |: start repeat
    -- :| end repeat
    -- :|: mid repeat
    -- [n start variant
    
    local bar_str = ''
    
    local type_symbols = {plain='|', double='||', thickthin='[|', thinthick='|]',
    variant='['}
    
    for i,v in pairs(type_symbols) do
        if bar.type==i then 
            bar_str = v
        end
    end
    
    if bar.type=='start_repeat' then
        bar_str= '|' .. repeat_string(':', bar.start_reps)
    end
    
    if bar.type=='end_repeat' then
        bar_str= repeat_string(':', bar.end_reps) .. '|'
    end
    
    if bar.type=='mid_repeat' then
        bar_str= repeat_string(':', bar.end_reps) .. '|' .. repeat_string(':', bar.start_reps)
    end
    
    if bar.type=='variant' then 
        bar_str = '[' 
    end
    
    -- variant indicators (e.g. for parts [4 or for repeats :|1 x x x :|2 x x x ||)
    if bar.variant_range then
      
        -- for part variants, can have multiple indicators
        if bar.type=='variant' then
            for i,v in ipairs(bar.variant_range) do
                bar_str = bar_str .. v .. ','
            end
            -- remove last comma
            bar_str = string.sub(bar_str, 1, -2)
        else
            -- can only have one variant indicator
            bar_str = bar_str .. bar.variant_range[1]
        end
    end
    
    return bar_str
end


function abc_note_element(element)
    -- Return a string representing a note element 
    -- can be a note, rest, bar symbol
    -- chord group, slur group, triplet/tuplet
    -- line break, beam break or some inline text
    if element.token=='split' then
        return ' '
    end
    
    if element.token=='split_line' then
        return '\n'
    end
    
    if element.token=='continue_line' then
        return '\\\n'
    end
    
    
    if element.token=='chord' then
            return '"' .. abc_chord(element.chord) .. '"'
    end
    
    if element.token=='overlay' then
        return string.rep('&', element.bars)
    end
    
    if element.token=='chord_begin' then
            return '['        
    end
    
    if element.token=='chord_end' then
        return ']'
    end
    
    if element.token=='slur_begin' then
        return '('        
    end
    
    if element.token=='slur_end' then
        return ')'
    end
    
    if element.token=='text' then     
        return '"' .. (element.position or '').. element.text .. '"'
    end
    
    if element.token=='triplet' then
        return abc_triplet(element.triplet)
    end
    
    if element.token=='note' then
        return abc_note(element.note)
    end
    
    if element.token=='bar' then
        return abc_bar(element.bar)
    end
 
    
    return nil
    
end
 
function abc_element(element)    
    -- return the abc representation of token_stream element
    
    return abc_note_element(element) or abc_field(element, element.inline)
    
end

function emit_abc(token_stream)
-- return the token_stream out as a valid ABC string
    local output = {}       
    for i,v in ipairs(token_stream) do
         table.insert(output, abc_element(v))
    end    
    -- concatenate into a single string
    return rtrim(table.concat(output))
end

function abc_from_songs(songs, creator)
    -- return the ABC representation of a table of songs
    -- the creator field can optionally be specified to identify
    -- the program that created this code
    local out = {}
    creator = creator or 'abclua'
    -- write out header
    table.insert(out, '%abc-2.1\n')
    table.insert(out, '%%abc-creator='..creator..'\n')
    
    -- each song segment separated by two newlines
    for i,v in ipairs(songs) do
        table.insert(out, emit_abc(v.token_stream))
        table.insert(out, '\n\n')
    end
    return table.concat(out)
end




--
-- From source file: tools.lua
--

local pitch_table = {c=0, d=2, e=4, f=5, g=7, a=9, b=11}
local pitches = {'c', 'd', 'e', 'f', 'g', 'a', 'b'}


function diatonic_transpose_note(original_mapping, shift, new_mapping, inverse_mapping, pitch, accidental)
    -- Transpose a note name (+ accidental) in an original key mapping to a new key mapping which is
    -- shift semitones away    
        local semi = (get_semitone(original_mapping, pitch, accidental)%12 + shift)
        
        -- test for octave shift
        local octave = 0
        if semi<0 then
            octave = math.floor((semi/12))
         end
               
        if semi>11 then
            octave = math.floor(((semi)/12))            
        end        
        
        semi = semi % 12             
        local new_accidental, new_pitch                       
        -- if we don't need an accidental
        if inverse_mapping[semi] then
            new_pitch = inverse_mapping[semi]       
            new_accidental = nil                  
        else
            -- check the next note
            new_pitch = inverse_mapping[(semi+1)%12]                     
            t = new_mapping[new_pitch]            
            if not t or t==-1 then 
                -- check the note lower and sharpen it
                new_pitch = inverse_mapping[(semi-1)%12] 
                t = new_mapping[new_pitch]
                if t==0 then new_accidental={num=1, den=1} end
                if t==-1 then new_accidental={num=0, den=0} end
                if t==1 then new_accidental={num=2, den=1} end
            else
                -- if we can just flatten that one, use that
                if t==0 then new_accidental={num=-1, den=1} end
                if t==1 then new_accidental={num=0, den=0} end            
            end            
        end        
        return new_pitch, new_accidental, octave
end


function diatonic_transpose(tokens, shift)
    -- Transpose a whole token stream by a given number of semitones    
    local current_key, original_key        
    local mapping, key_struct
    local inverse_mapping = {}
    
    
    for i,token in ipairs(tokens) do
        if token.token=='key' then                               
                        
            -- get new root key
            original_key = create_key_structure(token.key)
            token.key.root = transpose_note_name(token.key.root, shift)
            current_key = token.key            
            -- work out the semitones in this key
            mapping = create_key_structure(current_key)                                               
            for i,v in pairs(pitch_table) do                                           
                local k = v+mapping[i]
                k = k % 12
                inverse_mapping[k] = i
            end                       
        end        
        
        -- transpose chords
        if token.token=='chord' then
          token.chord = transpose_chord(token.chord, shift)                        
        end
        
        if token.token=='note' and mapping then
            local pitch,accidental,octave
            
            -- transpose embedded chords
            if token.note.chord then
                token.note.chord = transpose_chord(token.note.chord, shift % 12)                        
            end
        
            -- if we have a pitched note
            if token.note.pitch then        
                -- transpose the note                
                pitch,accidental,octave = diatonic_transpose_note(original_key, shift, mapping, inverse_mapping, token.note.pitch.note, token.note.pitch.accidental)                
                token.note.pitch.note = pitch
                token.note.pitch.accidental = accidental                    
                token.note.pitch.octave = token.note.pitch.octave + octave
            end
            
            -- apply to grace notes
            if token.note.grace then
                for i,v in ipairs(token.note.grace) do
                    pitch,accidental,octave = diatonic_transpose_note(original_key, shift, mapping, inverse_mapping, v.pitch.note, v.pitch.accidental)
                    v.pitch.note = pitch
                    v.pitch.accidental = accidental                
                    v.pitch.octave = v.pitch.octave + octave
                end
            end
            
        end
        
    end       
end


function swap_or_insert(t, match, position, default)
    -- Find match in t; if it exists, swap it into position
    -- if not, insert a default at that position
    local ref = find_first_match(t, match) 
    local elt
    
    -- insert default if does not match
    if not ref then                 
        table.insert(t, position, default)        
    else        
        elt = t[ref]
        table.remove(t, ref)
        -- swap it into place
        table.insert(t, position, elt)
    end
    
end

function validate_token_stream(tokens)
    -- Make sure the given token stream is valid
    -- Forces the token stream to begin with X:, followed by T:, followed by the other
    -- fields, followed by K:, followed by the notes
        
    swap_or_insert(tokens, {token='field_text', name='ref'}, 1, {token='field_text', name='ref', content='1', is_field=true})    
    swap_or_insert(tokens, {token='field_text', name='title'}, 2, {token='field_text', name='title', content='untitled', is_field=true})
    
        
    local first_note = 1
    -- find first non-field element
    for i,v in ipairs(tokens) do                                               
        if not v.is_field then
            break
        end        
        first_note = i        
    end
            
    -- make sure last element before a note is a key
    swap_or_insert(tokens, {token='key'}, first_note+1, {token='key', key={root='c'}})    
    return tokens
end



--
-- From source file: tuplets.lua
--
-- Functions for dealing with tuplets

function update_triplet_ratio(song)
    -- compute the current compression ratio
    -- The product of all active triplets
    local ratio = 1
    for i,v in ipairs(song.context.timing.triplet_state) do
        ratio = ratio / v.ratio
    end
    song.context.timing.triplet_compress = ratio
end

function push_triplet(song, p, q, r)
    -- push a new triplet onto the stack
    table.insert(song.context.timing.triplet_state, {count=r, ratio=p/q})
    update_triplet_ratio(song)
end

function reset_triplet_state(song)
    -- reset the triplet state, cancelling all triplets
    song.context.timing.triplet_state = {}
    update_triplet_ratio(song)
end

function update_tuplet_state(song)
    -- a note has occured; change tuplet state
    -- update tuplet counters; if back to zero, remove that triplet
    
    local actives = {}
    for i,v in ipairs(song.context.timing.triplet_state) do
        v.count = v.count-1
        -- keep only triplets with counters > 0
        if v.count > 0 then
            table.insert(actives, v)
        end
    end    
    song.context.timing.triplet_state = actives
        
    -- update the time compression
    update_triplet_ratio(song)

end

function apply_triplet(song, triplet)
    -- set the triplet fields in the song
    local p,q,r
    
    if triplet.q == 'n' then
        -- check if compound time -- if so
        -- the default timing for (5 (7 and (9 changes
        if is_compound_time(song) then
            q = 3
        else    
            q = 2
        end
    else
        q = triplet.q
    end
    p = triplet.p
    r = triplet.r 
    
    -- set compression and number of notes to apply this to    
    push_triplet(song, triplet.p, triplet.q, triplet.r)
    
end



function parse_triplet(triplet, song)
-- parse a triplet/tuplet definition, which specifies the contraction of the following
-- n notes. General form of p notes in the time of q for the next r notes

    local n, p, q, r
    q=-1
    r=-1
            
    -- simple triplet of form (3:
    if #triplet==1 then
        p = triplet[1]+0                
    end
    
    -- triplet of form (3:2
    if #triplet==2 then
        p = triplet[1]+0                
        q = triplet[2]+0
    end
    
    -- triplet of form (3:2:3 or (3::2 or (3::
    if #triplet==3 then
        p = triplet[1]+0
        if triplet[2] and string.len(triplet[2])>0 then
            q = triplet[2]+0
        end
        if triplet[3] and string.len(triplet[3])>0 then
            r = triplet[3]+0
        end
    end
       
    -- default: r is equal to p
    if r==-1 then
        r = p
    end

    -- allow long triplets
    -- if p>9 then
        -- warn("Bad triplet length (p>9)")
    -- end
    
    -- default to choosing q from the table
    local q_table = {-1,3,2,3,'n',2,'n',3,'n'}
    if q==-1 then
        q = q_table[p]
    end
        
    return {p=p, q=q, r=r}
end


--
-- From source file: pitches.lua
--
-- pitch arithmetic functions


local natural_pitch_table = {c=0, d=2, e=4, f=5, g=7, a=9, b=11}

function get_semitone(key_mapping, pitch, accidental)
    -- return the semitone of a note (0-11) in a given key, with the given accidental
    local base_pitch = natural_pitch_table[pitch]    
           
    -- accidentals / keys
    if accidental then   
        if accidental.den==0 then 
            accidental =  0 
        else
            accidental = accidental.num / accidental.den
        end
        base_pitch = base_pitch + accidental        
    else        
        -- apply key signature sharpening / flattening
        if key_mapping then
            accidental = key_mapping[string.lower(pitch)]
            base_pitch = base_pitch + (accidental)
        end
    end        
    return base_pitch 
end

function midi_note_from_note(mapping, note, accidental)
    -- Given a key mapping, get the midi note of a given note        
    -- optionally applying a forced accidental
    accidental = note.pitch.accidental or accidental    
    local base_pitch = get_semitone(mapping, note.pitch.note, accidental)    
    return base_pitch + 60 + (note.pitch.octave or 0) * 12
end

local note_table = {
c=0,
cb=11,
cs=1,
d=2,
db=1,
ds=3,
e=4,
eb=3,
es=5,
f=5,
fb=4,
fs=6,
g=7,
gb=6,
gs=8,
a=9,
ab=8,
as=10,
b=11,
bb=10,
bs=12
}

function all_note_table()
    -- return a list of all notes and their semitone numbers
    return note_table
end

local key_note_table = {
c=0,
cb=11,
cs=1,
d=2,
db=1,
e=4,
eb=3,
f=5,
fs=6,
g=7,
gb=6,
a=9,
ab=8,
b=11,
bb=10
}

local inverse_key_note_table = invert_table(key_note_table)

function midi_to_frequency(midi, reference)
    -- transform a midi note to a frequency (in Hz)
    -- optionally use a different tuning than concert A
    -- specify frequency of A in Hz as the second parameter if required
    reference = reference or 440.0    
    return reference * math.pow(2.0, (midi-69)/12.0)
end


function transpose_note_name(name, shift)
    -- convert a note string into a canonical note string shifted by shift 
    -- semitones. Wraps around at octave boundaries
    return canonical_note_name((get_note_number(name)+shift)%12)
end

function get_note_number(note)
    -- Convert a note string to a note number (0-11)
    -- e.g. get_note_number('C#') returns 1
    return note_table[string.lower(note:gsub('#','s'))]
end

function canonical_note_name(num)
    -- change a semitone number (0-11) to a note name.
    -- only returns one of the canonical names (so there is no
    -- enharmonic ambiguity). 
    -- This means that canonical_note_name(get_note_number(note)) is not necessarily equal to note 
    return inverse_key_note_table[num]
end

function chord_case(str)
    -- Convert a note name to upper case, with proper # symbol
    return string.upper(string.sub(str,1,1))..string.sub(str,2,-1):gsub('s', '#')
end

function printable_note_name(n)
    -- convert a note number to a note symbol, and then return it as
    -- a printable note (uppercase, with #)
    local str = inverse_key_note_table[n%12]
    return chord_case(str)
end


--
-- From source file: compile.lua
--
-- Functions from transforming a parsed token stream into a song structure and then an event stream


function get_bpm_from_tempo(tempo)
    -- return the real bpm of a tempo 
    local total_note = 0
    for i,v in ipairs(tempo) do
        total_note = total_note + (v.num / v.den)
    end                    
    
    local rate = 60.0 / (total_note * tempo.tempo_rate)
    return rate
end

function update_timing(song)
    -- Update the base note length (in seconds), given the current L and Q settings
    local rate = 0    
    local note_length = song.context.note_length or default_note_length(song)
    
    rate = get_bpm_from_tempo(song.context.tempo)
    song.context.timing.base_note_length = rate / note_length
    
    song.context.timing.grace_note_length = rate / (song.context.grace_length.den/song.context.grace_length.num)
    song.context.timing.bar_length = compute_bar_length(song)
        
    table.insert(song.opus, {event='timing_change', base_note_length=song.context.timing.base_note_length*1e6, bar_length=song.context.timing.bar_length,
    beats_in_bar = song.context.meter.num, note_length=note_length, beat_length = song.context.timing.bar_length/song.context.meter.num})
   
end    

function is_compound_time(song)
    -- return true if the meter is 6/8, 9/8 or 12/8
    -- and false otherwise
    local meter = song.context.meter
    if meter then
        if meter.den==8 and (meter.num==6 or meter.num==9 or meter.num==12) then
            return true
        end
    end
    return false
end

function apply_repeats(song, bar)
        -- clear any existing material
        if bar.type=='start_repeat' then
            add_section(song, 1)
        end
                                
        -- append any repeats, and variant endings
        if bar.type=='mid_repeat' or bar.type=='end_repeat' or bar.type=='double' or bar.type=='thickthin' or bar.type=='thinthick' then
        
            add_section(song, bar.end_reps+1)
            
            -- mark that we will now go into a variant mode
            if bar.variant_range then
                -- only allows first element in range to be used (e.g. can't do |1,3 within a repeat)
                song.context.in_variant = bar.variant_range[1]
            else
                song.context.in_variant = nil
            end            
        end
        
        -- part variant; if we see this we go into a new part
        if bar.type=='variant' then
            start_variant_part(song, bar)
        end        
end

function apply_key(song, key) 
    -- apply transpose / octave to the song state
    if key.clef then                 
        if key.clef.octave then
            song.context.global_transpose = 12 * key.clef.octave -- octave shift
        else
            song.context.global_transpose = 0
        end
        
        if key.clef.transpose then 
            song.context.global_transpose = song.context.global_transpose + key.clef.transpose                
        end
    end 
    
    -- update key map
    song.context.key_mapping = create_key_structure(key)
end

function finalise_song(song)
    -- Finalise a song's event stream
    -- Composes the parts, repeats into a single stream
    -- Inserts absolute times into the events 
    -- Inserts the lyrics into the song

    compose_parts(song)
    
    -- clear temporary data
    song.opus = nil
    song.temp_part = nil 
 
    -- time the stream and add lyrics    
   
    time_stream(song.stream)   
    song.stream = insert_lyrics(song.context.lyrics, song.stream)
end


function apply_voice_specifiers(song)
    -- apply the voice specifiers. this sets the voice transpose if need be
    song.context.voice_transpose = 0
    -- compute transpose
    local transpose =  song.context.voice_specifiers.transpose or  song.context.voice_specifiers.t or 0
    local octaves =   (song.context.voice_specifiers.octave) or 0
    
    -- look for '+8' or '-8' at the end of a clef (e.g. treble+8)
    if song.context.voice_specifiers.clef then
        local clef = song.context.voice_specifiers.clef
        if string.len(clef)>2 and string.sub(clef,-2)=='+8' then octaves=octaves+1 end
        if string.len(clef)>2 and string.sub(clef,-2)=='-8' then octaves=octaves-1 end
    end
    
    song.context.voice_transpose = 12*octaves + transpose   
    
end


function reset_timing(song)
    -- reset the timing state of the song
    song.context.timing = {} 
    song.context.timing.triplet_state = {}    
    song.context.timing.triplet_compress = 1
    song.context.timing.prev_broken_note = 1
    song.context.timing.bar_time = 0
    update_timing(song)
end


function reset_bar_time(song)
    -- if warnings are enabled, mark underfull and overfull bars
    if song.context.bar_warnings then    
        if song.context.timing.bar_time>1 then
            warn('Overfull bar')
        end
        
        if song.context.timing.bar_time<1 then
            warn('Underfull bar')
        end
    end
    
    song.context.timing.bar_time = 0
end

function start_new_voice(song, voice, specifiers)
    -- compose old voice into parts
    if song.context and song.context.voice then
        finalise_song(song)                
        song.voices[song.context.voice] = {stream=song.stream, context=song.context}
    end

    song.context.voice_specifiers = {}    
    -- merge in voice specifiers from heder and from this definition line
    if song.voice_specifiers[voice] then
        for i,v in pairs(song.voice_specifiers[voice]) do
            song.context.voice_specifiers[v.lhs] = v.rhs            
        end    
    end
    
    if specifiers then
        for i,v in pairs(specifiers) do
            song.context.voice_specifiers[v.lhs] = v.rhs
        end    
    end    
    
    apply_voice_specifiers(song)
    
    -- reset song state
    -- set up context state
    song.context.lyrics = {}
    song.context.current_part = 'default'
    song.context.part_map = {}
    song.context.pattern_map = {}
    
    song.context.voice = voice
    song.temp_part = {}
    song.opus = song.temp_part
    reset_timing(song)
            
end



function expand_token_stream(song)
    -- expand a token_stream into a song structure
    
    for i,v in ipairs(song.token_stream) do
   
        if song.context.write_abc_events then
            -- write in the ABC notation event as a string
            table.insert(song.opus, {event='abc', abc=abc_element(v)})
        end
        
        local event
        -- copy in standard events that don't change the context state
        if v.token ~= 'note' then
           event = copy_table(v)
           event.event = event.token
           event.token = nil
           table.insert(song.opus, event)
        else
           insert_note(v.note, song)                                         
        end
       
        -- end of header; store metadata so far
        if v.token=='header_end' then
            song.header_metadata = deepcopy(song.metadata)
            song.header_context = deepcopy(song.context) 
        end
       
        -- deal with triplet definitions
        if v.token=='triplet' then                
            -- update the context tuplet state so that timing is correct for the next notes
            apply_triplet(song, v.triplet)
            end
        
        -- deal with bars and repeat symbols
        if v.token=='bar' then
            reset_bar_time(song)
            apply_repeats(song, v.bar)  
            song.context.accidental = {} -- clear any lingering accidentals             
        end
        
            
        -- text fields
        if v.token=='field_text'  then       
            if song.metadata[v.name] then
                table.insert(song.metadata[v.name], v.content)
            else            
                song.metadata[v.name] =  {v.content}
            end
        end                
        
        -- append fields
        if v.token=='append_field_text' then
            local last
            if song.metadata[v.name] then
                last = song.metadata[v.name][#song.metadata[v.name]] 
                last = last..' '..v.content
                song.metadata[v.name][#song.metadata[v.name]]  = last                
            else
                warn("Continuing a field with +: that doesn't exist.")
            end          
                
        end
        
        -- new voice
        if v.token=='voice_change' then
            start_new_voice(song, v.voice.id, v.voice.specifiers)
        end
        
        if v.token=='voice_def' then
            -- store any voice specific settings for later
            song.voice_specifiers[v.voice.id] = v.voice.specifiers
        end
        
        if v.token=='instruction' then
            if v.directive then
                apply_directive(song, v.directive.directive, v.directive.arguments)
            end
        end
         
        
        if v.token=='note_length' then
             song.context.note_length = v.note_length
            update_timing(song)
        end
        
        if v.token=='tempo' then
            song.context.tempo = v.tempo
            update_timing(song)
             -- store tempo string in metadata
            song.metadata.tempo = string.sub(abc_tempo(v.tempo),3)
   
        end
        
        if v.token=='words' then         
            table.insert(song.opus, {event='lyric_align'}) 
            table.insert(song.context.lyrics, v.lyrics)
        end
            
        if v.token=='parts' then
            song.context.part_structure = v.parts
            song.context.part_sequence = expand_parts(song.context.part_structure)      
        end
        
        if v.token=='new_part' then
            song.in_variant_part = nil -- clear the variant flag
            start_new_part(song, v.part)    
        end
        
        if v.token=='meter' then  
            song.context.meter = v.meter
            update_timing(song)  
            -- store key string in metadata
            song.metadata.meter = string.sub(abc_meter(v.meter),3)
                
        end
        
        -- update key
        if v.token=='key' then            
            song.context.key = v.key
            apply_key(song, song.context.key)
            
            -- store key string in metadata
            song.metadata.key = string.sub(abc_key(v.key),3)
        end
 
    
    end
    
end


function compile_token_stream(song, context, metadata)
    -- Convert a token_stream into a full
    -- a song datastructure. 
    -- 
    -- song.metadata contains header data about title, reference number, key etc.
    --  stored as plain text
   
    -- The song contains a table of voices
    -- each voice contains:
    -- voice.stream: a series of events (e.g. note on, note off)
    --  indexed by microseconds,
    -- voice.context contains all of the parsed song data
    -- copy any inherited data from the file header
    
    song.default_context = context or get_default_context()
    song.context = song.default_context
   
    song.voices = {}
    song.voice_specifiers = {}
    song.metadata = metadata or {}
    start_new_voice(song, 'default')
    expand_token_stream(song)
    
    -- finalise the voice
    start_new_voice(song, nil)
    
    -- clean up
    song.stream = nil
    
end


--
-- From source file: parse_abc.lua
--
-- Grammar for parsing tune definitions

-- The master grammar
local tune_pattern = [[
elements <- ( ({}  <element>)  +) -> {}
element <- (  {:field: field :}  / ({:slur: <slurred_note> :}) / ({:chord_group: <chord_group> :})  / {:overlay: <overlay> :} / {:bar: (<bar> / <variant>) :}   / {:free_text: free :} / {:triplet: triplet :} / {:s: beam_split :}  / {:continuation: continuation :}) -> {}

overlay <- ('&' +)
continuation <- ('\')
beam_split <- (%s +)
free <- ( '"' {:text: [^"]* :} '"' ) -> {}
bar <- ( {:type: ((']' / '[') * ('|' / ':') + (']' / '[') *) :} ({:variant_range: (<range_set>) :}) ? ) -> {}
variant <- ({:type: '[' :} {:variant_range: <range_set> :})   -> {}
range_set <- (range (',' range)*)
range <- ([0-9] ('-' [0-9]) ?)
slurred_note <- ( ((<complete_note>) -> {}) / ( ({:chord: chord :} ) ? '(' ((<complete_note> %s*)+) ')' )  -> {}  ) 


chord_group <- ( ({:chord: chord :} ) ? ('[' ((<complete_note> %s*) +) ']' ) ) -> {} 
complete_note <- (({:grace: (grace)  :}) ?  ({:chord: (chord)  :}) ?  ({:decoration: ({decoration} +)->{} :}) ?  {:note_def: full_note :}  (%s * {:tie: (tie)  :}) ? ) -> {} 
triplet <- ('(' {[1-9]} (':' {[1-9] ?}  (':' {[1-9]} ? ) ?) ?) -> {}
grace <- ('{' full_note + '}') -> {}
tie <- ('-')
chord <- (["] {([^"] *)} ["])
full_note <-  (({:pitch: (note) :} / {:rest: (rest) :} / {:space: (space) :}/{:measure_rest: <measure_rest> :} ) {:duration: (duration ?)  :}  {:broken: (broken ?)  :})  -> {}
rest <- ( 'z' / 'x' )
space <- 'y'
measure_rest <- (('Z' / 'X')  ) -> {}
broken <- ( ('<' +) / ('>' +) )
note <- (({:accidental: ({accidental} duration ? ) -> {}  :})? ({:note:  ([a-g]/[A-G]) :}) ({:octave: (octave)  :}) ? ) -> {}
decoration <- ( ('!' ([^!] *) '!') / ('+' ([^+] *) '+') / '.' / [~] / 'H' / 'L' / 'M' / 'O' / 'P' / 'S' / 'T' / 'u' / 'v' )
octave <- (( ['] / ',') +)
accidental <- ( ('^^' /  '__' /  '^' / '_' / '=')   ) 
duration <- ( (({:num: ([1-9] +) :}) ? ({:slashes: ('/' +)  :})?  ({:den: ((  [1-9]+  ) ) :})?))  -> {}

field <- (  '['  {:contents: field_element  ':'  [^]`] + :} ']' ) -> {}
field_element <- ([A-Za-z])

]]
local tune_matcher = re.compile(tune_pattern)


function parse_free_text(text)
    -- split off an annotation symbol from free text, if it is there
    local annotations = {'^', '_', '@', '<', '>'}
    -- separate annotation symbols
    local position, new_text
    if string.len(text)>1 and is_in(string.sub(text,1,1), annotations) then
        position = string.sub(text,1,1)
        new_text = string.sub(text,2)
    else
        new_text = text
    end
    return position, new_text
end

function add_note_to_stream(token_stream, note)
    -- add a note to the token stream
    local cnote = parse_note(note)    
    if cnote.free_text then
            local position, text = parse_free_text(cnote.free_text)                   
            table.insert(token_stream, {token='text', text=text, position = position})                            
            cnote.free_text = nil
    end
    table.insert(token_stream, {token='note', note=cnote})          
 end

function read_tune_segment(tune_data, song)
    -- read the next token in the note stream    
    local cross_ref = nil
    for i,v in ipairs(tune_data) do
        
        if type(v) == 'number' then
            -- insert cross refs, if they are enabled
            if song.parse.cross_ref then
                 table.insert(song.token_stream, {token='cross_ref', at=v, line=song.parse.line})
            end
        else
                    
            -- store annotations
            if v.free_text then
                -- could be a standalone chord
                local chord = parse_chord(v.free_text.text)                                                
                if chord then
                    table.insert(song.token_stream, {token='chord', chord=chord})
                else
                    local position, text = parse_free_text(v.free_text.text)                   
                    table.insert(song.token_stream, {token='text', text=text, position = position})
                end
            end
            
            -- parse inline fields (e.g. [r:hello!])
            if v.field then                
                -- this automatically writes it to the token_stream            
                parse_field(v.field.contents, song, true)
            end
            
            -- deal with triplet definitions
            if v.triplet then                                        
                table.insert(song.token_stream, {token='triplet', triplet=parse_triplet(v.triplet, song)})
                
            end
            
            -- voice overlay
            if v.overlay then
                table.insert(song.token_stream, {token='overlay', bars=string.len(v.overlay)})
            end
            
            -- beam splits
            if v.s then
                table.insert(song.token_stream, {token='split'})
            end
            
            -- linebreaks
            if v.linebreak then
                table.insert(song.token_stream, {token='split_line'})
            end
            
            if v.continue_line then
                table.insert(song.token_stream, {token='continue_line'})
            end
                                        
            -- deal with bars and repeat symbols
            if v.bar then   
                local bar = parse_bar(v.bar)
                if bar.type ~= 'variant' then
                    song.parse.measure = song.parse.measure + 1 -- record the measures numbers as written
                end
                bar.measure = song.parse.measure
                table.insert(song.token_stream, {token='bar', bar=bar})               
            end
            
            -- chord groups
            if v.chord_group then
            
                -- textual chords
                if v.chord_group.chord then
                    table.insert(song.token_stream, {token='chord', chord=parse_chord(v.chord_group.chord)})                                
                end
                
                if v.chord_group[1] then
                    table.insert(song.token_stream, {token='chord_begin'})                                
                    -- insert the individual notes
                    for i,note in ipairs(v.chord_group) do                
                        add_note_to_stream(song.token_stream, note)                        
                    end
                    table.insert(song.token_stream, {token='chord_end'})                                
                end                               
                
            end
            
            -- if we have slur groups then there are some notes to parse...
            if v.slur then            
                if v.slur.chord then
                    table.insert(song.token_stream, {token='chord', chord=parse_chord(v.slur.chord)})                                
                end
                
                -- slur groups (only put the group in if there
                -- are more than elements, or there is an associated chord name)
                if #v.slur>1  then
                    table.insert(song.token_stream, {token='slur_begin'} )
                   
                end
                
                -- insert the individual notes
                for i,note in ipairs(v.slur) do                                    
                    add_note_to_stream(song.token_stream, note)
                end
                    
                if #v.slur>1 then
                    table.insert(song.token_stream, {token='slur_end'} )
                end
            end
        end
    end
    
end


function expand_macros(song, line)
    -- expand any macros in a line   
    local converged = false
    local iterations = 0
    local expanded_line
    
    expanded_line = apply_macros(song.parse.macros, line)
    expanded_line = apply_macros(song.parse.user_macros, expanded_line)
        
    -- macros changed this line; must now re-parse the line
    match = tune_matcher:match(expanded_line)
    if not match then
        warn('Macro expansion produced invalid output '..line..expanded_line)
        return nil -- if macro expansion broke the parsing, ignore this line
    end
    
    return match    
    
end

function parse_abc_line(line, song)
    -- Parse one line of ABC, updating the song
    -- datastructure. Temporary state is held in
    -- information from line to line
        
    -- strip whitespace from start and end of line
    line = line:gsub('^%s*', '')
    line = line:gsub('%s*$', '')
    
    -- remove any backquotes
    line = line:gsub('`', '')
    
    -- replace stylesheet directives with I: information fields
    line = line:gsub("^%%%%", "I:")    
    
    -- strip comments
    line = line:gsub("%%.*", "")
    
    --
    -- read header or metadata
    --       
    -- read metadata fields
    local field_parsed = parse_field(line, song)
      
   
    -- check if we've read the complete header; terminated on a key
    if song.parse.found_key and song.parse.in_header then
        song.parse.in_header = false
        table.insert(song.token_stream, {token='header_end'})
    end
        
    --
    -- read tune
    --
    if not field_parsed and not song.parse.in_header then
        
        -- try and match notes
        local match = tune_matcher:match(line)
                
        -- if it was a tune line, then parse it
        -- (if not, it should be a metadata field)
        if match then            
        
            -- check for macros
            if not song.parse.no_expand and (#song.parse.macros>0 or #song.parse.user_macros>0)  then               
                match = expand_macros(song, line)
                if not match then 
                    return nil -- bad macro messed this line up
                end
            end
            
            -- we found tune notes; this isn't a file header
            song.parse.has_notes = true
            
            -- insert linebreaks if there is not a continuation symbol
            if  not match[#match].continuation then
                table.insert(match, {linebreak=''})    
            else
                table.insert(match, {continue_line=''})    
            end
            
            read_tune_segment(match, song)
        end
    end
    
    
end    


function parse_abc_string(song, str)    
    -- parse an ABC file and fill in the song structure
    -- this is a separate method so that recursive calls can be made to it 
    -- to include subfiles
    
    
    local lines = split(str, "[\r\n]")
    for i,line in pairs(lines) do        
        song.parse.line = i
        --parse_abc_line( line, song)
        local success, err = pcall(parse_abc_line, line, song)
        if not success then
            warn('Parse error reading line '  .. line.. '\n'.. err)
        end
    end
end
    

function parse_abc(str, options, in_header)
    -- parse and ABC file and return a song with a filled in token_stream field
    -- representing all of the tokens in the stream    
    local song = {}    
    
    song.token_stream = {}
    options = options or {}    
    -- default to being in the header
    if in_header==nil then
        in_header = true
    end
    song.parse = {in_header=in_header, has_notes=false, macros={}, user_macros={}, measure = options.measure or 1, no_expand=options.no_expand or false, cross_ref=options.cross_ref or false}    
    parse_abc_string(song, str)
     
    return song 
end
    
function compile_abc(str, options)
    -- parse an ABC string and compile it
    song = parse_abc(str, options) 
    compile_token_stream(song,  get_default_context(), {})    
    return song
end
    
function get_default_context()
    return   {
    tempo = {tempo_rate=120, [1]={num=1, den=8}}, 
    use_parts = false,
    meter = {num=4, den=4},
    key = { root='C', mode='maj', clef={}},
    key_mapping = {c=0,d=0,e=0,f=0,g=0,a=0,b=0},
    global_transpose = 0,
    voice_transpose = 0,
    grace_length = {num=1, den=32},
    propagate_accidentals = 'pitch',
    accidental = {},
    directives = {},
    broken_ratio=2,
    write_abc_events = false
    }
end
    
local section_matcher = re.compile([[
     abc_tunes <- (section (break section) * last_line ?) -> {}
     break <- (([ ] * %nl)  )
     section <- { (line +)  }
     line <- ( ([^%nl] +  %nl) )
     last_line <- ( ([^%nl]+) )
    ]] 
)    
function parse_abc_multisong(str, options)
         
    -- split file into sections
   
    
    str = str..'\n'
    
    -- tunes must begin with a field (although there
    -- can be directives or comments first)
    local sections = section_matcher:match(str)
    local tunes = {}    
    
    -- malformed file
    if not sections or #sections==0 then
        return {}
    end
   
    -- only include patterns with a field in them; ignore 
    -- free text blocks
    for i,v in ipairs(sections) do    
        if v:gmatch('\n[a-zA-Z]:') then            
            table.insert(tunes, v)  
        end
    end
        
    -- set defaults for the whole tune
    local default_metadata = {}
    
    local default_context = get_default_context()
    
    -- no tunes!
    if #tunes<1 then
        return {}
    end
    
    local songs = {}
    
    -- first tune might be a file header
    local first_tune = parse_abc(tunes[1], options) 
    compile_token_stream(first_tune,  default_context, default_metadata)
    table.insert(songs, first_tune)
    
    
    -- if no notes, is a global header for this whole file
    if not first_tune.parse.has_notes then
        default_metadata = first_tune.metadata
        default_context = first_tune.context
    end
    
   
    -- add remaining tunes, using file header as default, if needed
    for i,v in ipairs(tunes) do
        -- don't add first tune twice
        if i~=1 then
            local tune = parse_abc(v, options) 
            compile_token_stream(tune, deepcopy(default_context), deepcopy(default_metadata))    
            table.insert(songs, tune)
        end
    end
    
    return songs
end

function parse_abc_file(filename, options)
    -- Read a file and send it for parsing. Returns the 
    -- corresponding song table.
    local f = io.open(filename, 'r')
    local contents = f:read('*a')
    return parse_abc_multisong(contents, options)
end

function parse_abc_fragment(str, options)
    -- Parse a short abc fragment, and return the token stream table    
    options = options or {}
    local song = parse_abc(str, options, false)
    return song.token_stream
end

function compile_tokens(tokens, context)
    --Converts a token stream from a fragment into a timed event stream
    -- Returns the event stream if this is a single voice fragment, or
    -- a table of voices, if it is a multi-voice fragment
    --    
    context = context or get_default_context()
    
    local song = {token_stream=tokens}
    compile_token_stream(song, context, {})
                
    if #song.voices>1 then
        local voice_stream = {}
        -- return a table of voices
        for i,v in pairs(song.voices) do
            voice_streams[i] = {stream=v.stream, context=v.context}
        end
        return voice_streams
    else    
        -- return the default voice stream
        return song.voices['default'].stream, song.voices['default'].context    
    end
end


-- module exports
local abclua = {
name="abclua",
parse_abc_multisong = parse_abc_multisong,
parse_abc = parse_abc,
parse_abc_fragment = parse_abc_fragment,
compile_tokens = compile_tokens,
parse_abc_file = parse_abc_file,
print_notes = print_notes,
print_lyrics_notes = print_lyrics_notes,
emit_abc = emit_abc,
song_to_opus = song_to_opus,
stream_to_opus = stream_to_opus,
make_midi = make_midi,
make_midi_from_stream = make_midi_from_stream,
trim_event_stream = trim_event_stream,
render_grace_notes = render_grace_notes,
register_directive = register_directive,
abc_from_songs = abc_from_songs,
diatonic_transpose = diatonic_transpose,
get_note_stream = get_note_stream,
get_chord_stream = get_chord_stream,
abc_element = abc_element,
validate_token_stream = validate_token_stream,
filter_event_stream = filter_event_stream,
get_note_number = get_note_number,
get_bpm_from_tempo = get_bpm_from_tempo,
printable_note_name = printable_note_name,
version=0.2,
}


-- TODO:

-- Allow chords with key-relative values (e.g. "ii", "V", "V7", "I")
-- move to lua 5.1.5
-- add sqlite example
-- add tune matcher example
-- Text string encodings

-- ABCLint -> check abc files for problems

-- Midi processing routines.

-- transposing macros don't work when octave modifiers and ties are applied






--
-- From source file: parse_note.lua
--
-- Functions for parsing and canonicalising notes

function canonicalise_duration(duration)
    -- fill in duration field; remove slashes
    -- and fill in numerator and denominator
    
    if duration.slashes and not duration.den then
         local den = 1
         local l = string.len(duration.slashes)
         for i = 1,l do
            den = den * 2
         end
         duration.den = den
    end
    
    if not duration.num then
        duration.num = 1
    end
    
    if not duration.den then
        duration.den = 1
    end
    duration.slashes = nil

end

function canonicalise_accidental(accidental)
    -- Transform string indicator to integer and record any fractional part
    -- (for microtonal tuning)
    local acc = accidental[1]
    local value
    local fraction = {num=1, den=1}

    -- fractional accidentals
    if accidental[2] and (accidental[2].num or accidental[2].slashes) then
        canonicalise_duration(accidental[2])
        fraction = accidental[2] 
    end
        
    -- accidentals
    if acc == '^' then
       value = {num=fraction.num, den=fraction.den}
    end
    
    if acc == '^^' then
       value = {num=2*fraction.num, den=fraction.den}
    end
    
    if acc == '_' then
        value = {num=-fraction.num, den=fraction.den}
    end
    
    if acc == '__' then
        value = {num=-2*fraction.num, den=fraction.den}
    end
    
    if acc == '=' then
        value = {num=0, den=0}
    end
    
    return value

end

function canonicalise_note(note)
    -- Canonicalise a note, filling in the full duration field. 
    -- Remove slashes from the duration
    -- Fills in full duration field
    -- Replaces broken with an integer representing the dotted value (e.g. 0 = plain, 1 = once dotted,
    --  2 = twice, etc.)    
    canonicalise_duration(note.duration)
        
    if note.broken then
        local shift = 0
        -- get the overall shift: negative means this note gets shortened
        for c in note.broken:gmatch"." do
            
            if c == '>' then
                shift = shift + 1
            end
            if c == '<' then
                shift = shift - 1
            end
        end
        note.broken = nil
        note.duration.broken = shift
    else
        note.duration.broken = 0
    end
  
  if note.pitch then
      -- add octave shifts  
      
        local octave = 0
        if note.pitch.octave then
            for c in note.pitch.octave:gmatch"." do
                if c == "'" then
                    octave = octave + 1
                end
                if c==',' then 
                    octave = octave - 1
                end
            end
        end        
        -- +1 octave for lower case notes
        if note.pitch.note == string.lower(note.pitch.note) then
            octave = octave + 1           
        end        
        note.pitch.note = string.lower(note.pitch.note)
        note.pitch.octave = octave        
        if note.pitch.accidental then
            note.pitch.accidental  =  canonicalise_accidental(note.pitch.accidental)
        end
    end
    
    -- tied notes
    if note.tie then
        note.tie = true
    end
    
    -- parse chords
    if note.chord then        
        local chord = parse_chord(note.chord) 
        if chord then
            note.chord = chord
        else
            -- store free text annotations
            note.free_text = note.chord
            note.chord = nil
        end
    end
        
    if note.decoration then        
        -- clean up decorations (replace +xxx+ with !xxx!)    
        for i,v in ipairs(note.decoration) do            
            if string.sub(v,1,1)=='+'  then
                note.decoration[i] = '!'..string.sub(v,2,-2)..'!'
            end
        end        
    end
    
    note.duration.slashes = nil
    return note        
end

function make_note(note)
    -- Clean up a note structure. 
    -- Clean up the duration and pitch of notes and any grace notes
    -- Replace the decoration string with a sequence of decorators
    -- fix the note itself
    canonicalise_note(note)
    
    -- and the grace notes
    if note.grace then
        for i,v in ipairs(note.grace) do
            canonicalise_note(v)
        end
    end
    return note    
end

function parse_note(note)
    -- move note def into the note itself
    
    for i,v in pairs(note.note_def) do
        note[i] = v
    end
    note.note_def = nil
    return make_note(note)
    
end





--
-- From source file: meter_tempo.lua
--


local tempo_matcher = re.compile([[
tempo <- (

    (["] {:name: [^"]* :} ["] %s *) ?
    ( 
    (  (  (div (%s + div) *)  )  %s * '=' %s * {:tempo_rate: number:} )  /
    (  'C=' {:tempo_rate: number:} ) /
    (  {:tempo_rate: number :} ) 
    ) ?
    (%s + ["] {:name: [^"]* :} ["] %s *) ?
) -> {}

div <- ({:num: number:} %s * '/' %s * {:den: number:}) -> {}
number <- ( [0-9] + )
]])

-- standard tempo names
local tempo_names = {
larghissimo=40,
moderato=104,
adagissimo= 44,
allegro= 120,
allegretto= 112,
lentissimo= 48,
largo=        56,
vivace =168,
adagio=59,
vivo=180,
lento=62,
presto=192,
larghetto=66,
allegrissimo=208,
adagietto=76,
vivacissimo=220,
andante=88,
prestissimo=240,
andantino=96
}

function parse_tempo(l)
    -- Parse a tempo string
    -- Returns a tempo table, with an (optional) name and tempo_rate field
    -- tempo_rate is in units per second
    -- the numbered elements specify the unit lengths to be played up to that point
    -- each element has a "num" and "den" field to specify the numerator and denominator
    local captures = tempo_matcher:match(l)        
    if captures and captures.name and not captures.tempo_rate then    
        -- fill in rate / division if we just have a name        
        if tempo_names[captures.name] then
           captures.tempo_rate = tempo_names[captures.name]
           captures[1] = {num=1, den=4}
        end
    end
    
    return captures
end

local length_matcher = re.compile("('1' ('/' {[0-9] +}) ?) -> {}")
function parse_length(l)
    -- Parse a string giving note length, as a fraction "1/n" (or plain "1")
    -- Returns integer representing denominator.
    local captures = length_matcher:match(l)             
    if captures[1] then
        return captures[1]+0
    else
        return 1    
    end
end



function get_simplified_meter(meter)
    -- return meter as a simple num/den form
    -- with the beat emphasis separate
    -- by summing up all num elements
    -- (e.g. (2+3+2)/8 becomes 7/8)
    -- the beat emphasis is stored as
    -- emphasis = {1,3,5}

    if meter.common then
        return {num=4, den=4, emphasis={0}}
    end
    
    if meter.cut then
        return {num=2, den=2, emphasis={0}}
    end
    
    if meter.none then
        return {num=0, den=0, emphasis={0}}
    end
    
    local total_num = 0
    local emphasis = {}
    for i,v in ipairs(meter.num) do
        table.insert(emphasis, total_num)
        total_num = total_num + v
    end
    return {num=total_num, den=meter.den, emphasis=emphasis}
end

local meter_matcher = re.compile([[
    meter <- (fraction / cut / common / none) 
    common <- ({:common: 'C' :}) -> {}
    cut <- ({:cut: 'C|' :}) -> {}
    none <- ({:none: 'none' / '' :})  -> {}    
    fraction <- ({:num: complex :} %s * '/' %s * {:den: [0-9]+ :}) -> {}    
    complex <- ( '(' ? ((number + '+') * number) ->{} ')' ? )
    number <- {([0-9]+)}     
    ]])

function parse_meter(m)
    -- Parse a string giving the meter definition
    -- Returns fraction as a two element table
    local captures = meter_matcher:match(m)    
    return get_simplified_meter(captures)
    
end




--
-- From source file: register_directives.lua
--
local grace_matcher = re.compile([[ 
    length <- ({:num: (number) :} '/' {:den: (number) :}) -> {}
    number <- ([0-9]+)
    ]])


function directive_set_grace_note_length(song, directive, arguments)
    -- set the length of grace notes
    -- Directive should be of the form I:gracenotes 1/64
    if arguments[1] then
        -- extract ratio
        local ratio = grace_matcher:match(arguments[1])
        if ratio then
            song.context.grace_note_length = {num=ratio.num, den=ratio.den}
        end
    end
    update_timing(song) -- must recompute note lengths
end


function directive_abc_include(song, directive, arguments)
    -- Include a file. We can just directly invoke parse_abc_string() on 
    -- the file contents. The include file must have only one tune -- no multi-tune files
    
    local filename = arguments[1]
    if filename then
        local f = io.open(filename, 'r')            
        song.includes = song.includes or {}
        
        -- disallow include loops!
        if song.includes[filename] then
            return 
        end
        
        -- remember we included this file
        song.includes[filename] = filename
        
        -- check if the file exists
        if f then
            -- and we can read it...
            local contents = f:read('*a')
            if contents then
                -- then recursively invoke parse_abc_string
                parse_abc_string(song, contents)
            end
        end
    end
end

function directive_broken_ratio(song, directive, arguments)
        -- set the broken rhythm ratio
        local p = arguments[2]
        local q = arguments[3] or 1
        song.context.broken_ratio = p/q
end


function directive_propagate_accidentals(song, directive, arguments)
    -- Set the accidental propagation mode. Can be
    -- 'not': do not propagate accidentals
    -- 'ocatave': propagate only within an octave until end of bar
    -- 'pitch': propagate within pitch class until end of bar
    song.context.propagate_accidentals = arguments[1]
end


function directive_enable_bar_warnings(song, directive, arguments)
    -- turn on bar warnings, so that overfull and underfull bars cause
    -- warnings to be printed
    song.context.bar_warnings = true
end

function directive_set_bar_number(song, directive, arguments)
    -- set the current (or first) bar number
    song.parse.measure = tonumber(arguments[1])
    
end

register_directive('enable-bar-warnings', directive_enable_bar_warnings)
register_directive('gracenote', directive_set_grace_note_length)
register_directive('abc-include', directive_abc_include, true)
register_directive('broken-ratio', directive_broken_ratio)

register_directive('propagate-accidentals', directive_propagate_accidentals)

register_directive('setbarnb', directive_set_bar_number, true)
register_directive('measurefirst', directive_set_bar_number, true)



return abclua